
  Syntax error!
  tests/parsing/infiniteLoops/nonRecTypes.res:4:29-36

  2 ┆ include (
  3 ┆           {
  4 ┆             type t('value) = {
  5 ┆               mutable size: int,
  6 ┆               mutable root: option(node('value)),

  Type parameters require angle brackets:
  t<'value>


  Syntax error!
  tests/parsing/infiniteLoops/nonRecTypes.res:19:45-51

  17 ┆   ~size: int,
  18 ┆   ~root: option(node('value)),
  19 ┆   ~compare: Js.Internal.fn([ | `Arity_2('value, 'value)], int)
  20 ┆ ) =>
  21 ┆ t('value) =

  consecutive statements on a line must be separated by ';' or a newline


  Syntax error!
  tests/parsing/infiniteLoops/nonRecTypes.res:67:26-68:3

  65 │         };
  66 │ let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
  67 │ let rec minNode = node =>
  68 │ let findMin = rbt =>
  69 │ let removeNode = (rbt, node) => {
  70 │   let nodeToRemove =

  I'm not sure what to parse here when looking at "let".


  Syntax error!
  tests/parsing/infiniteLoops/nonRecTypes.res:68:21-69:3

  66 │ let has = (rbt, value) => _findNode(rbt, rootGet(rbt), value) !== None;
  67 │ let rec minNode = node =>
  68 │ let findMin = rbt =>
  69 │ let removeNode = (rbt, node) => {
  70 │   let nodeToRemove =
  71 │     switch (leftGet(node), rightGet(node)) {

  I'm not sure what to parse here when looking at "let".


  Syntax error!
  tests/parsing/infiniteLoops/nonRecTypes.res:434:31-38

  432 │     updateSum(Some(node), ~delta);
  433 │   };
  434 │ type nonrec oldNewVisibleNodes('value) = {
  435 │   mutable old: array('value),
  436 │   mutable new_: array('value),

  Type parameters require angle brackets:
  oldNewVisibleNodes<'value>

include
  struct
    include
      struct
        type nonrec 'value t =
          {
          mutable size: int ;
          mutable root: 'value node option ;
          compare: [ [%rescript.typehole ]] Js.Internal.fn }
        ;;(({js|Arity_2('value, 'value)], int),
                      };
                    }: {

                    }
                  );
          type t('value);
          external t:
            (
              ~size: int,
              ~root: option(node('value)),
              ~compare: Js.Internal.fn([ | |js})
          [@res.template ])
        ;;Arity_2 (value, value)
        ;;int
        ;;((t value)[@res.uapp ]) = {js||js}
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0#\0\0\0\r\0\0\0&\0\0\0#\x91\xa0\xa0A\xa0$size@\xa0\xa0A\xa0$root@\xa0\xa0A\xa0'compare@@|js}
        external sizeSet :
          ('value t -> int -> unit, [ `Has_arity2 ]) function$ = "size"
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x15\0\0\0\t\0\0\0\x1a\0\0\0\x19\xb0\xa0\xa0A\x91@\xa0\xa0A\x04\x03@E\x97\xa0$size@|js}
        ;;[|(({js|use sizeGet instead or use {abstract = light} explicitly|js})
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external size : ('value t -> int, [ `Has_arity1 ]) function$ = ""
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x10\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0$size@|js}
        ;;[|((1)[@internal.arity ])|]
        external sizeGet : ('value t -> int, [ `Has_arity1 ]) function$ = ""
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x10\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0$size@|js}
        external rootSet :
          ('value t -> 'value node option -> unit, [ `Has_arity2 ]) function$
            = "root"
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x15\0\0\0\t\0\0\0\x1a\0\0\0\x19\xb0\xa0\xa0A\x91@\xa0\xa0A\x04\x03@E\x97\xa0$root@|js}
        ;;[|(({js|use rootGet instead or use {abstract = light} explicitly|js})
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external root :
          ('value t -> 'value node option, [ `Has_arity1 ]) function$ = ""
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x10\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0$root@|js}
        ;;[|((1)[@internal.arity ])|]
        external rootGet :
          ('value t -> 'value node option, [ `Has_arity1 ]) function$ = ""
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x10\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0$root@|js}
        ;;[|(({js|use compareGet instead or use {abstract = light} explicitly|js})
            [@ocaml.deprecated ])|]
        ;;[|((1)[@internal.arity ])|]
        external compare :
          ('value t -> [ [%rescript.typehole ]] Js.Internal.fn,
            [ `Has_arity1 ]) function$
        ;;(({js|Arity_2('value, 'value)], int) =
            ""
            "BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x13\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0'compare@";
          [@internal.arity 1]
          external compareGet:
            t('value) => Js.Internal.fn([ | |js})
          [@res.template ])
        ;;Arity_2 (value, value)
        ;;int
        ;;{js||js}
        ;;{js|BS:6.0.1\x84\x95\xa6\xbe\0\0\0\x13\0\0\0\x07\0\0\0\x14\0\0\0\x13\xb0\xa0\xa0A\x91@@A\x98\xa0'compare@|js}
      end
    let has =
      ((Function$
          (fun rbt ->
             fun value ->
               ((_findNode rbt ((rootGet rbt)[@res.uapp ]) value)
                 [@res.uapp ]) != None))
      [@res.arity 2])
    let rec minNode = ((Function$ (fun node -> [%rescript.exprhole ]))
      [@res.arity 1])
    let findMin = ((Function$ (fun rbt -> [%rescript.exprhole ]))
      [@res.arity 1])
    let removeNode =
      ((Function$
          (fun rbt ->
             fun node ->
               ((let nodeToRemove =
                   match (((leftGet node)[@res.uapp ]), ((rightGet node)
                           [@res.uapp ]))
                   with
                   | (Some _, Some _) ->
                       let successor =
                         ((castNotOption
                             ((minNode ((rightGet node)[@res.uapp ]))
                             [@res.uapp ]))
                         [@res.uapp ]) in
                       (((valueSet node ((valueGet successor)[@res.uapp ]))
                        [@res.uapp ]);
                        ((heightSet node ((heightGet successor)[@res.uapp ]))
                        [@res.uapp ]);
                        successor)
                   | _ -> node in
                 let successor =
                   match ((leftGet nodeToRemove)[@res.uapp ]) with
                   | None -> ((rightGet nodeToRemove)[@res.uapp ])
                   | left -> left in
                 let (successor, isLeaf) =
                   match successor with
                   | None ->
                       let leaf =
                         ((createNode
                             ~value:((Js.Internal.raw_expr {js|0|js})
                             [@res.namedArgLoc ][@res.uapp ]) ~color:((Black)
                             [@res.namedArgLoc ]) ~height:((0.)
                             [@res.namedArgLoc ]))
                         [@res.uapp ]) in
                       let isLeaf =
                         ((Js.Internal.fn_mk1
                             ((Function$ (fun x -> x == leaf))[@res.arity 1]))
                         [@res.uapp ]) in
                       (leaf, isLeaf)
                   | Some successor ->
                       (successor,
                         ((Js.Internal.fn_mk1 ((Function$ (fun _ -> false))
                             [@res.arity 1]))[@res.uapp ])) in
                 let nodeParent = ((parentGet nodeToRemove)[@res.uapp ]) in
                 ((parentSet successor nodeParent)
                 [@res.uapp ]);
                 (match nodeParent with
                  | None -> ()
                  | Some parent ->
                      ((leftOrRightSet parent ~node:((nodeToRemove)
                          [@res.namedArgLoc ]) (Some successor))
                      [@res.uapp ]));
                 ((updateSumRecursive rbt successor)
                 [@res.uapp ]);
                 if ((colorGet nodeToRemove)[@res.uapp ]) == Black
                 then
                   (if ((colorGet successor)[@res.uapp ]) == Red
                    then
                      (((colorSet successor Black)
                       [@res.uapp ]);
                       if ((parentGet successor)[@res.uapp ]) == None
                       then ((rootSet rbt (Some successor))[@res.uapp ]))
                    else
                      (let break = ((ref false)[@res.uapp ]) in
                       let successorRef = ((ref successor)[@res.uapp ]) in
                       while not break.contents do
                         let successor = successorRef.contents in
                         match ((parentGet successor)[@res.uapp ]) with
                         | None ->
                             (((rootSet rbt (Some successor))
                              [@res.uapp ]);
                              break.contents <- true)
                         | Some successorParent ->
                             let sibling = ((siblingOf successor)
                               [@res.uapp ]) in
                             (if
                                (sibling != None) &&
                                  (((colorGet ((castNotOption sibling)
                                       [@res.uapp ]))
                                     [@res.uapp ]) == Red)
                              then
                                (((colorSet successorParent Red)
                                 [@res.uapp ]);
                                 ((colorSet ((castNotOption sibling)
                                     [@res.uapp ]) Black)
                                 [@res.uapp ]);
                                 if ((isLeft successor)[@res.uapp ])
                                 then ((rotateLeft rbt successorParent)
                                   [@res.uapp ])
                                 else ((rotateRight rbt successorParent)
                                   [@res.uapp ]));
                              (let sibling = ((siblingOf successor)
                                 [@res.uapp ]) in
                               let siblingNN = ((castNotOption sibling)
                                 [@res.uapp ]) in
                               if
                                 (((colorGet successorParent)[@res.uapp ]) ==
                                    Black)
                                   &&
                                   ((sibling == None) ||
                                      (((((colorGet siblingNN)[@res.uapp ])
                                           == Black)
                                          &&
                                          ((((leftGet siblingNN)[@res.uapp ])
                                              == None)
                                             ||
                                             (((colorGet
                                                  ((castNotOption
                                                      ((leftGet siblingNN)
                                                      [@res.uapp ]))
                                                  [@res.uapp ]))
                                                [@res.uapp ]) == Black)))
                                         &&
                                         ((((rightGet siblingNN)[@res.uapp ])
                                             == None)
                                            ||
                                            (((colorGet
                                                 ((castNotOption
                                                     ((rightGet siblingNN)
                                                     [@res.uapp ]))
                                                 [@res.uapp ]))
                                               [@res.uapp ]) == Black))))
                               then
                                 (if sibling != None
                                  then ((colorSet siblingNN Red)[@res.uapp ]);
                                  successorRef.contents <- successorParent)
                               else
                                 if
                                   (((colorGet successorParent)[@res.uapp ])
                                      == Red)
                                     &&
                                     ((sibling == None) ||
                                        (((((colorGet siblingNN)[@res.uapp ])
                                             == Black)
                                            &&
                                            ((((leftGet siblingNN)
                                                [@res.uapp ]) == None)
                                               ||
                                               (((colorGet
                                                    ((castNotOption
                                                        ((leftGet siblingNN)
                                                        [@res.uapp ]))
                                                    [@res.uapp ]))
                                                  [@res.uapp ]) == Black)))
                                           &&
                                           ((((rightGet siblingNN)
                                               [@res.uapp ]) == None)
                                              ||
                                              (((colorGet
                                                   ((castNotOption
                                                       ((rightGet siblingNN)
                                                       [@res.uapp ]))
                                                   [@res.uapp ]))
                                                 [@res.uapp ]) == Black))))
                                 then
                                   (if sibling != None
                                    then ((colorSet siblingNN Red)
                                      [@res.uapp ]);
                                    ((colorSet successorParent Black)
                                    [@res.uapp ]);
                                    break.contents <- true)
                                 else
                                   if
                                     (sibling != None) &&
                                       (((colorGet ((castNotOption sibling)
                                            [@res.uapp ]))
                                          [@res.uapp ]) == Black)
                                   then
                                     (let sibling = ((castNotOption sibling)
                                        [@res.uapp ]) in
                                      if
                                        ((((isLeft successor)[@res.uapp ]) &&
                                            ((((rightGet sibling)
                                                [@res.uapp ]) == None)
                                               ||
                                               (((colorGet
                                                    ((castNotOption
                                                        ((rightGet sibling)
                                                        [@res.uapp ]))
                                                    [@res.uapp ]))
                                                  [@res.uapp ]) == Black)))
                                           &&
                                           (((leftGet sibling)[@res.uapp ])
                                              != None))
                                          &&
                                          (((colorGet
                                               ((castNotOption
                                                   ((leftGet sibling)
                                                   [@res.uapp ]))
                                               [@res.uapp ]))
                                             [@res.uapp ]) == Red)
                                      then
                                        (((colorSet sibling Red)
                                         [@res.uapp ]);
                                         ((colorSet
                                             ((castNotOption
                                                 ((leftGet sibling)
                                                 [@res.uapp ]))[@res.uapp ])
                                             Black)
                                         [@res.uapp ]);
                                         ((rotateRight rbt sibling)
                                         [@res.uapp ]))
                                      else
                                        if
                                          (((not ((isLeft successor)
                                               [@res.uapp ]))
                                              &&
                                              ((((leftGet sibling)
                                                  [@res.uapp ]) == None)
                                                 ||
                                                 (((colorGet
                                                      ((castNotOption
                                                          ((leftGet sibling)
                                                          [@res.uapp ]))
                                                      [@res.uapp ]))
                                                    [@res.uapp ]) == Black)))
                                             &&
                                             (((rightGet sibling)
                                                [@res.uapp ]) != None))
                                            &&
                                            (((colorGet
                                                 ((castNotOption
                                                     ((rightGet sibling)
                                                     [@res.uapp ]))
                                                 [@res.uapp ]))
                                               [@res.uapp ]) == Red)
                                        then
                                          (((colorSet sibling Red)
                                           [@res.uapp ]);
                                           ((colorSet
                                               ((castNotOption
                                                   ((rightGet sibling)
                                                   [@res.uapp ]))
                                               [@res.uapp ]) Black)
                                           [@res.uapp ]);
                                           ((rotateLeft rbt sibling)
                                           [@res.uapp ]));
                                      break.contents <- true)
                                   else
                                     (let sibling = ((siblingOf successor)
                                        [@res.uapp ]) in
                                      let sibling = ((castNotOption sibling)
                                        [@res.uapp ]) in
                                      ((colorSet sibling
                                          ((colorGet successorParent)
                                          [@res.uapp ]))
                                      [@res.uapp ]);
                                      if ((isLeft successor)[@res.uapp ])
                                      then
                                        (((colorSet
                                             ((castNotOption
                                                 ((rightGet sibling)
                                                 [@res.uapp ]))[@res.uapp ])
                                             Black)
                                         [@res.uapp ]);
                                         ((rotateRight rbt successorParent)
                                         [@res.uapp ]))
                                      else
                                        (((colorSet
                                             ((castNotOption
                                                 ((leftGet sibling)
                                                 [@res.uapp ]))[@res.uapp ])
                                             Black)
                                         [@res.uapp ]);
                                         ((rotateLeft rbt successorParent)
                                         [@res.uapp ])))))
                         done));
                 if ((Js.Internal.fn_run1 isLeaf successor)[@res.uapp ])
                 then
                   (if ((rootGet rbt)[@res.uapp ]) == (Some successor)
                    then ((rootSet rbt None)[@res.uapp ]);
                    (match ((parentGet successor)[@res.uapp ]) with
                     | None -> ()
                     | Some parent ->
                         ((leftOrRightSet parent ~node:((successor)
                             [@res.namedArgLoc ]) None)
                         [@res.uapp ]))))
               [@res.braces ])))
      [@res.arity 2])
    let remove =
      ((Function$
          (fun rbt ->
             fun value ->
               match ((_findNode rbt ((rootGet rbt)[@res.uapp ]) value)
                 [@res.uapp ])
               with
               | Some node ->
                   (((removeNode rbt node)
                    [@res.uapp ]);
                    ((sizeSet rbt (((sizeGet rbt)[@res.uapp ]) - 1))
                    [@res.uapp ]);
                    Some ((heightGet node)[@res.uapp ]))
               | None -> None))
      [@res.arity 2])
    let findThroughCallback =
      ((Function$
          (fun rbt ->
             fun cb ->
               ((let rec findThroughCallback =
                   ((Function$
                       (fun rbt ->
                          fun node ->
                            fun cb ->
                              match node with
                              | None -> None
                              | Some node ->
                                  let cmp =
                                    ((Js.Internal.fn_run1 cb ((valueGet node)
                                        [@res.uapp ]))
                                    [@res.uapp ]) in
                                  if cmp == 0
                                  then Some node
                                  else
                                    if cmp < 0
                                    then
                                      ((findThroughCallback rbt
                                          ((leftGet node)[@res.uapp ]) cb)
                                      [@res.uapp ])
                                    else
                                      ((findThroughCallback rbt
                                          ((rightGet node)[@res.uapp ]) cb)
                                      [@res.uapp ])))
                   [@res.arity 3]) in
                 match ((findThroughCallback rbt ((rootGet rbt)[@res.uapp ])
                           cb)
                   [@res.uapp ])
                 with
                 | None -> None
                 | Some node -> Some ((valueGet node)[@res.uapp ]))
               [@res.braces ])))
      [@res.arity 2])
    let make =
      ((Function$
          (fun ~compare:((compare)[@res.namedArgLoc ]) ->
             ((t ~size:((0)[@res.namedArgLoc ]) ~root:((None)
                 [@res.namedArgLoc ]) ~compare:((compare)[@res.namedArgLoc ]))
             [@res.uapp ])))
      [@res.arity 1])
    let rec heightOfInterval =
      ((Function$
          (fun rbt ->
             fun node ->
               fun lhs ->
                 fun rhs ->
                   match node with
                   | None -> 0.
                   | Some n ->
                       if (lhs == None) && (rhs == None)
                       then ((sumGet n)[@res.uapp ])
                       else
                         if
                           (lhs != None) &&
                             (((Js.Internal.fn_run2 ((compareGet rbt)
                                  [@res.uapp ]) ((valueGet n)[@res.uapp ])
                                  ((castNotOption lhs)[@res.uapp ]))
                                [@res.uapp ]) < 0)
                         then
                           ((heightOfInterval rbt ((rightGet n)[@res.uapp ])
                               lhs rhs)
                           [@res.uapp ])
                         else
                           if
                             (rhs != None) &&
                               (((Js.Internal.fn_run2 ((compareGet rbt)
                                    [@res.uapp ]) ((valueGet n)[@res.uapp ])
                                    ((castNotOption rhs)[@res.uapp ]))
                                  [@res.uapp ]) > 0)
                           then
                             ((heightOfInterval rbt ((leftGet n)[@res.uapp ])
                                 lhs rhs)
                             [@res.uapp ])
                           else
                             (((heightGet n)[@res.uapp ]) +.
                                ((heightOfInterval rbt ((leftGet n)
                                    [@res.uapp ]) lhs None)
                                [@res.uapp ]))
                               +.
                               ((heightOfInterval rbt ((rightGet n)
                                   [@res.uapp ]) None rhs)
                               [@res.uapp ])))
      [@res.arity 4])
    let heightOfInterval =
      ((Function$
          (fun rbt ->
             fun lhs ->
               fun rhs ->
                 ((heightOfInterval rbt ((rootGet rbt)[@res.uapp ]) lhs rhs)
                 [@res.uapp ])))
      [@res.arity 3])
    let rec firstVisibleNode =
      ((Function$
          (fun node ->
             fun offset ->
               match node with
               | None -> None
               | Some node ->
                   if ((sumGet node)[@res.uapp ]) <= offset
                   then None
                   else
                     (let nodeHeight = ((heightGet node)[@res.uapp ]) in
                      let sumLeft =
                        match ((leftGet node)[@res.uapp ]) with
                        | None -> 0.0
                        | Some left -> ((sumGet left)[@res.uapp ]) in
                      if sumLeft > offset
                      then
                        ((firstVisibleNode ((leftGet node)[@res.uapp ])
                            offset)
                        [@res.uapp ])
                      else
                        if (sumLeft +. nodeHeight) > offset
                        then Some node
                        else
                          ((firstVisibleNode ((rightGet node)[@res.uapp ])
                              (offset -. (sumLeft +. nodeHeight)))
                          [@res.uapp ]))))
      [@res.arity 2])
    let lastVisibleNode =
      ((Function$
          (fun node ->
             fun offset ->
               match ((firstVisibleNode node offset)[@res.uapp ]) with
               | None -> ((maxNode node)[@res.uapp ])
               | first -> first))
      [@res.arity 2])
    let firstVisible =
      ((Function$
          (fun rbt ->
             fun ~offset:((offset)[@res.namedArgLoc ]) ->
               match ((firstVisibleNode ((rootGet rbt)[@res.uapp ]) offset)
                 [@res.uapp ])
               with
               | None -> None
               | Some node -> Some ((valueGet node)[@res.uapp ])))
      [@res.arity 2])
    let rec leftmost =
      ((Function$
          (fun node ->
             match ((leftGet node)[@res.uapp ]) with
             | None -> node
             | Some node -> ((leftmost node)[@res.uapp ])))
      [@res.arity 1])
    let rec firstRightParent =
      ((Function$
          (fun node ->
             match ((parentGet node)[@res.uapp ]) with
             | None -> None
             | Some parent ->
                 if ((isLeft node)[@res.uapp ])
                 then Some parent
                 else ((firstRightParent parent)[@res.uapp ])))
      [@res.arity 1])
    let nextNode =
      ((Function$
          (fun node ->
             match ((rightGet node)[@res.uapp ]) with
             | None -> ((firstRightParent node)[@res.uapp ])
             | Some right -> Some ((leftmost right)[@res.uapp ])))
      [@res.arity 1])
    let rec sumLeftSpine =
      ((Function$
          (fun node ->
             fun ~fromRightChild:((fromRightChild)[@res.namedArgLoc ]) ->
               ((let leftSpine =
                   match ((leftGet node)[@res.uapp ]) with
                   | None -> ((heightGet node)[@res.uapp ])
                   | Some left ->
                       if fromRightChild
                       then
                         ((heightGet node)[@res.uapp ]) +. ((sumGet left)
                           [@res.uapp ])
                       else 0.0 in
                 match ((parentGet node)[@res.uapp ]) with
                 | None -> leftSpine
                 | Some parent ->
                     leftSpine +.
                       ((sumLeftSpine parent
                           ~fromRightChild:((((rightGet parent)[@res.uapp ])
                                               == (Some node))
                           [@res.namedArgLoc ]))
                       [@res.uapp ]))
               [@res.braces ])))
      [@res.arity 2])
    let getY =
      ((Function$
          (fun node ->
             ((sumLeftSpine node ~fromRightChild:((true)[@res.namedArgLoc ]))
               [@res.uapp ]) -. ((heightGet node)[@res.uapp ])))
      [@res.arity 1])
    let linearSearch =
      ((Function$
          (fun rbt ->
             fun callback ->
               ((let rec find =
                   ((Function$
                       (fun node ->
                          fun callback ->
                            if
                              ((Js.Internal.fn_run1 callback ((valueGet node)
                                  [@res.uapp ]))
                              [@res.uapp ])
                            then Some ((valueGet node)[@res.uapp ])
                            else
                              (match ((nextNode node)[@res.uapp ]) with
                               | None -> None
                               | Some node -> ((find node callback)
                                   [@res.uapp ]))))
                   [@res.arity 2]) in
                 match ((minNode ((rootGet rbt)[@res.uapp ]))[@res.uapp ])
                 with
                 | None -> None
                 | Some node -> ((find node callback)[@res.uapp ]))
               [@res.braces ])))
      [@res.arity 2])
    let rec iterate =
      ((Function$
          (fun ~inclusive:((inclusive)[@res.namedArgLoc ]) ->
             fun firstNode ->
               fun lastNode ->
                 fun ~callback:((callback)[@res.namedArgLoc ]) ->
                   match firstNode with
                   | None -> ()
                   | Some node ->
                       (if inclusive
                        then ((Js.Internal.fn_run1 callback node)
                          [@res.uapp ]);
                        if firstNode != lastNode
                        then
                          (if not inclusive
                           then ((Js.Internal.fn_run1 callback node)
                             [@res.uapp ]);
                           ((iterate ~inclusive:((inclusive)
                               [@res.namedArgLoc ]) ((nextNode node)
                               [@res.uapp ]) lastNode ~callback:((callback)
                               [@res.namedArgLoc ]))
                           [@res.uapp ])))))
      [@res.arity 4])
    let rec iterateWithY =
      ((Function$
          (fun ?y:((y)[@res.namedArgLoc ]) ->
             fun ~inclusive:((inclusive)[@res.namedArgLoc ]) ->
               fun firstNode ->
                 fun lastNode ->
                   fun ~callback:((callback)[@res.namedArgLoc ]) ->
                     match firstNode with
                     | None -> ()
                     | Some node ->
                         let y =
                           match y with
                           | None -> ((getY node)[@res.uapp ])
                           | Some y -> y in
                         (if inclusive
                          then ((Js.Internal.fn_run2 callback node y)
                            [@res.uapp ]);
                          if firstNode != lastNode
                          then
                            (if not inclusive
                             then ((Js.Internal.fn_run2 callback node y)
                               [@res.uapp ]);
                             ((iterateWithY
                                 ~y:((y +. ((heightGet node)[@res.uapp ]))
                                 [@res.namedArgLoc ]) ~inclusive:((inclusive)
                                 [@res.namedArgLoc ]) ((nextNode node)
                                 [@res.uapp ]) lastNode ~callback:((callback)
                                 [@res.namedArgLoc ]))
                             [@res.uapp ])))))
      [@res.arity 5])
    let rec updateSum =
      ((Function$
          (fun node ->
             fun ~delta:((delta)[@res.namedArgLoc ]) ->
               match node with
               | None -> ()
               | Some node ->
                   (((sumSet node (((sumGet node)[@res.uapp ]) +. delta))
                    [@res.uapp ]);
                    ((updateSum ((parentGet node)[@res.uapp ])
                        ~delta:((delta)[@res.namedArgLoc ]))
                    [@res.uapp ]))))
      [@res.arity 2])
    let setHeight =
      ((Function$
          (fun rbt ->
             fun value ->
               fun ~height:((height)[@res.namedArgLoc ]) ->
                 match ((_findNode rbt ((rootGet rbt)[@res.uapp ]) value)
                   [@res.uapp ])
                 with
                 | None -> ()
                 | Some node ->
                     let delta = height -. ((heightGet node)[@res.uapp ]) in
                     (((heightSet node height)
                      [@res.uapp ]);
                      ((updateSum (Some node) ~delta:((delta)
                          [@res.namedArgLoc ]))
                      [@res.uapp ]))))
      [@res.arity 3])
    type nonrec 'value oldNewVisibleNodes =
      {
      mutable old: 'value array ;
      mutable new_: 'value array }
  end