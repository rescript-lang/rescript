
  Syntax error!
  tests/parsing/infiniteLoops/equalAfterBinaryExpr.res:169:17

  167 ┆ if isLeaf(. successor) {
  168 ┆   if rbt->root === Some(successor) {
  169 ┆     rbt->root = None
  170 ┆   }
  171 ┆ }

  Did you mean `==` here?

let rec _addLoop =
  ((Function$
      (fun rbt ->
         fun currentNode ->
           ((if (Some currentNode) == (rbt |.u root)
             then currentNode.color <- Black
             else
               if (currentNode.parent |.u castNotOption).color == Black
               then ()
               else
                 if
                   (((let uncle = ((uncleOf currentNode)[@res.uapp ]) in
                      (uncle != None) &&
                        ((uncle |.u castNotOption).color == Red)))
                   [@res.braces ])
                 then
                   ((currentNode.parent |.u castNotOption).color <- Black;
                    (((uncleOf currentNode)[@res.uapp ]) |.u castNotOption).color
                      <- Black;
                    (((grandParentOf currentNode)[@res.uapp ]) |.u
                       castNotOption).color
                      <- Red;
                    ((_addLoop rbt
                        (((grandParentOf currentNode)[@res.uapp ]) |.u
                           castNotOption))
                    [@res.uapp ]))
                 else
                   (let currentNode =
                      if
                        (not ((isLeft currentNode)[@res.uapp ])) &&
                          ((isLeft (currentNode.parent |.u castNotOption))
                          [@res.uapp ])
                      then
                        (((rotateLeft rbt
                             (currentNode.parent |.u castNotOption))
                         [@res.uapp ]);
                         currentNode.left |.u castNotOption)
                      else
                        if
                          ((isLeft currentNode)[@res.uapp ]) &&
                            (not
                               ((isLeft
                                   (currentNode.parent |.u castNotOption))
                               [@res.uapp ]))
                        then
                          (((rotateRight rbt
                               (currentNode.parent |.u castNotOption))
                           [@res.uapp ]);
                           currentNode.right |.u castNotOption)
                        else currentNode in
                    (currentNode.parent |.u castNotOption).color <- Black;
                    (((grandParentOf currentNode)[@res.uapp ]) |.u
                       castNotOption).color
                      <- Red;
                    if ((isLeft currentNode)[@res.uapp ])
                    then
                      ((rotateRight rbt
                          (((grandParentOf currentNode)[@res.uapp ]) |.u
                             castNotOption))
                      [@res.uapp ])
                    else
                      ((rotateLeft rbt
                          (((grandParentOf currentNode)[@res.uapp ]) |.u
                             castNotOption))
                      [@res.uapp ])))
           [@res.braces ])))
  [@res.arity 2])
let removeNode =
  ((Function$
      (fun rbt ->
         fun node ->
           ((if nodeToRemove.color == Black
             then
               (if successor.color == Red
                then
                  (successor.color <- Black;
                   if successor.parent == None
                   then rbt |.u ((rootSet (Some successor))[@res.uapp ]))
                else
                  (let break = ((ref false)[@res.uapp ]) in
                   let successorRef = ((ref successor)[@res.uapp ]) in
                   while not break.contents do
                     let successor = successorRef.contents in
                     match successor.parent with
                     | None ->
                         (rbt |.u ((rootSet (Some successor))[@res.uapp ]);
                          break.contents <- true)
                     | Some successorParent ->
                         let sibling = ((siblingOf successor)[@res.uapp ]) in
                         (if
                            (sibling != None) &&
                              ((sibling |.u castNotOption).color == Red)
                          then
                            (successorParent.color <- Red;
                             (sibling |.u castNotOption).color <- Black;
                             if ((isLeft successor)[@res.uapp ])
                             then ((rotateLeft rbt successorParent)
                               [@res.uapp ])
                             else ((rotateRight rbt successorParent)
                               [@res.uapp ]));
                          (let sibling = ((siblingOf successor)[@res.uapp ]) in
                           let siblingNN = sibling |.u castNotOption in
                           if
                             (successorParent.color == Black) &&
                               ((sibling == None) ||
                                  (((siblingNN.color == Black) &&
                                      ((siblingNN.left == None) ||
                                         ((siblingNN.left |.u castNotOption).color
                                            == Black)))
                                     &&
                                     ((siblingNN.right == None) ||
                                        ((siblingNN.right |.u castNotOption).color
                                           == Black))))
                           then
                             (if sibling != None then siblingNN.color <- Red;
                              successorRef.contents <- successorParent)
                           else
                             if
                               (successorParent.color == Red) &&
                                 ((sibling == None) ||
                                    (((siblingNN.color == Black) &&
                                        ((siblingNN.left == None) ||
                                           ((siblingNN.left |.u castNotOption).color
                                              == Black)))
                                       &&
                                       ((siblingNN.right == None) ||
                                          ((siblingNN.right |.u castNotOption).color
                                             == Black))))
                             then
                               (if sibling != None
                                then siblingNN.color <- Red;
                                successorParent.color <- Black;
                                break.contents <- true)
                             else
                               if
                                 (sibling != None) &&
                                   ((sibling |.u castNotOption).color ==
                                      Black)
                               then
                                 (let sibling = sibling |.u castNotOption in
                                  if
                                    ((((isLeft successor)[@res.uapp ]) &&
                                        ((sibling.right == None) ||
                                           ((sibling.right |.u castNotOption).color
                                              == Black)))
                                       && (sibling.left != None))
                                      &&
                                      ((sibling.left |.u castNotOption).color
                                         == Red)
                                  then
                                    (sibling.color <- Red;
                                     (sibling.left |.u castNotOption).color
                                       <- Black;
                                     ((rotateRight rbt sibling)
                                     [@res.uapp ]))
                                  else
                                    if
                                      (((not ((isLeft successor)[@res.uapp ]))
                                          &&
                                          ((sibling.left == None) ||
                                             ((sibling.left |.u castNotOption).color
                                                == Black)))
                                         && (sibling.right != None))
                                        &&
                                        ((sibling.right |.u castNotOption).color
                                           == Red)
                                    then
                                      (sibling.color <- Red;
                                       (sibling.right |.u castNotOption).color
                                         <- Black;
                                       ((rotateLeft rbt sibling)
                                       [@res.uapp ]));
                                  break.contents <- true)
                               else
                                 (let sibling = ((siblingOf successor)
                                    [@res.uapp ]) in
                                  let sibling = sibling |.u castNotOption in
                                  sibling.color <- (successorParent.color);
                                  if ((isLeft successor)[@res.uapp ])
                                  then
                                    ((sibling.right |.u castNotOption).color
                                       <- Black;
                                     ((rotateRight rbt successorParent)
                                     [@res.uapp ]))
                                  else
                                    ((sibling.left |.u castNotOption).color
                                       <- Black;
                                     ((rotateLeft rbt successorParent)
                                     [@res.uapp ])))))
                     done));
             if ((isLeaf successor)[@res.uapp ])
             then
               (if (rbt |.u root) == (Some successor)
                then (rbt |.u root) = None))
           [@res.braces ])))
  [@res.arity 2])