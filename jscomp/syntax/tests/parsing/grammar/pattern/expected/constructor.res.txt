let Instance = i
let Instance as inst = i
let React.Instance = i
let React.Instance as inst = i
let Instance component = i
let Instance component as inst = i
let Instance component = i
let Instance { render; subtree } = i
let Instance { render; subtree } as x = i
let Instance ({ render; subtree } as inst) = i
let Instance ({ render; subtree }, inst) = i
let Instance ({ render; subtree } : Instance.t) = i
let Instance ({ render; subtree } : Instance.t) as inst = i
let Instance ({ render; subtree } : Instance.t) = i
let Instance (component, tree) = i
let Instance (component, tree) as x = i
let Instance ((component as x), (tree as y)) = i
let Instance (component, tree) as inst = i
let Instance (component, tree) = i
let ((Instance) : React.t) = i
let (Instance : React.t) as t = i
let (Instance : React.t) as x = i
let ((Instance (component : comp)) : React.t) = i
let ((Instance (component : comp)) : React.t) = i
;;match x with
  | Instance -> ()
  | Instance as inst -> ()
  | Instance comp -> ()
  | Instance comp as inst -> ()
  | Instance { render; subtree } -> ()
  | Instance ({ render; subtree }, inst) -> ()
  | Instance ({ render; subtree } : Instance.t) -> ()
  | Instance ({ render; subtree } : Instance.t) -> ()
  | Instance (comp, tree) -> ()
  | React.Instance (comp, tree) -> ()
  | (Instance (comp : Component.t) : React.t) -> ()
let f = ((Function$ (fun (Instance) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance as i) -> i))[@res.arity 1])
let f = ((Function$ (fun (React.Instance) -> i))[@res.arity 1])
let f = ((Function$ (fun (React.Instance as x) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance component) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance component) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance { render; subtree }) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance ({ render; subtree }, inst)) -> i))
  [@res.arity 1])
let f = ((Function$ (fun (Instance ({ render; subtree } : Instance.t)) -> i))
  [@res.arity 1])
let f = ((Function$ (fun (Instance ({ render; subtree } : Instance.t)) -> i))
  [@res.arity 1])
let f = ((Function$ (fun (Instance (component, tree)) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance (component, tree)) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance : React.t) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance : React.t) -> i))[@res.arity 1])
let f = ((Function$ (fun (Instance (comp : Component.t) : React.t) -> ()))
  [@res.arity 1])
;;for Blue = x to y do () done
;;for Blue as c = x to y do () done
;;for Blue = x to y do () done
;;for Blue as c = x to y do () done
;;for (Blue : Color.t) = x to y do () done
;;for (Blue : Color.t) as c = x to y do () done
;;for (Blue : Color.t) as c = x to y do () done
;;for Rgba (r, g, b) = x to y do () done
;;for Rgba (r, g, b) as c = x to y do () done
;;for Rgba ((r : float), (g : float), (b : float)) = x to y do () done
;;for Rgba ((r : float), (g : float), (b : float)) as c = x to y do () done
;;for (Rgba (r, g, b) : Rgb.t) = x to y do () done
;;for (Rgba (r, g, b) : Rgb.t) as c = x to y do () done
;;for (Rgba (r, g, b) : Rgb.t) as c = x to y do () done
;;for Colour.Rgba (r, g, b) = x to y do () done
;;for Colour.Rgba ((r : float), (g : float), (b : float)) = x to y do () done
;;for (Colour.Rgba (r, g, b) : Rgb.t) = x to y do () done
;;for Point { x; y; z } = x to y do () done
;;for Point { x; y; z } = x to y do () done
;;for Point { x; y; z } as p = x to y do () done
;;match truth with
  | true -> Js.log {js|true|js}
  | false -> Js.log {js|false|js}