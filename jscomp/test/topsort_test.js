// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Caml = require("../../lib/js/caml.js");
let List = require("../../lib/js/list.js");
let Curry = require("../../lib/js/curry.js");
let $$String = require("../../lib/js/string.js");
let Caml_obj = require("../../lib/js/caml_obj.js");
let Pervasives = require("../../lib/js/pervasives.js");
let Caml_option = require("../../lib/js/caml_option.js");
let Caml_exceptions = require("../../lib/js/caml_exceptions.js");
let Caml_js_exceptions = require("../../lib/js/caml_js_exceptions.js");

let graph = {
  hd: [
    "a",
    "b"
  ],
  tl: {
    hd: [
      "a",
      "c"
    ],
    tl: {
      hd: [
        "a",
        "d"
      ],
      tl: {
        hd: [
          "b",
          "e"
        ],
        tl: {
          hd: [
            "c",
            "f"
          ],
          tl: {
            hd: [
              "d",
              "e"
            ],
            tl: {
              hd: [
                "e",
                "f"
              ],
              tl: {
                hd: [
                  "e",
                  "g"
                ],
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  }
};

function nexts(x, g) {
  return List.fold_left((function (acc, param) {
    if (param[0] === x) {
      return {
        hd: param[1],
        tl: acc
      };
    } else {
      return acc;
    }
  }), /* [] */0, g);
}

function dfs1(_nodes, graph, _visited) {
  while(true) {
    let visited = _visited;
    let nodes = _nodes;
    if (!nodes) {
      return List.rev(visited);
    }
    let xs = nodes.tl;
    let x = nodes.hd;
    if (List.mem(x, visited)) {
      _nodes = xs;
      continue;
    }
    console.log(x);
    _visited = {
      hd: x,
      tl: visited
    };
    _nodes = Pervasives.$at(nexts(x, graph), xs);
    continue;
  };
}

if (!Caml_obj.equal(dfs1({
    hd: "a",
    tl: /* [] */0
  }, graph, /* [] */0), {
    hd: "a",
    tl: {
      hd: "d",
      tl: {
        hd: "e",
        tl: {
          hd: "g",
          tl: {
            hd: "f",
            tl: {
              hd: "c",
              tl: {
                hd: "b",
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            35,
            2
          ]
        }
      });
}

console.log("");

if (!Caml_obj.equal(dfs1({
    hd: "b",
    tl: /* [] */0
  }, {
    hd: [
      "f",
      "d"
    ],
    tl: graph
  }, /* [] */0), {
    hd: "b",
    tl: {
      hd: "e",
      tl: {
        hd: "g",
        tl: {
          hd: "f",
          tl: {
            hd: "d",
            tl: /* [] */0
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            38,
            2
          ]
        }
      });
}

function dfs2(nodes, graph, visited) {
  let aux = function (_nodes, graph, _visited) {
    while(true) {
      let visited = _visited;
      let nodes = _nodes;
      if (!nodes) {
        return visited;
      }
      let xs = nodes.tl;
      let x = nodes.hd;
      if (List.mem(x, visited)) {
        _nodes = xs;
        continue;
      }
      _visited = aux(nexts(x, graph), graph, {
        hd: x,
        tl: visited
      });
      _nodes = xs;
      continue;
    };
  };
  return List.rev(aux(nodes, graph, visited));
}

if (!Caml_obj.equal(dfs2({
    hd: "a",
    tl: /* [] */0
  }, graph, /* [] */0), {
    hd: "a",
    tl: {
      hd: "d",
      tl: {
        hd: "e",
        tl: {
          hd: "g",
          tl: {
            hd: "f",
            tl: {
              hd: "c",
              tl: {
                hd: "b",
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            57,
            2
          ]
        }
      });
}

if (!Caml_obj.equal(dfs2({
    hd: "b",
    tl: /* [] */0
  }, {
    hd: [
      "f",
      "d"
    ],
    tl: graph
  }, /* [] */0), {
    hd: "b",
    tl: {
      hd: "e",
      tl: {
        hd: "g",
        tl: {
          hd: "f",
          tl: {
            hd: "d",
            tl: /* [] */0
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            58,
            2
          ]
        }
      });
}

function dfs3(nodes, graph) {
  let visited = {
    contents: /* [] */0
  };
  let aux = function (node, graph) {
    if (!List.mem(node, visited.contents)) {
      visited.contents = {
        hd: node,
        tl: visited.contents
      };
      return List.iter((function (x) {
        aux(x, graph);
      }), nexts(node, graph));
    }
    
  };
  List.iter((function (node) {
    aux(node, graph);
  }), nodes);
  return List.rev(visited.contents);
}

if (!Caml_obj.equal(dfs3({
    hd: "a",
    tl: /* [] */0
  }, graph), {
    hd: "a",
    tl: {
      hd: "d",
      tl: {
        hd: "e",
        tl: {
          hd: "g",
          tl: {
            hd: "f",
            tl: {
              hd: "c",
              tl: {
                hd: "b",
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            74,
            2
          ]
        }
      });
}

if (!Caml_obj.equal(dfs3({
    hd: "b",
    tl: /* [] */0
  }, {
    hd: [
      "f",
      "d"
    ],
    tl: graph
  }), {
    hd: "b",
    tl: {
      hd: "e",
      tl: {
        hd: "g",
        tl: {
          hd: "f",
          tl: {
            hd: "d",
            tl: /* [] */0
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            75,
            2
          ]
        }
      });
}

let grwork = {
  hd: [
    "wake",
    "shower"
  ],
  tl: {
    hd: [
      "shower",
      "dress"
    ],
    tl: {
      hd: [
        "dress",
        "go"
      ],
      tl: {
        hd: [
          "wake",
          "eat"
        ],
        tl: {
          hd: [
            "eat",
            "washup"
          ],
          tl: {
            hd: [
              "washup",
              "go"
            ],
            tl: /* [] */0
          }
        }
      }
    }
  }
};

function unsafe_topsort(graph) {
  let visited = {
    contents: /* [] */0
  };
  let sort_node = function (node) {
    if (List.mem(node, visited.contents)) {
      return;
    }
    let nodes = nexts(node, graph);
    List.iter(sort_node, nodes);
    visited.contents = {
      hd: node,
      tl: visited.contents
    };
  };
  List.iter((function (param) {
    sort_node(param[0]);
  }), graph);
  return visited.contents;
}

if (!Caml_obj.equal(unsafe_topsort(grwork), {
    hd: "wake",
    tl: {
      hd: "shower",
      tl: {
        hd: "dress",
        tl: {
          hd: "eat",
          tl: {
            hd: "washup",
            tl: {
              hd: "go",
              tl: /* [] */0
            }
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            112,
            9
          ]
        }
      });
}

function height(param) {
  if (typeof param !== "object") {
    return 0;
  } else {
    return param.h;
  }
}

function create(l, v, r) {
  let hl;
  hl = typeof l !== "object" ? 0 : l.h;
  let hr;
  hr = typeof r !== "object" ? 0 : r.h;
  return {
    TAG: "Node",
    l: l,
    v: v,
    r: r,
    h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
  };
}

function bal(l, v, r) {
  let hl;
  hl = typeof l !== "object" ? 0 : l.h;
  let hr;
  hr = typeof r !== "object" ? 0 : r.h;
  if (hl > (hr + 2 | 0)) {
    if (typeof l !== "object") {
      throw new Error("Invalid_argument", {
            cause: {
              RE_EXN_ID: "Invalid_argument",
              _1: "Set.bal"
            }
          });
    }
    let lr = l.r;
    let lv = l.v;
    let ll = l.l;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, create(lr, v, r));
    }
    if (typeof lr === "object") {
      return create(create(ll, lv, lr.l), lr.v, create(lr.r, v, r));
    }
    throw new Error("Invalid_argument", {
          cause: {
            RE_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          }
        });
  }
  if (hr <= (hl + 2 | 0)) {
    return {
      TAG: "Node",
      l: l,
      v: v,
      r: r,
      h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
    };
  }
  if (typeof r !== "object") {
    throw new Error("Invalid_argument", {
          cause: {
            RE_EXN_ID: "Invalid_argument",
            _1: "Set.bal"
          }
        });
  }
  let rr = r.r;
  let rv = r.v;
  let rl = r.l;
  if (height(rr) >= height(rl)) {
    return create(create(l, v, rl), rv, rr);
  }
  if (typeof rl === "object") {
    return create(create(l, v, rl.l), rl.v, create(rl.r, rv, rr));
  }
  throw new Error("Invalid_argument", {
        cause: {
          RE_EXN_ID: "Invalid_argument",
          _1: "Set.bal"
        }
      });
}

function add(x, param) {
  if (typeof param !== "object") {
    return {
      TAG: "Node",
      l: "Empty",
      v: x,
      r: "Empty",
      h: 1
    };
  }
  let r = param.r;
  let v = param.v;
  let l = param.l;
  let c = Caml.string_compare(x, v);
  if (c === 0) {
    return param;
  }
  if (c < 0) {
    let ll = add(x, l);
    if (l === ll) {
      return param;
    } else {
      return bal(ll, v, r);
    }
  }
  let rr = add(x, r);
  if (r === rr) {
    return param;
  } else {
    return bal(l, v, rr);
  }
}

function singleton(x) {
  return {
    TAG: "Node",
    l: "Empty",
    v: x,
    r: "Empty",
    h: 1
  };
}

function add_min_element(x, param) {
  if (typeof param !== "object") {
    return singleton(x);
  } else {
    return bal(add_min_element(x, param.l), param.v, param.r);
  }
}

function add_max_element(x, param) {
  if (typeof param !== "object") {
    return singleton(x);
  } else {
    return bal(param.l, param.v, add_max_element(x, param.r));
  }
}

function join(l, v, r) {
  if (typeof l !== "object") {
    return add_min_element(v, r);
  }
  let lh = l.h;
  if (typeof r !== "object") {
    return add_max_element(v, l);
  }
  let rh = r.h;
  if (lh > (rh + 2 | 0)) {
    return bal(l.l, l.v, join(l.r, v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(l, v, r.l), r.v, r.r);
  } else {
    return create(l, v, r);
  }
}

function min_elt(_param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      throw new Error("Not_found", {
            cause: {
              RE_EXN_ID: "Not_found"
            }
          });
    }
    let l = param.l;
    if (typeof l !== "object") {
      return param.v;
    }
    _param = l;
    continue;
  };
}

function min_elt_opt(_param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    let l = param.l;
    if (typeof l !== "object") {
      return Caml_option.some(param.v);
    }
    _param = l;
    continue;
  };
}

function max_elt(_param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      throw new Error("Not_found", {
            cause: {
              RE_EXN_ID: "Not_found"
            }
          });
    }
    let r = param.r;
    if (typeof r !== "object") {
      return param.v;
    }
    _param = r;
    continue;
  };
}

function max_elt_opt(_param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    let r = param.r;
    if (typeof r !== "object") {
      return Caml_option.some(param.v);
    }
    _param = r;
    continue;
  };
}

function remove_min_elt(param) {
  if (typeof param !== "object") {
    throw new Error("Invalid_argument", {
          cause: {
            RE_EXN_ID: "Invalid_argument",
            _1: "Set.remove_min_elt"
          }
        });
  }
  let l = param.l;
  if (typeof l !== "object") {
    return param.r;
  } else {
    return bal(remove_min_elt(l), param.v, param.r);
  }
}

function concat(t1, t2) {
  if (typeof t1 !== "object") {
    return t2;
  } else if (typeof t2 !== "object") {
    return t1;
  } else {
    return join(t1, min_elt(t2), remove_min_elt(t2));
  }
}

function split(x, param) {
  if (typeof param !== "object") {
    return [
      "Empty",
      false,
      "Empty"
    ];
  }
  let r = param.r;
  let v = param.v;
  let l = param.l;
  let c = Caml.string_compare(x, v);
  if (c === 0) {
    return [
      l,
      true,
      r
    ];
  }
  if (c < 0) {
    let match = split(x, l);
    return [
      match[0],
      match[1],
      join(match[2], v, r)
    ];
  }
  let match$1 = split(x, r);
  return [
    join(l, v, match$1[0]),
    match$1[1],
    match$1[2]
  ];
}

function is_empty(param) {
  if (typeof param !== "object") {
    return true;
  } else {
    return false;
  }
}

function mem(x, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return false;
    }
    let c = Caml.string_compare(x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

function remove(x, param) {
  if (typeof param !== "object") {
    return "Empty";
  }
  let r = param.r;
  let v = param.v;
  let l = param.l;
  let c = Caml.string_compare(x, v);
  if (c === 0) {
    if (typeof l !== "object") {
      return r;
    } else if (typeof r !== "object") {
      return l;
    } else {
      return bal(l, min_elt(r), remove_min_elt(r));
    }
  }
  if (c < 0) {
    let ll = remove(x, l);
    if (l === ll) {
      return param;
    } else {
      return bal(ll, v, r);
    }
  }
  let rr = remove(x, r);
  if (r === rr) {
    return param;
  } else {
    return bal(l, v, rr);
  }
}

function union(s1, s2) {
  if (typeof s1 !== "object") {
    return s2;
  }
  let h1 = s1.h;
  let v1 = s1.v;
  if (typeof s2 !== "object") {
    return s1;
  }
  let h2 = s2.h;
  let v2 = s2.v;
  if (h1 >= h2) {
    if (h2 === 1) {
      return add(v2, s1);
    }
    let match = split(v1, s2);
    return join(union(s1.l, match[0]), v1, union(s1.r, match[2]));
  }
  if (h1 === 1) {
    return add(v1, s2);
  }
  let match$1 = split(v2, s1);
  return join(union(match$1[0], s2.l), v2, union(match$1[2], s2.r));
}

function inter(s1, s2) {
  if (typeof s1 !== "object") {
    return "Empty";
  }
  if (typeof s2 !== "object") {
    return "Empty";
  }
  let r1 = s1.r;
  let v1 = s1.v;
  let l1 = s1.l;
  let match = split(v1, s2);
  let l2 = match[0];
  if (match[1]) {
    return join(inter(l1, l2), v1, inter(r1, match[2]));
  } else {
    return concat(inter(l1, l2), inter(r1, match[2]));
  }
}

function diff(s1, s2) {
  if (typeof s1 !== "object") {
    return "Empty";
  }
  if (typeof s2 !== "object") {
    return s1;
  }
  let r1 = s1.r;
  let v1 = s1.v;
  let l1 = s1.l;
  let match = split(v1, s2);
  let l2 = match[0];
  if (match[1]) {
    return concat(diff(l1, l2), diff(r1, match[2]));
  } else {
    return join(diff(l1, l2), v1, diff(r1, match[2]));
  }
}

function cons_enum(_s, _e) {
  while(true) {
    let e = _e;
    let s = _s;
    if (typeof s !== "object") {
      return e;
    }
    _e = {
      TAG: "More",
      _0: s.v,
      _1: s.r,
      _2: e
    };
    _s = s.l;
    continue;
  };
}

function compare(s1, s2) {
  let _e1 = cons_enum(s1, "End");
  let _e2 = cons_enum(s2, "End");
  while(true) {
    let e2 = _e2;
    let e1 = _e1;
    if (typeof e1 !== "object") {
      if (typeof e2 !== "object") {
        return 0;
      } else {
        return -1;
      }
    }
    if (typeof e2 !== "object") {
      return 1;
    }
    let c = Caml.string_compare(e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    _e2 = cons_enum(e2._1, e2._2);
    _e1 = cons_enum(e1._1, e1._2);
    continue;
  };
}

function equal(s1, s2) {
  return compare(s1, s2) === 0;
}

function subset(_s1, _s2) {
  while(true) {
    let s2 = _s2;
    let s1 = _s1;
    if (typeof s1 !== "object") {
      return true;
    }
    let r1 = s1.r;
    let v1 = s1.v;
    let l1 = s1.l;
    if (typeof s2 !== "object") {
      return false;
    }
    let r2 = s2.r;
    let l2 = s2.l;
    let c = Caml.string_compare(v1, s2.v);
    if (c === 0) {
      if (!subset(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue;
    }
    if (c < 0) {
      if (!subset({
          TAG: "Node",
          l: l1,
          v: v1,
          r: "Empty",
          h: 0
        }, l2)) {
        return false;
      }
      _s1 = r1;
      continue;
    }
    if (!subset({
        TAG: "Node",
        l: "Empty",
        v: v1,
        r: r1,
        h: 0
      }, r2)) {
      return false;
    }
    _s1 = l1;
    continue;
  };
}

function iter(f, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    iter(f, param.l);
    Curry._1(f, param.v);
    _param = param.r;
    continue;
  };
}

function fold(f, _s, _accu) {
  while(true) {
    let accu = _accu;
    let s = _s;
    if (typeof s !== "object") {
      return accu;
    }
    _accu = Curry._2(f, s.v, fold(f, s.l, accu));
    _s = s.r;
    continue;
  };
}

function for_all(p, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return true;
    }
    if (!Curry._1(p, param.v)) {
      return false;
    }
    if (!for_all(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue;
  };
}

function exists(p, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return false;
    }
    if (Curry._1(p, param.v)) {
      return true;
    }
    if (exists(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue;
  };
}

function filter(p, param) {
  if (typeof param !== "object") {
    return "Empty";
  }
  let r = param.r;
  let v = param.v;
  let l = param.l;
  let l$p = filter(p, l);
  let pv = Curry._1(p, v);
  let r$p = filter(p, r);
  if (pv) {
    if (l === l$p && r === r$p) {
      return param;
    } else {
      return join(l$p, v, r$p);
    }
  } else {
    return concat(l$p, r$p);
  }
}

function partition(p, param) {
  if (typeof param !== "object") {
    return [
      "Empty",
      "Empty"
    ];
  }
  let v = param.v;
  let match = partition(p, param.l);
  let lf = match[1];
  let lt = match[0];
  let pv = Curry._1(p, v);
  let match$1 = partition(p, param.r);
  let rf = match$1[1];
  let rt = match$1[0];
  if (pv) {
    return [
      join(lt, v, rt),
      concat(lf, rf)
    ];
  } else {
    return [
      concat(lt, rt),
      join(lf, v, rf)
    ];
  }
}

function cardinal(param) {
  if (typeof param !== "object") {
    return 0;
  } else {
    return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
  }
}

function elements_aux(_accu, _param) {
  while(true) {
    let param = _param;
    let accu = _accu;
    if (typeof param !== "object") {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: param.v,
      tl: elements_aux(accu, param.r)
    };
    continue;
  };
}

function elements(s) {
  return elements_aux(/* [] */0, s);
}

function find(x, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      throw new Error("Not_found", {
            cause: {
              RE_EXN_ID: "Not_found"
            }
          });
    }
    let v = param.v;
    let c = Caml.string_compare(x, v);
    if (c === 0) {
      return v;
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

function find_first(f, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      throw new Error("Not_found", {
            cause: {
              RE_EXN_ID: "Not_found"
            }
          });
    }
    let v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _param$1 = param.l;
      while(true) {
        let param$1 = _param$1;
        let v0 = _v0;
        if (typeof param$1 !== "object") {
          return v0;
        }
        let v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _v0 = v$1;
          continue;
        }
        _param$1 = param$1.r;
        continue;
      };
    }
    _param = param.r;
    continue;
  };
}

function find_first_opt(f, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    let v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _param$1 = param.l;
      while(true) {
        let param$1 = _param$1;
        let v0 = _v0;
        if (typeof param$1 !== "object") {
          return Caml_option.some(v0);
        }
        let v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _v0 = v$1;
          continue;
        }
        _param$1 = param$1.r;
        continue;
      };
    }
    _param = param.r;
    continue;
  };
}

function find_last(f, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      throw new Error("Not_found", {
            cause: {
              RE_EXN_ID: "Not_found"
            }
          });
    }
    let v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _param$1 = param.r;
      while(true) {
        let param$1 = _param$1;
        let v0 = _v0;
        if (typeof param$1 !== "object") {
          return v0;
        }
        let v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _v0 = v$1;
          continue;
        }
        _param$1 = param$1.l;
        continue;
      };
    }
    _param = param.l;
    continue;
  };
}

function find_last_opt(f, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    let v = param.v;
    if (Curry._1(f, v)) {
      let _v0 = v;
      let _param$1 = param.r;
      while(true) {
        let param$1 = _param$1;
        let v0 = _v0;
        if (typeof param$1 !== "object") {
          return Caml_option.some(v0);
        }
        let v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _v0 = v$1;
          continue;
        }
        _param$1 = param$1.l;
        continue;
      };
    }
    _param = param.l;
    continue;
  };
}

function find_opt(x, _param) {
  while(true) {
    let param = _param;
    if (typeof param !== "object") {
      return;
    }
    let v = param.v;
    let c = Caml.string_compare(x, v);
    if (c === 0) {
      return Caml_option.some(v);
    }
    _param = c < 0 ? param.l : param.r;
    continue;
  };
}

function map(f, param) {
  if (typeof param !== "object") {
    return "Empty";
  }
  let r = param.r;
  let v = param.v;
  let l = param.l;
  let l$p = map(f, l);
  let v$p = Curry._1(f, v);
  let r$p = map(f, r);
  if (l === l$p && v === v$p && r === r$p) {
    return param;
  } else if ((l$p === "Empty" || Caml.string_compare(max_elt(l$p), v$p) < 0) && (r$p === "Empty" || Caml.string_compare(v$p, min_elt(r$p)) < 0)) {
    return join(l$p, v$p, r$p);
  } else {
    return union(l$p, add(v$p, r$p));
  }
}

function of_list(l) {
  if (!l) {
    return "Empty";
  }
  let match = l.tl;
  let x0 = l.hd;
  if (!match) {
    return singleton(x0);
  }
  let match$1 = match.tl;
  let x1 = match.hd;
  if (!match$1) {
    return add(x1, singleton(x0));
  }
  let match$2 = match$1.tl;
  let x2 = match$1.hd;
  if (!match$2) {
    return add(x2, add(x1, singleton(x0)));
  }
  let match$3 = match$2.tl;
  let x3 = match$2.hd;
  if (match$3) {
    if (match$3.tl) {
      let l$1 = List.sort_uniq($$String.compare, l);
      let sub = function (n, l) {
        switch (n) {
          case 0 :
              return [
                "Empty",
                l
              ];
          case 1 :
              if (l) {
                return [
                  {
                    TAG: "Node",
                    l: "Empty",
                    v: l.hd,
                    r: "Empty",
                    h: 1
                  },
                  l.tl
                ];
              }
              break;
          case 2 :
              if (l) {
                let match = l.tl;
                if (match) {
                  return [
                    {
                      TAG: "Node",
                      l: {
                        TAG: "Node",
                        l: "Empty",
                        v: l.hd,
                        r: "Empty",
                        h: 1
                      },
                      v: match.hd,
                      r: "Empty",
                      h: 2
                    },
                    match.tl
                  ];
                }
                
              }
              break;
          case 3 :
              if (l) {
                let match$1 = l.tl;
                if (match$1) {
                  let match$2 = match$1.tl;
                  if (match$2) {
                    return [
                      {
                        TAG: "Node",
                        l: {
                          TAG: "Node",
                          l: "Empty",
                          v: l.hd,
                          r: "Empty",
                          h: 1
                        },
                        v: match$1.hd,
                        r: {
                          TAG: "Node",
                          l: "Empty",
                          v: match$2.hd,
                          r: "Empty",
                          h: 1
                        },
                        h: 2
                      },
                      match$2.tl
                    ];
                  }
                  
                }
                
              }
              break;
          default:
            
        }
        let nl = n / 2 | 0;
        let match$3 = sub(nl, l);
        let l$1 = match$3[1];
        if (l$1) {
          let match$4 = sub((n - nl | 0) - 1 | 0, l$1.tl);
          return [
            create(match$3[0], l$1.hd, match$4[0]),
            match$4[1]
          ];
        }
        throw new Error("Assert_failure", {
              cause: {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "set.res",
                  691,
                  20
                ]
              }
            });
      };
      return sub(List.length(l$1), l$1)[0];
    } else {
      return add(match$3.hd, add(x3, add(x2, add(x1, singleton(x0)))));
    }
  } else {
    return add(x3, add(x2, add(x1, singleton(x0))));
  }
}

let String_set = {
  empty: "Empty",
  is_empty: is_empty,
  mem: mem,
  add: add,
  singleton: singleton,
  remove: remove,
  union: union,
  inter: inter,
  diff: diff,
  compare: compare,
  equal: equal,
  subset: subset,
  iter: iter,
  map: map,
  fold: fold,
  for_all: for_all,
  exists: exists,
  filter: filter,
  partition: partition,
  cardinal: cardinal,
  elements: elements,
  min_elt: min_elt,
  min_elt_opt: min_elt_opt,
  max_elt: max_elt,
  max_elt_opt: max_elt_opt,
  choose: min_elt,
  choose_opt: min_elt_opt,
  split: split,
  find: find,
  find_opt: find_opt,
  find_first: find_first,
  find_first_opt: find_first_opt,
  find_last: find_last,
  find_last_opt: find_last_opt,
  of_list: of_list
};

let Cycle = /* @__PURE__ */Caml_exceptions.create("Topsort_test.Cycle");

function pathsort(graph) {
  let visited = {
    contents: /* [] */0
  };
  let empty_path = [
    "Empty",
    /* [] */0
  ];
  let $plus$great = function (node, param) {
    let stack = param[1];
    let set = param[0];
    if (mem(node, set)) {
      throw new Error(Cycle, {
            cause: {
              RE_EXN_ID: Cycle,
              _1: {
                hd: node,
                tl: stack
              }
            }
          });
    }
    return [
      add(node, set),
      {
        hd: node,
        tl: stack
      }
    ];
  };
  let sort_nodes = function (path, nodes) {
    List.iter((function (node) {
      sort_node(path, node);
    }), nodes);
  };
  let sort_node = function (path, node) {
    if (!List.mem(node, visited.contents)) {
      sort_nodes($plus$great(node, path), nexts(node, graph));
      visited.contents = {
        hd: node,
        tl: visited.contents
      };
      return;
    }
    
  };
  List.iter((function (param) {
    sort_node(empty_path, param[0]);
  }), graph);
  return visited.contents;
}

if (!Caml_obj.equal(pathsort(grwork), {
    hd: "wake",
    tl: {
      hd: "shower",
      tl: {
        hd: "dress",
        tl: {
          hd: "eat",
          tl: {
            hd: "washup",
            tl: {
              hd: "go",
              tl: /* [] */0
            }
          }
        }
      }
    }
  })) {
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            144,
            9
          ]
        }
      });
}

try {
  pathsort({
    hd: [
      "go",
      "eat"
    ],
    tl: grwork
  });
  throw new Error("Assert_failure", {
        cause: {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "topsort_test.res",
            148,
            2
          ]
        }
      });
}
catch (raw_exn){
  let exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  let exit = 0;
  if (exn.RE_EXN_ID === Cycle) {
    let match = exn._1;
    if (match && match.hd === "go") {
      let match$1 = match.tl;
      if (match$1 && match$1.hd === "washup") {
        let match$2 = match$1.tl;
        if (match$2 && match$2.hd === "eat") {
          let match$3 = match$2.tl;
          if (!(match$3 && match$3.hd === "go" && !match$3.tl)) {
            exit = 1;
          }
          
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw new Error("Assert_failure", {
          cause: {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "topsort_test.res",
              151,
              7
            ]
          }
        });
  }
  
}

exports.graph = graph;
exports.nexts = nexts;
exports.dfs1 = dfs1;
exports.dfs2 = dfs2;
exports.dfs3 = dfs3;
exports.grwork = grwork;
exports.unsafe_topsort = unsafe_topsort;
exports.String_set = String_set;
exports.Cycle = Cycle;
exports.pathsort = pathsort;
/*  Not a pure module */
