#!/usr/bin/env node
//@ts-check
"use strict";

/**
 * This script is supposed to be running in project root directory
 * It matters since we need read .sourcedirs(location)
 * and its content are file/directories with regard to project root
 */

var bsc_exe = require("./scripts/bin_path").bsc_exe;
var rescript_exe = require("./scripts/bin_path").rescript_exe;
var bsb = require("./scripts/rescript_bsb");

var cwd = process.cwd();
process.env.BSB_PROJECT_ROOT = cwd;

if (process.env.NINJA_ANSI_FORCED === undefined) {
  if (require("tty").isatty(1)) {
    process.env.NINJA_ANSI_FORCED = "1";
  }
} else {
  if (process.argv.includes("-verbose")) {
    console.log(`NINJA_ANSI_FORCED: "${process.env.NINJA_ANSI_FORCED}"`);
  }
}

const helpMessage = `Usage: rescript <options> <subcommand>

\`rescript\` is equivalent to \`rescript build\`

Options:
  -v, -version  display version number
  -h, -help     display help

Subcommands:
  build
  clean
  format
  convert
  dump
  help

Run \`rescript <subcommand> -h\` for subcommand help. Examples:
  rescript build -h
  rescript format -h`;

function onUncaughtException(err) {
  console.error("Uncaught Exception", err);
  bsb.releaseBuild();
  process.exit(1);
}

function exitProcess() {
  bsb.releaseBuild();
  process.exit(0);
}

process.on("uncaughtException", onUncaughtException);

// OS signal handlers
// Ctrl+C
process.on("SIGINT", exitProcess);
// kill pid
process.on("SIGUSR1", exitProcess);
process.on("SIGUSR2", exitProcess);
process.on("SIGTERM", exitProcess);
process.on("SIGHUP", exitProcess);

const args = process.argv.slice(2);
const argPatterns = {
  help: ['help', '-h', '-help', '--help'],
  version: ['version', '-v', '-version', '--version'],
};

const helpArgIndex = args.findIndex(arg => argPatterns.help.includes(arg));
const firstPositionalArgIndex = args.findIndex(arg => !arg.startsWith("-"));

if (helpArgIndex !== -1 && (firstPositionalArgIndex === -1 || helpArgIndex <= firstPositionalArgIndex)) {
  console.log(helpMessage);

} else if (argPatterns.version.includes(args[0])) {
  console.log(require("./package.json").version);

} else if (firstPositionalArgIndex !== -1) {
  const subcmd = args[firstPositionalArgIndex];
  const subcmdArgs = args.slice(firstPositionalArgIndex + 1);

  switch (subcmd) {
    case "info": {
      bsb.info(subcmdArgs);
      break;
    }
    case "clean": {
      bsb.clean(subcmdArgs);
      break;
    }
    case "build": {
      bsb.build(subcmdArgs);
      break;
    }
    case "format": {
      require("./scripts/rescript_format.js").main(
        subcmdArgs,
        rescript_exe,
        bsc_exe
      );
      break;
    }
    case "dump": {
      require("./scripts/rescript_dump.js").main(
        subcmdArgs,
        rescript_exe,
        bsc_exe
      );
      break;
    }
    case "convert": {
      require("./scripts/rescript_convert.js").main(
        subcmdArgs,
        rescript_exe,
        bsc_exe
      );
      break;
    }
    default: {
      console.error(
        `Error: Unknown command "${subcmd}".\n${helpMessage}`
      );
      process.exit(2);
    }
  }
} else {
  bsb.build(args);
}
