Complete src/CompletionJsx.res 3:17
posCursor:[3:17] posNoWhite:[3:16] Found expr:[3:3->3:17]
Completable: Cpath Value[someString]->st
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[someString]->st
ContextPath Value[someString]
Path someString
Path Stdlib.String.st
[{
    "label": "String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"}
  }, {
    "label": "String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"}
  }]

Complete src/CompletionJsx.res 13:21
posCursor:[13:21] posNoWhite:[13:20] Found expr:[8:13->33:3]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[9:4->32:10]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[10:4->32:10]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[11:4->32:10]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[12:4->32:10]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[13:7->32:10]
posCursor:[13:21] posNoWhite:[13:20] Found expr:[13:7->13:21]
Completable: Cpath Value[someString]->st <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[someString]->st <<jsx>>
ContextPath Value[someString]
Path someString
Path Stdlib.String.st
[{
    "label": "React.string",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": "Turns `string` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"}
  }, {
    "label": "String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"}
  }]

Complete src/CompletionJsx.res 18:24
posCursor:[18:24] posNoWhite:[18:23] Found expr:[8:13->33:3]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[9:4->32:10]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[10:4->32:10]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[11:4->32:10]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[12:4->32:10]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[18:24] posNoWhite:[18:23] Found expr:[15:8->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[16:7->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[17:7->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[17:7->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[18:10->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[18:10->32:4]
posCursor:[18:24] posNoWhite:[18:23] Found expr:[18:10->18:24]
Completable: Cpath Value[someString]->st <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[someString]->st <<jsx>>
ContextPath Value[someString]
Path someString
Path Stdlib.String.st
[{
    "label": "React.string",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": "Turns `string` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"}
  }, {
    "label": "String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"}
  }]

Complete src/CompletionJsx.res 20:27
posCursor:[20:27] posNoWhite:[20:26] Found expr:[8:13->33:3]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[9:4->32:10]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[10:4->32:10]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[11:4->32:10]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[12:4->32:10]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[20:27] posNoWhite:[20:26] Found expr:[15:8->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[16:7->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[17:7->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[17:7->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[20:10->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[20:10->32:4]
posCursor:[20:27] posNoWhite:[20:26] Found expr:[20:10->20:27]
Completable: Cpath string->st <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath string->st <<jsx>>
ContextPath string
Path Stdlib.String.st
[{
    "label": "React.string",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": "Turns `string` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"}
  }, {
    "label": "String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"}
  }]

Complete src/CompletionJsx.res 22:40
posCursor:[22:40] posNoWhite:[22:39] Found expr:[8:13->33:3]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[9:4->32:10]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[10:4->32:10]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[11:4->32:10]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[12:4->32:10]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[22:40] posNoWhite:[22:39] Found expr:[15:8->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[16:7->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[17:7->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[17:7->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[22:10->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[22:10->32:4]
posCursor:[22:40] posNoWhite:[22:39] Found expr:[22:10->22:40]
Completable: Cpath Value[String, trim](Nolabel)->st <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[String, trim](Nolabel)->st <<jsx>>
ContextPath Value[String, trim](Nolabel)
ContextPath Value[String, trim]
Path String.trim
Path Stdlib.String.st
[{
    "label": "React.string",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": "Turns `string` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"}
  }, {
    "label": "String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"}
  }]

Complete src/CompletionJsx.res 24:19
posCursor:[24:19] posNoWhite:[24:18] Found expr:[8:13->33:3]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[9:4->32:10]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[10:4->32:10]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[11:4->32:10]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[12:4->32:10]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[24:19] posNoWhite:[24:18] Found expr:[15:8->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[16:7->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[17:7->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[17:7->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[24:10->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[24:10->32:4]
posCursor:[24:19] posNoWhite:[24:18] Found expr:[24:10->0:-1]
Completable: Cpath Value[someInt]-> <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[someInt]-> <<jsx>>
ContextPath Value[someInt]
Path someInt
Path Stdlib.Int.
[{
    "label": "React.int",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": {"kind": "markdown", "value": "Turns `int` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "Int.equal",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => bool",
    "documentation": null
  }, {
    "label": "Int.toStringWithRadix",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~radix: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toString` instead\n\n\n`toStringWithRadix(n, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toStringWithRadix(6, ~radix=2) // \"110\"\nInt.toStringWithRadix(373592855, ~radix=16) // \"16449317\"\nInt.toStringWithRadix(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36.\n"}
  }, {
    "label": "Int.toExponentialWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toExponential` instead\n\n\n`toExponential(n, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\non MDN.\n\n## Examples\n\n```rescript\nInt.toExponentialWithPrecision(77, ~digits=2) // \"7.70e+1\"\nInt.toExponentialWithPrecision(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10.\n"}
  }, {
    "label": "Int.clamp",
    "kind": 12,
    "tags": [],
    "detail": "(~min: int=?, ~max: int=?, int) => int",
    "documentation": {"kind": "markdown", "value": "\n`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nInt.clamp(42) == 42\nInt.clamp(42, ~min=50) == 50\nInt.clamp(42, ~max=40) == 40\nInt.clamp(42, ~min=50, ~max=40) == 50\n```\n"}
  }, {
    "label": "Int.toFixedWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toFixed` instead\n\n\n`toFixedWithPrecision(n, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixedWithPrecision(300, ~digits=4) // \"300.0000\"\nInt.toFixedWithPrecision(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100.\n"}
  }, {
    "label": "Int.toPrecisionWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toPrecision` instead\n\n\n`toPrecisionWithPrecision(n, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecisionWithPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecisionWithPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits.\n\n"}
  }, {
    "label": "Int.compare",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => Ordering.t",
    "documentation": null
  }, {
    "label": "Int.ignore",
    "kind": 12,
    "tags": [],
    "detail": "int => unit",
    "documentation": {"kind": "markdown", "value": "\n  `ignore(int)` ignores the provided int and returns unit.\n\n  This helper is useful when you want to discard a value (for example, the result of an operation with side effects)\n  without having to store or process it further.\n"}
  }, {
    "label": "Int.toPrecision",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toPrecision(n, ~digits=?)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecision(100) // \"100\"\nInt.toPrecision(1) // \"1\"\nInt.toPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits.\n"}
  }, {
    "label": "Int.range",
    "kind": 12,
    "tags": [],
    "detail": "(int, int, ~options: rangeOptions=?) => array<int>",
    "documentation": {"kind": "markdown", "value": "\n`range(start, end, ~options=?)` returns an int array of the sequence of integers in the\nrange `[start, end)`. That is, including `start` but excluding `end`.\n\nIf `step` is not set and `start < end`, the sequence will be increasing in steps of 1.\n\nIf `step` is not set and `start > end`, the sequence will be decreasing in steps of -1.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.range(3, 6) == [3, 4, 5]\nInt.range(-3, -1) == [-3, -2]\nInt.range(3, 1) == [3, 2]\nInt.range(3, 7, ~options={step: 2}) == [3, 5]\nInt.range(3, 7, ~options={step: 2, inclusive: true}) == [3, 5, 7]\nInt.range(3, 6, ~options={step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`.\n"}
  }, {
    "label": "Int.toString",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~radix: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toString(n, ~radix=?)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toString(1000) // \"1000\"\nInt.toString(-1000) // \"-1000\"\nInt.toString(6, ~radix=2) // \"110\"\nInt.toString(373592855, ~radix=16) // \"16449317\"\nInt.toString(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36.\n"}
  }, {
    "label": "Int.toFloat",
    "kind": 12,
    "tags": [],
    "detail": "int => float",
    "documentation": {"kind": "markdown", "value": "\n`toFloat(n)` return a `float` representing the given value.\n\n## Examples\n\n```rescript\nInt.toFloat(100) == 100.0\nInt.toFloat(2) == 2.0\n```\n"}
  }, {
    "label": "Int.mod",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": "\n`mod(n1, n2)` calculates the modulo (remainder after division) of two integers.\n\n## Examples\n\n```rescript\nInt.mod(7, 4) == 3\n```\n"}
  }, {
    "label": "Int.rangeWithOptions",
    "kind": 12,
    "tags": [1],
    "detail": "(int, int, rangeOptions) => array<int>",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `range` instead\n\n\n`rangeWithOptions(start, end, options)` is like `range`, but with `step` and\n`inclusive` options configurable.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.rangeWithOptions(3, 7, {step: 2}) == [3, 5]\nInt.rangeWithOptions(3, 7, {step: 2, inclusive: true}) == [3, 5, 7]\nInt.rangeWithOptions(3, 6, {step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`.\n"}
  }, {
    "label": "Int.toLocaleString",
    "kind": 12,
    "tags": [],
    "detail": "int => string",
    "documentation": {"kind": "markdown", "value": "\n`toLocaleString(n)` return a `string` with language-sensitive representing the\ngiven value. See [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nInt.toLocaleString(1000) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nInt.toLocaleString(1000) // \"1.000\"\n```\n"}
  }, {
    "label": "Int.toExponential",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toExponential(n, ~digits=?)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\n\n## Examples\n\n```rescript\nInt.toExponential(1000) // \"1e+3\"\nInt.toExponential(-1000) // \"-1e+3\"\nInt.toExponential(77, ~digits=2) // \"7.70e+1\"\nInt.toExponential(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10.\n"}
  }, {
    "label": "Int.toFixed",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toFixed(n, ~digits=?)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixed(123456) // \"123456.00\"\nInt.toFixed(10) // \"10.00\"\nInt.toFixed(300, ~digits=4) // \"300.0000\"\nInt.toFixed(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100.\n"}
  }]

Complete src/CompletionJsx.res 26:14
posCursor:[26:14] posNoWhite:[26:13] Found expr:[8:13->33:3]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[9:4->32:10]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[10:4->32:10]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[11:4->32:10]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[12:4->32:10]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[26:14] posNoWhite:[26:13] Found expr:[15:8->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[16:7->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[17:7->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[17:7->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[26:10->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[26:10->32:4]
posCursor:[26:14] posNoWhite:[26:13] Found expr:[26:10->0:-1]
Completable: Cpath int-> <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath int-> <<jsx>>
ContextPath int
Path Stdlib.Int.
[{
    "label": "React.int",
    "kind": 12,
    "tags": [],
    "detail": "int",
    "documentation": {"kind": "markdown", "value": "Turns `int` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "Int.equal",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => bool",
    "documentation": null
  }, {
    "label": "Int.toStringWithRadix",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~radix: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toString` instead\n\n\n`toStringWithRadix(n, ~radix)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toStringWithRadix(6, ~radix=2) // \"110\"\nInt.toStringWithRadix(373592855, ~radix=16) // \"16449317\"\nInt.toStringWithRadix(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36.\n"}
  }, {
    "label": "Int.toExponentialWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toExponential` instead\n\n\n`toExponential(n, ~digits)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\non MDN.\n\n## Examples\n\n```rescript\nInt.toExponentialWithPrecision(77, ~digits=2) // \"7.70e+1\"\nInt.toExponentialWithPrecision(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10.\n"}
  }, {
    "label": "Int.clamp",
    "kind": 12,
    "tags": [],
    "detail": "(~min: int=?, ~max: int=?, int) => int",
    "documentation": {"kind": "markdown", "value": "\n`clamp(~min=?, ~max=?, value)` returns `value`, optionally bounded by `min` and `max`.\n\nif `max` < `min` returns `min`.\n\n## Examples\n\n```rescript\nInt.clamp(42) == 42\nInt.clamp(42, ~min=50) == 50\nInt.clamp(42, ~max=40) == 40\nInt.clamp(42, ~min=50, ~max=40) == 50\n```\n"}
  }, {
    "label": "Int.toFixedWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toFixed` instead\n\n\n`toFixedWithPrecision(n, ~digits)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixedWithPrecision(300, ~digits=4) // \"300.0000\"\nInt.toFixedWithPrecision(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100.\n"}
  }, {
    "label": "Int.toPrecisionWithPrecision",
    "kind": 12,
    "tags": [1],
    "detail": "(int, ~digits: int) => string",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `toPrecision` instead\n\n\n`toPrecisionWithPrecision(n, ~digits)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecisionWithPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecisionWithPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits.\n\n"}
  }, {
    "label": "Int.compare",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => Ordering.t",
    "documentation": null
  }, {
    "label": "Int.ignore",
    "kind": 12,
    "tags": [],
    "detail": "int => unit",
    "documentation": {"kind": "markdown", "value": "\n  `ignore(int)` ignores the provided int and returns unit.\n\n  This helper is useful when you want to discard a value (for example, the result of an operation with side effects)\n  without having to store or process it further.\n"}
  }, {
    "label": "Int.toPrecision",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toPrecision(n, ~digits=?)` return a `string` representing the giver value with\nprecision. `digits` specifies the number of significant digits. See [`Number.toPrecision`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision) on MDN.\n\n## Examples\n\n```rescript\nInt.toPrecision(100) // \"100\"\nInt.toPrecision(1) // \"1\"\nInt.toPrecision(100, ~digits=2) // \"1.0e+2\"\nInt.toPrecision(1, ~digits=2) // \"1.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is not between 1 and 100 (inclusive).\nImplementations are allowed to support larger and smaller values as well.\nECMA-262 only requires a precision of up to 21 significant digits.\n"}
  }, {
    "label": "Int.range",
    "kind": 12,
    "tags": [],
    "detail": "(int, int, ~options: rangeOptions=?) => array<int>",
    "documentation": {"kind": "markdown", "value": "\n`range(start, end, ~options=?)` returns an int array of the sequence of integers in the\nrange `[start, end)`. That is, including `start` but excluding `end`.\n\nIf `step` is not set and `start < end`, the sequence will be increasing in steps of 1.\n\nIf `step` is not set and `start > end`, the sequence will be decreasing in steps of -1.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.range(3, 6) == [3, 4, 5]\nInt.range(-3, -1) == [-3, -2]\nInt.range(3, 1) == [3, 2]\nInt.range(3, 7, ~options={step: 2}) == [3, 5]\nInt.range(3, 7, ~options={step: 2, inclusive: true}) == [3, 5, 7]\nInt.range(3, 6, ~options={step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`.\n"}
  }, {
    "label": "Int.toString",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~radix: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toString(n, ~radix=?)` return a `string` representing the given value.\n`~radix` specifies the radix base to use for the formatted number.\nSee [`Number.toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\non MDN.\n\n## Examples\n\n```rescript\nInt.toString(1000) // \"1000\"\nInt.toString(-1000) // \"-1000\"\nInt.toString(6, ~radix=2) // \"110\"\nInt.toString(373592855, ~radix=16) // \"16449317\"\nInt.toString(123456, ~radix=36) // \"2n9c\"\n```\n\n## Exceptions\n\n`RangeError`: if `radix` is less than 2 or greater than 36.\n"}
  }, {
    "label": "Int.toFloat",
    "kind": 12,
    "tags": [],
    "detail": "int => float",
    "documentation": {"kind": "markdown", "value": "\n`toFloat(n)` return a `float` representing the given value.\n\n## Examples\n\n```rescript\nInt.toFloat(100) == 100.0\nInt.toFloat(2) == 2.0\n```\n"}
  }, {
    "label": "Int.mod",
    "kind": 12,
    "tags": [],
    "detail": "(int, int) => int",
    "documentation": {"kind": "markdown", "value": "\n`mod(n1, n2)` calculates the modulo (remainder after division) of two integers.\n\n## Examples\n\n```rescript\nInt.mod(7, 4) == 3\n```\n"}
  }, {
    "label": "Int.rangeWithOptions",
    "kind": 12,
    "tags": [1],
    "detail": "(int, int, rangeOptions) => array<int>",
    "documentation": {"kind": "markdown", "value": "Deprecated: Use `range` instead\n\n\n`rangeWithOptions(start, end, options)` is like `range`, but with `step` and\n`inclusive` options configurable.\n\nIf `step` is set, the sequence will increase or decrease by that amount for each\nstep. If `start < end` and `step` is negative, or vice versa, an empty array is\nreturned since the sequence would otherwise never reach or exceed the end value\nand hence be infinite. If `step` is `0` and `start !=` end, a `RangeError` is\nraised as the sequence would never reach or exceed the end value and hence be\ninfinite.\n\nIf `inclusive` is set to `true`, the sequence will include `end` if `step` is\nset such that the sequence includes it.\n\n## Examples\n\n```rescript\nInt.rangeWithOptions(3, 7, {step: 2}) == [3, 5]\nInt.rangeWithOptions(3, 7, {step: 2, inclusive: true}) == [3, 5, 7]\nInt.rangeWithOptions(3, 6, {step: -2}) // RangeError\n```\n\n## Exceptions\n\n- Raises `RangeError` if `step == 0 && start != end`.\n"}
  }, {
    "label": "Int.toLocaleString",
    "kind": 12,
    "tags": [],
    "detail": "int => string",
    "documentation": {"kind": "markdown", "value": "\n`toLocaleString(n)` return a `string` with language-sensitive representing the\ngiven value. See [`Number.toLocaleString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString) on MDN.\n\n## Examples\n\n```rescript\n// If the application uses English as the default language\nInt.toLocaleString(1000) // \"1,000\"\n\n// If the application uses Portuguese Brazil as the default language\nInt.toLocaleString(1000) // \"1.000\"\n```\n"}
  }, {
    "label": "Int.toExponential",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toExponential(n, ~digits=?)` return a `string` representing the given value in\nexponential notation. `digits` specifies how many digits should appear after\nthe decimal point. See [`Number.toExponential`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)\n\n## Examples\n\n```rescript\nInt.toExponential(1000) // \"1e+3\"\nInt.toExponential(-1000) // \"-1e+3\"\nInt.toExponential(77, ~digits=2) // \"7.70e+1\"\nInt.toExponential(5678, ~digits=2) // \"5.68e+3\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` less than 0 or greater than 10.\n"}
  }, {
    "label": "Int.toFixed",
    "kind": 12,
    "tags": [],
    "detail": "(int, ~digits: int=?) => string",
    "documentation": {"kind": "markdown", "value": "\n`toFixed(n, ~digits=?)` return a `string` representing the given\nvalue using fixed-point notation. `digits` specifies how many digits should\nappear after the decimal point. See [`Number.toFixed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)\non MDN.\n\n## Examples\n\n```rescript\nInt.toFixed(123456) // \"123456.00\"\nInt.toFixed(10) // \"10.00\"\nInt.toFixed(300, ~digits=4) // \"300.0000\"\nInt.toFixed(300, ~digits=1) // \"300.0\"\n```\n\n## Exceptions\n\n- `RangeError`: If `digits` is less than 0 or larger than 100.\n"}
  }]

Complete src/CompletionJsx.res 28:20
posCursor:[28:20] posNoWhite:[28:19] Found expr:[8:13->33:3]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[9:4->32:10]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[10:4->32:10]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[11:4->32:10]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[12:4->32:10]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[28:20] posNoWhite:[28:19] Found expr:[15:8->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[16:7->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[17:7->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[17:7->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[28:10->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[28:10->32:4]
posCursor:[28:20] posNoWhite:[28:19] Found expr:[28:10->28:20]
Completable: Cpath Value[someArr]->a <<jsx>>
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath Value[someArr]->a <<jsx>>
ContextPath Value[someArr]
Path someArr
Path Stdlib.Array.a
[{
    "label": "React.array",
    "kind": 12,
    "tags": [],
    "detail": "array<React.element>",
    "documentation": {"kind": "markdown", "value": "Turns `array` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertTextFormat": 2
  }, {
    "label": "Array.at",
    "kind": 12,
    "tags": [],
    "detail": "(array<'a>, int) => option<'a>",
    "documentation": {"kind": "markdown", "value": "\n`at(array, index)`\n\nGet an element by its index. Negative indices count backwards from the last item.\n\n## Examples\n\n```rescript\n[\"a\", \"b\", \"c\"]->Array.at(0)->assertEqual(Some(\"a\"))\n[\"a\", \"b\", \"c\"]->Array.at(2)->assertEqual(Some(\"c\"))\n[\"a\", \"b\", \"c\"]->Array.at(3)->assertEqual(None)\n[\"a\", \"b\", \"c\"]->Array.at(-1)->assertEqual(Some(\"c\"))\n[\"a\", \"b\", \"c\"]->Array.at(-3)->assertEqual(Some(\"a\"))\n[\"a\", \"b\", \"c\"]->Array.at(-4)->assertEqual(None)\n```\n"}
  }]

Complete src/CompletionJsx.res 30:12
posCursor:[30:12] posNoWhite:[30:11] Found expr:[8:13->33:3]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[9:4->32:10]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[10:4->32:10]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[11:4->32:10]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[12:4->32:10]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[15:5->32:10]
JSX <div:[15:5->15:8] > _children:15:8
posCursor:[30:12] posNoWhite:[30:11] Found expr:[15:8->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[16:7->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[17:7->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[17:7->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[30:10->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[30:10->33:2]
posCursor:[30:12] posNoWhite:[30:11] Found expr:[30:10->32:10]
JSX <di:[30:10->30:12] div[32:6->32:9]=...[32:6->32:9]> _children:32:9
Completable: ChtmlElement <di
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
[{
    "label": "<dialog>",
    "kind": 4,
    "tags": [],
    "detail": "Defines a dialog box or subwindow.",
    "documentation": {"kind": "markdown", "value": "Defines a dialog box or subwindow."},
    "insertText": "dialog"
  }, {
    "label": "<dir>",
    "kind": 4,
    "tags": [1],
    "detail": "Defines a directory list. Use <ul> instead.",
    "documentation": {"kind": "markdown", "value": "Deprecated: true\n\nDefines a directory list. Use <ul> instead."},
    "insertText": "dir"
  }, {
    "label": "<div>",
    "kind": 4,
    "tags": [],
    "detail": "Specifies a division or a section in a document.",
    "documentation": {"kind": "markdown", "value": "Specifies a division or a section in a document."},
    "insertText": "div"
  }]

Complete src/CompletionJsx.res 45:23
posCursor:[45:23] posNoWhite:[45:22] Found expr:[45:4->45:23]
JSX <CompWithoutJsxPpx:[45:4->45:21] n[45:22->45:23]=...[45:22->45:23]> _children:None
Completable: Cjsx([CompWithoutJsxPpx], n, [n])
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
Path CompWithoutJsxPpx.make
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/CompletionJsx.res 48:27
posCursor:[48:27] posNoWhite:[48:26] Found expr:[48:4->48:28]
JSX <SomeComponent:[48:4->48:17] someProp[48:18->48:26]=...[48:18->48:26]> _children:None
Completable: Cexpression CJsxPropValue [SomeComponent] someProp
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath CJsxPropValue [SomeComponent] someProp
Path SomeComponent.make
[{
    "label": "\"\"",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": null,
    "sortText": "A",
    "insertText": "{\"$0\"}",
    "insertTextFormat": 2
  }]

Complete src/CompletionJsx.res 51:11
posCursor:[51:11] posNoWhite:[51:10] Found expr:[51:4->51:11]
JSX <h1:[51:4->51:6] hidd[51:7->51:11]=...[51:7->51:11]> _children:None
Completable: Cjsx([h1], hidd, [hidd])
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
Path ReactDOM.domProps
Path JsxDOM.domProps
[{
    "label": "hidden",
    "kind": 4,
    "tags": [],
    "detail": "bool",
    "documentation": null
  }]

Complete src/CompletionJsx.res 61:30
posCursor:[61:30] posNoWhite:[61:28] Found expr:[61:4->61:29]
JSX <IntrinsicElementLowercase:[61:4->61:29] > _children:None
Completable: Cjsx([IntrinsicElementLowercase], "", [])
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
Path IntrinsicElementLowercase.make
[{
    "label": "name",
    "kind": 4,
    "tags": [],
    "detail": "option<string>",
    "documentation": null
  }, {
    "label": "age",
    "kind": 4,
    "tags": [],
    "detail": "option<int>",
    "documentation": null
  }, {
    "label": "key",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/CompletionJsx.res 73:36
posCursor:[73:36] posNoWhite:[73:35] Found expr:[73:4->73:41]
JSX <MultiPropComp:[73:4->73:17] name[73:18->73:22]=...[73:23->73:30] time[73:31->73:35]=...[73:37->73:40]> _children:None
Completable: Cexpression CJsxPropValue [MultiPropComp] time
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath CJsxPropValue [MultiPropComp] time
Path MultiPropComp.make
[{
    "label": "Now",
    "kind": 4,
    "tags": [],
    "detail": "Now",
    "documentation": {"kind": "markdown", "value": "```rescript\nNow\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Now}",
    "insertTextFormat": 2
  }, {
    "label": "Later",
    "kind": 4,
    "tags": [],
    "detail": "Later",
    "documentation": {"kind": "markdown", "value": "```rescript\nLater\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Later}",
    "insertTextFormat": 2
  }]

Complete src/CompletionJsx.res 76:36
posCursor:[76:36] posNoWhite:[76:35] Found expr:[76:4->76:40]
JSX <MultiPropComp:[76:4->76:17] name[76:18->76:22]=...[76:23->76:30] time[76:31->76:35]=...[76:37->76:40]> _children:None
Completable: Cexpression CJsxPropValue [MultiPropComp] time
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath CJsxPropValue [MultiPropComp] time
Path MultiPropComp.make
[{
    "label": "Now",
    "kind": 4,
    "tags": [],
    "detail": "Now",
    "documentation": {"kind": "markdown", "value": "```rescript\nNow\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Now}",
    "insertTextFormat": 2
  }, {
    "label": "Later",
    "kind": 4,
    "tags": [],
    "detail": "Later",
    "documentation": {"kind": "markdown", "value": "```rescript\nLater\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Later}",
    "insertTextFormat": 2
  }]

Complete src/CompletionJsx.res 79:28
posCursor:[79:28] posNoWhite:[79:27] Found expr:[79:4->79:32]
JSX <MultiPropComp:[79:4->79:17] name[79:18->79:22]=...[79:18->79:22] time[79:23->79:27]=...[79:29->79:32]> _children:None
Completable: Cexpression CJsxPropValue [MultiPropComp] time
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath CJsxPropValue [MultiPropComp] time
Path MultiPropComp.make
[{
    "label": "Now",
    "kind": 4,
    "tags": [],
    "detail": "Now",
    "documentation": {"kind": "markdown", "value": "```rescript\nNow\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Now}",
    "insertTextFormat": 2
  }, {
    "label": "Later",
    "kind": 4,
    "tags": [],
    "detail": "Later",
    "documentation": {"kind": "markdown", "value": "```rescript\nLater\n```\n\n```rescript\ntype time = Now | Later\n```"},
    "insertText": "{Later}",
    "insertTextFormat": 2
  }]

Complete src/CompletionJsx.res 89:26
posCursor:[89:26] posNoWhite:[89:24] Found expr:[89:4->89:27]
JSX <Info:[89:4->89:8] _type[89:9->89:14]=...[89:16->89:24]> _children:89:26
Completable: Cjsx([Info], "", [_type])
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
Path Info.make
[{
    "label": "key",
    "kind": 4,
    "tags": [],
    "detail": "string",
    "documentation": null
  }]

Complete src/CompletionJsx.res 93:19
posCursor:[93:19] posNoWhite:[93:18] Found expr:[93:12->93:24]
JSX <p:[93:12->93:13] > _children:93:13
posCursor:[93:19] posNoWhite:[93:18] Found expr:[93:13->93:20]
posCursor:[93:19] posNoWhite:[93:18] Found expr:[93:15->93:20]
posCursor:[93:19] posNoWhite:[93:18] Found expr:[93:15->93:19]
Pexp_field [93:15->93:17] s:[93:18->93:19]
Completable: Cpath string.s
Package opens Stdlib.place holder Pervasives.JsxModules.place holder
Resolved opens 1 Stdlib
ContextPath string.s
ContextPath string
ContextPath string->s <<jsx>>
ContextPath string
Path Stdlib.String.s
[{
    "label": "->React.string",
    "kind": 12,
    "tags": [],
    "detail": "string",
    "documentation": {"kind": "markdown", "value": "Turns `string` into a JSX element so it can be used inside of JSX."},
    "sortText": "A",
    "insertText": "->React.string",
    "insertTextFormat": 2,
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.searchOpt",
    "kind": 12,
    "tags": [],
    "detail": "(string, RegExp.t) => option<int>",
    "documentation": {"kind": "markdown", "value": "\n`searchOpt(str, regexp)`. Like `search`, but return an `option<int>`.\n\n## Examples\n\n```rescript\nString.searchOpt(\"testing 1 2 3\", %re(\"/\\d+/\")) == Some(8)\nString.searchOpt(\"no numbers\", %re(\"/\\d+/\")) == None\n```\n"},
    "sortText": "searchOpt",
    "insertText": "->String.searchOpt",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.splitByRegExpAtMost",
    "kind": 12,
    "tags": [],
    "detail": "(string, RegExp.t, ~limit: int) => array<option<string>>",
    "documentation": {"kind": "markdown", "value": "\n`splitByRegExpAtMost(str, regexp, ~limit)` splits the given `str` at every\noccurrence of `regexp` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings, the\narray will contain all the substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExpAtMost(\"Hello World. How are you doing?\", %re(\"/ /\"), ~limit=3) == [\n  Some(\"Hello\"),\n  Some(\"World.\"),\n  Some(\"How\"),\n]\n```\n"},
    "sortText": "splitByRegExpAtMost",
    "insertText": "->String.splitByRegExpAtMost",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.slice",
    "kind": 12,
    "tags": [],
    "detail": "(string, ~start: int, ~end: int) => string",
    "documentation": {"kind": "markdown", "value": "\n`slice(str, ~start, ~end)` returns the substring of `str` starting at\ncharacter `start` up to but not including `end`.\n- If either `start` or `end` is negative, then it is evaluated as\n`length(str - start)` or `length(str - end)`.\n- If `end` is greater than the length of `str`, then it is treated as\n`length(str)`.\n- If `start` is greater than `end`, slice returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.slice(\"abcdefg\", ~start=2, ~end=5) == \"cde\"\nString.slice(\"abcdefg\", ~start=2, ~end=9) == \"cdefg\"\nString.slice(\"abcdefg\", ~start=-4, ~end=-2) == \"de\"\nString.slice(\"abcdefg\", ~start=5, ~end=1) == \"\"\n```\n"},
    "sortText": "slice",
    "insertText": "->String.slice",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.substringToEnd",
    "kind": 12,
    "tags": [],
    "detail": "(string, ~start: int) => string",
    "documentation": {"kind": "markdown", "value": "\n`substringToEnd(str, ~start)` returns the substring of `str` from position\n`start` to the end.\n- If `start` is less than or equal to zero, the entire string is returned.\n- If `start` is greater than or equal to the length of `str`, the empty string\nis returned.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substringToEnd(\"playground\", ~start=4) == \"ground\"\nString.substringToEnd(\"playground\", ~start=-3) == \"playground\"\nString.substringToEnd(\"playground\", ~start=12) == \"\"\n```\n"},
    "sortText": "substringToEnd",
    "insertText": "->String.substringToEnd",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.startsWith",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWith(str, substr)` returns `true` if the `str` starts with `substr`,\n`false` otherwise.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWith(\"BuckleScript\", \"Buckle\") == true\nString.startsWith(\"BuckleScript\", \"\") == true\nString.startsWith(\"JavaScript\", \"Buckle\") == false\n```\n"},
    "sortText": "startsWith",
    "insertText": "->String.startsWith",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.splitAtMost",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, ~limit: int) => array<string>",
    "documentation": {"kind": "markdown", "value": "\n`splitAtMost(str, delimiter, ~limit)` splits the given `str` at every\noccurrence of `delimiter` and returns an array of the first `limit` resulting\nsubstrings. If `limit` is negative or greater than the number of substrings,\nthe array will contain all the substrings.\n\n## Examples\n\n```rescript\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=3) == [\"ant\", \"bee\", \"cat\"]\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=0) == []\nString.splitAtMost(\"ant/bee/cat/dog/elk\", \"/\", ~limit=9) == [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n```\n"},
    "sortText": "splitAtMost",
    "insertText": "->String.splitAtMost",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.sliceToEnd",
    "kind": 12,
    "tags": [],
    "detail": "(string, ~start: int) => string",
    "documentation": {"kind": "markdown", "value": "\n`sliceToEnd(str, ~start)` returns the substring of `str` starting at character\n`start` to the end of the string.\n- If `start` is negative, then it is evaluated as `length(str - start)`.\n- If `start` is greater than the length of `str`, then sliceToEnd returns the empty string.\nSee [`String.slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) on MDN.\n\n## Examples\n\n```rescript\nString.sliceToEnd(\"abcdefg\", ~start=4) == \"efg\"\nString.sliceToEnd(\"abcdefg\", ~start=-2) == \"fg\"\nString.sliceToEnd(\"abcdefg\", ~start=7) == \"\"\n```\n"},
    "sortText": "sliceToEnd",
    "insertText": "->String.sliceToEnd",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.setSymbol",
    "kind": 12,
    "tags": [],
    "detail": "(string, Symbol.t, 'a) => unit",
    "documentation": null,
    "sortText": "setSymbol",
    "insertText": "->String.setSymbol",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.splitByRegExp",
    "kind": 12,
    "tags": [],
    "detail": "(string, RegExp.t) => array<option<string>>",
    "documentation": {"kind": "markdown", "value": "\n`splitByRegExp(str, regexp)` splits the given `str` at every occurrence of\n`regexp` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.splitByRegExp(\"Jan,Feb,Mar\", %re(\"/,/\")) == [Some(\"Jan\"), Some(\"Feb\"), Some(\"Mar\")]\n```\n"},
    "sortText": "splitByRegExp",
    "insertText": "->String.splitByRegExp",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.startsWithFrom",
    "kind": 12,
    "tags": [],
    "detail": "(string, string, int) => bool",
    "documentation": {"kind": "markdown", "value": "\n`startsWithFrom(str, substr, n)` returns `true` if the `str` starts\nwith `substr` starting at position `n`, `false` otherwise. If `n` is negative,\nthe search starts at the beginning of `str`.\nSee [`String.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) on MDN.\n\n## Examples\n\n```rescript\nString.startsWithFrom(\"BuckleScript\", \"kle\", 3) == true\nString.startsWithFrom(\"BuckleScript\", \"\", 3) == true\nString.startsWithFrom(\"JavaScript\", \"Buckle\", 2) == false\n```\n"},
    "sortText": "startsWithFrom",
    "insertText": "->String.startsWithFrom",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.split",
    "kind": 12,
    "tags": [],
    "detail": "(string, string) => array<string>",
    "documentation": {"kind": "markdown", "value": "\n`split(str, delimiter)` splits the given `str` at every occurrence of\n`delimiter` and returns an array of the resulting substrings.\nSee [`String.split`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split) on MDN.\n\n## Examples\n\n```rescript\nString.split(\"2018-01-02\", \"-\") == [\"2018\", \"01\", \"02\"]\nString.split(\"a,b,,c\", \",\") == [\"a\", \"b\", \"\", \"c\"]\nString.split(\"good::bad as great::awful\", \"::\") == [\"good\", \"bad as great\", \"awful\"]\nString.split(\"has-no-delimiter\", \";\") == [\"has-no-delimiter\"]\n```\n"},
    "sortText": "split",
    "insertText": "->String.split",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.substring",
    "kind": 12,
    "tags": [],
    "detail": "(string, ~start: int, ~end: int) => string",
    "documentation": {"kind": "markdown", "value": "\n`substring(str, ~start, ~end)` returns characters `start` up to but not\nincluding end from `str`.\n- If `start` is less than zero, it is treated as zero.\n- If `end` is zero or negative, the empty string is returned.\n- If `start` is greater than `end`, the `start` and `end` points are swapped.\nSee [`String.substring`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring) on MDN.\n\n## Examples\n\n```rescript\nString.substring(\"playground\", ~start=3, ~end=6) == \"ygr\"\nString.substring(\"playground\", ~start=6, ~end=3) == \"ygr\"\nString.substring(\"playground\", ~start=4, ~end=12) == \"ground\"\n```\n"},
    "sortText": "substring",
    "insertText": "->String.substring",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }, {
    "label": "->String.search",
    "kind": 12,
    "tags": [],
    "detail": "(string, RegExp.t) => int",
    "documentation": {"kind": "markdown", "value": "\n`search(str, regexp)` returns the starting position of the first match of\n`regexp` in the given `str`, or -1 if there is no match.\nSee [`String.search`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search) on MDN.\n\n## Examples\n\n```rescript\nString.search(\"testing 1 2 3\", %re(\"/\\d+/\")) == 8\nString.search(\"no numbers\", %re(\"/\\d+/\")) == -1\n```\n"},
    "sortText": "search",
    "insertText": "->String.search",
    "additionalTextEdits": [{
      "range": {"start": {"line": 93, "character": 17}, "end": {"line": 93, "character": 18}},
      "newText": ""
      }]
  }]

