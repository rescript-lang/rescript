// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Mocha from "mocha";
import * as Test_utils from "./test_utils.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function testPrimitive() {
  console.log(42);
}

function testPrimitiveRef() {
  console.log(42);
}

function testNone() {
  
}

function testNoneRef() {
  
}

function testQualified() {
  console.log("hello");
}

function testQualifiedRef() {
  console.log("hello");
}

function testComplexExpr() {
  console.log("true");
}

function testComplexExprRef() {
  console.log("true");
}

function testNestedCalls() {
  let opt = [
    1,
    2,
    3
  ];
  opt.forEach(item => {
    console.log(item);
  });
}

function testNestedCallsRef() {
  let opt = [
    1,
    2,
    3
  ];
  opt.forEach(item => {
    console.log(item);
  });
}

function testNamedCallback() {
  console.log(42);
}

function testNamedCallbackRef() {
  console.log(42);
}

function testMultiple() {
  console.log("first");
  console.log("second");
}

function testMultipleRef() {
  console.log("first");
  console.log("second");
}

function testNonPrimitive() {
  console.log("hello");
}

function testNonPrimitiveRef() {
  console.log("hello");
}

let ForEach = {
  testPrimitive: testPrimitive,
  testPrimitiveRef: testPrimitiveRef,
  testNone: testNone,
  testNoneRef: testNoneRef,
  testQualified: testQualified,
  testQualifiedRef: testQualifiedRef,
  testComplexExpr: testComplexExpr,
  testComplexExprRef: testComplexExprRef,
  testNestedCalls: testNestedCalls,
  testNestedCallsRef: testNestedCallsRef,
  testNamedCallback: testNamedCallback,
  testNamedCallbackRef: testNamedCallbackRef,
  testMultiple: testMultiple,
  testMultipleRef: testMultipleRef,
  testNonPrimitive: testNonPrimitive,
  testNonPrimitiveRef: testNonPrimitiveRef
};

function testPrimitive$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitiveRef$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNone$1() {
  let result;
  console.log(result);
}

function testNoneRef$1() {
  let result;
  console.log(result);
}

function testQualified$1() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedRef$1() {
  let result = "hello" + " world";
  console.log(result);
}

function testComplex() {
  let result = "true";
  console.log(result);
}

function testComplexRef() {
  let result = "true";
  console.log(result);
}

function testNamedCallback$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackRef$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

let $$Map = {
  testPrimitive: testPrimitive$1,
  testPrimitiveRef: testPrimitiveRef$1,
  testNone: testNone$1,
  testNoneRef: testNoneRef$1,
  testQualified: testQualified$1,
  testQualifiedRef: testQualifiedRef$1,
  testComplex: testComplex,
  testComplexRef: testComplexRef,
  testNamedCallback: testNamedCallback$1,
  testNamedCallbackRef: testNamedCallbackRef$1
};

function testPrimitive$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitiveRef$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNone$2() {
  let result;
  console.log(result);
}

function testNoneRef$2() {
  let result;
  console.log(result);
}

function testQualified$2() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedRef$2() {
  let result = "hello" + " world";
  console.log(result);
}

function testComplex$1() {
  let result = "true";
  console.log(result);
}

function testComplexRef$1() {
  let result = "true";
  console.log(result);
}

function testNamedCallback$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackRef$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

let FlatMap = {
  testPrimitive: testPrimitive$2,
  testPrimitiveRef: testPrimitiveRef$2,
  testNone: testNone$2,
  testNoneRef: testNoneRef$2,
  testQualified: testQualified$2,
  testQualifiedRef: testQualifiedRef$2,
  testComplex: testComplex$1,
  testComplexRef: testComplexRef$1,
  testNamedCallback: testNamedCallback$2,
  testNamedCallbackRef: testNamedCallbackRef$2
};

Mocha.describe("Scope preservation in Option optimizations", () => {
  Mocha.test("Option.forEach evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return _value => {};
    };
    Stdlib_Option.forEach(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 337, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.forEach does not shadow surrounding bindings", () => {
    let result;
    result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 350, characters 7-14", result, 90);
  });
  Mocha.test("Option.map evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return value => value;
    };
    Stdlib_Option.map(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 362, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.map does not shadow surrounding bindings", () => {
    let result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 368, characters 7-14", result, 90);
  });
  Mocha.test("Option.flatMap evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return value => Primitive_option.some(value);
    };
    Stdlib_Option.flatMap(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 380, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.flatMap does not shadow surrounding bindings", () => {
    let result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 386, characters 7-14", result, 90);
  });
});

let globalValue = 89;

export {
  globalValue,
  ForEach,
  $$Map,
  FlatMap,
}
/*  Not a pure module */
