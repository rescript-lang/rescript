// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Mocha from "mocha";
import * as Test_utils from "./test_utils.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function getIncidentCategoryName(incidents, categories, incidentId) {
  let __res_option_opt = incidentId !== undefined ? Belt_MapString.get(incidents, incidentId) : undefined;
  let __res_option_opt$1 = __res_option_opt !== undefined ? __res_option_opt.categoryId : undefined;
  let __res_option_opt$2 = __res_option_opt$1 !== undefined ? Belt_MapString.get(categories, __res_option_opt$1) : undefined;
  if (__res_option_opt$2 !== undefined) {
    return __res_option_opt$2.name;
  }
}

let PipeChain = {
  getIncidentCategoryName: getIncidentCategoryName
};

function testPrimitive() {
  console.log(42);
}

function testPrimitivePipe() {
  console.log(42);
}

function testPrimitiveRef() {
  console.log(42);
}

function testNone() {
  
}

function testNonePipe() {
  
}

function testNoneRef() {
  
}

function testQualified() {
  console.log("hello");
}

function testQualifiedPipe() {
  console.log("hello");
}

function testQualifiedRef() {
  console.log("hello");
}

function testComplexExpr() {
  console.log("true");
}

function testComplexExprPipe() {
  console.log("true");
}

function testComplexExprRef() {
  console.log("true");
}

function testNestedCalls() {
  let opt = [
    1,
    2,
    3
  ];
  opt.forEach(item => {
    console.log(item);
  });
}

function testNestedCallsPipe() {
  let opt = [
    1,
    2,
    3
  ];
  opt.forEach(item => {
    console.log(item);
  });
}

function testNestedCallsRef() {
  let opt = [
    1,
    2,
    3
  ];
  opt.forEach(item => {
    console.log(item);
  });
}

function testNamedCallback() {
  console.log(42);
}

function testNamedCallbackPipe() {
  console.log(42);
}

function testNamedCallbackRef() {
  console.log(42);
}

function testMultiple() {
  console.log("first");
  console.log("second");
}

function testMultiplePipe() {
  console.log("first");
  console.log("second");
}

function testMultipleRef() {
  console.log("first");
  console.log("second");
}

function testNonPrimitive() {
  console.log("hello");
}

function testNonPrimitivePipe() {
  console.log("hello");
}

function testNonPrimitiveRef() {
  console.log("hello");
}

let ForEach = {
  testPrimitive: testPrimitive,
  testPrimitivePipe: testPrimitivePipe,
  testPrimitiveRef: testPrimitiveRef,
  testNone: testNone,
  testNonePipe: testNonePipe,
  testNoneRef: testNoneRef,
  testQualified: testQualified,
  testQualifiedPipe: testQualifiedPipe,
  testQualifiedRef: testQualifiedRef,
  testComplexExpr: testComplexExpr,
  testComplexExprPipe: testComplexExprPipe,
  testComplexExprRef: testComplexExprRef,
  testNestedCalls: testNestedCalls,
  testNestedCallsPipe: testNestedCallsPipe,
  testNestedCallsRef: testNestedCallsRef,
  testNamedCallback: testNamedCallback,
  testNamedCallbackPipe: testNamedCallbackPipe,
  testNamedCallbackRef: testNamedCallbackRef,
  testMultiple: testMultiple,
  testMultiplePipe: testMultiplePipe,
  testMultipleRef: testMultipleRef,
  testNonPrimitive: testNonPrimitive,
  testNonPrimitivePipe: testNonPrimitivePipe,
  testNonPrimitiveRef: testNonPrimitiveRef
};

function testPrimitive$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitivePipe$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitiveRef$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNone$1() {
  let result;
  console.log(result);
}

function testNonePipe$1() {
  let result;
  console.log(result);
}

function testNoneRef$1() {
  let result;
  console.log(result);
}

function testQualified$1() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedPipe$1() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedRef$1() {
  let result = "hello" + " world";
  console.log(result);
}

function testComplex() {
  let result = "true";
  console.log(result);
}

function testComplexPipe() {
  let result = "true";
  console.log(result);
}

function testComplexRef() {
  let result = "true";
  console.log(result);
}

function testNamedCallback$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackPipe$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackRef$1() {
  let result = 42 + 1 | 0;
  console.log(result);
}

let $$Map = {
  testPrimitive: testPrimitive$1,
  testPrimitivePipe: testPrimitivePipe$1,
  testPrimitiveRef: testPrimitiveRef$1,
  testNone: testNone$1,
  testNonePipe: testNonePipe$1,
  testNoneRef: testNoneRef$1,
  testQualified: testQualified$1,
  testQualifiedPipe: testQualifiedPipe$1,
  testQualifiedRef: testQualifiedRef$1,
  testComplex: testComplex,
  testComplexPipe: testComplexPipe,
  testComplexRef: testComplexRef,
  testNamedCallback: testNamedCallback$1,
  testNamedCallbackPipe: testNamedCallbackPipe$1,
  testNamedCallbackRef: testNamedCallbackRef$1
};

function testPrimitive$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitivePipe$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testPrimitiveRef$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNone$2() {
  let result;
  console.log(result);
}

function testNonePipe$2() {
  let result;
  console.log(result);
}

function testNoneRef$2() {
  let result;
  console.log(result);
}

function testQualified$2() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedPipe$2() {
  let result = "hello" + " world";
  console.log(result);
}

function testQualifiedRef$2() {
  let result = "hello" + " world";
  console.log(result);
}

function testComplex$1() {
  let result = "true";
  console.log(result);
}

function testComplexPipe$1() {
  let result = "true";
  console.log(result);
}

function testComplexRef$1() {
  let result = "true";
  console.log(result);
}

function testNamedCallback$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackPipe$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

function testNamedCallbackRef$2() {
  let result = 42 + 1 | 0;
  console.log(result);
}

let FlatMap = {
  testPrimitive: testPrimitive$2,
  testPrimitivePipe: testPrimitivePipe$2,
  testPrimitiveRef: testPrimitiveRef$2,
  testNone: testNone$2,
  testNonePipe: testNonePipe$2,
  testNoneRef: testNoneRef$2,
  testQualified: testQualified$2,
  testQualifiedPipe: testQualifiedPipe$2,
  testQualifiedRef: testQualifiedRef$2,
  testComplex: testComplex$1,
  testComplexPipe: testComplexPipe$1,
  testComplexRef: testComplexRef$1,
  testNamedCallback: testNamedCallback$2,
  testNamedCallbackPipe: testNamedCallbackPipe$2,
  testNamedCallbackRef: testNamedCallbackRef$2
};

Mocha.describe("Scope preservation in Option optimizations", () => {
  Mocha.test("Option.forEach evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return _value => {};
    };
    Stdlib_Option.forEach(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 481, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.forEach does not shadow surrounding bindings", () => {
    let result;
    result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 494, characters 7-14", result, 90);
  });
  Mocha.test("Option.map evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return value => value;
    };
    Stdlib_Option.map(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 506, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.map does not shadow surrounding bindings", () => {
    let result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 512, characters 7-14", result, 90);
  });
  Mocha.test("Option.flatMap evaluates callback argument even when option is None", () => {
    let invocations = {
      contents: 0
    };
    let makeCallback = () => {
      invocations.contents = invocations.contents + 1 | 0;
      return value => Primitive_option.some(value);
    };
    Stdlib_Option.flatMap(undefined, makeCallback());
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 524, characters 7-14", invocations.contents, 1);
  });
  Mocha.test("Option.flatMap does not shadow surrounding bindings", () => {
    let result = 89 + 1 | 0;
    Test_utils.eq("File \"option_stdlib_optimization_test.res\", line 530, characters 7-14", result, 90);
  });
});

let globalValue = 89;

export {
  globalValue,
  PipeChain,
  ForEach,
  $$Map,
  FlatMap,
}
/*  Not a pure module */
