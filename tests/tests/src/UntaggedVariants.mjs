// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Primitive_array from "rescript/lib/es6/Primitive_array.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function classify(x) {
  if (x === "A") {
    return "A";
  } else if (typeof x === "number") {
    return "An integer";
  } else {
    return "A string" + x;
  }
}

function classify2(x) {
  if (typeof x === "string") {
    return "A string" + x;
  } else {
    return "A float";
  }
}

function cls(x) {
  if (typeof x !== "object") {
    if (x === "One") {
      return "one";
    } else {
      return "two";
    }
  } else {
    return "object" + x.y;
  }
}

let ListWithTuples = {};

let ListWithObjects = {};

function tuplesToObjects(l) {
  if (l === undefined) {
    return null;
  } else {
    return {
      hd: l[0],
      tl: tuplesToObjects(l[1])
    };
  }
}

let l1 = [
  1,
  [
    2,
    [
      3,
      undefined
    ]
  ]
];

let l2 = tuplesToObjects(l1);

console.log("l1", l1);

console.log("l2", l2);

function isTrue(x) {
  if (x === true) {
    return true;
  } else {
    return x.flag;
  }
}

let Truthy = {
  isTrue: isTrue
};

function classify$1(x) {
  if (x == null) {
    if (x === null) {
      return "null";
    } else {
      return "undefined";
    }
  } else {
    return "object" + x.name;
  }
}

let TwoObjects = {
  classify: classify$1
};

function classify$2(x) {
  if (x === "A" || x === "B") {
    if (x === "A") {
      return "a";
    } else {
      return "b";
    }
  }
  console.log(x);
  return "Unknown";
}

let Unknown = {
  classify: classify$2
};

function classify$3(x) {
  if (x === "A" || x === "D" || x === "B" || x === "C") {
    switch (x) {
      case "A" :
        return "a";
      case "B" :
        return "b";
      case "C" :
        return "c";
      case "D" :
        return "d";
    }
  } else {
    switch (typeof x) {
      case "string" :
        return "string";
      case "number" :
        return "int";
      case "object" :
        return "Object" + x.name;
    }
  }
}

let MultipleBlocks = {
  classify: classify$3
};

function classify$4(x) {
  switch (typeof x) {
    case "string" :
      return "string";
    case "number" :
      return "int";
    case "object" :
      return "Object" + x.name;
  }
}

let OnlyBlocks = {
  classify: classify$4
};

function classify$5(x) {
  if (Array.isArray(x)) {
    return "array";
  }
  switch (typeof x) {
    case "string" :
      return "string";
    case "number" :
      return "int";
    case "object" :
      return "Object" + x.name;
  }
}

let WithArray = {
  classify: classify$5
};

function classify$6(x) {
  if (x === false || x === null || x === true) {
    switch (x) {
      case false :
        return "JSONFalse";
      case true :
        return "JSONTrue";
      case null :
        return "JSONNull";
    }
  } else {
    if (Array.isArray(x)) {
      return {
        TAG: "JSONArray",
        _0: x
      };
    }
    switch (typeof x) {
      case "string" :
        return {
          TAG: "JSONString",
          _0: x
        };
      case "number" :
        return {
          TAG: "JSONNumber",
          _0: x
        };
      case "object" :
        return {
          TAG: "JSONObject",
          _0: x
        };
    }
  }
}

let Json = {
  classify: classify$6
};

function check(s, y) {
  if (s === "B") {
    return 42;
  }
  let x = s[0];
  if (x === "B") {
    return 42;
  }
  let tmp = s[1];
  if (tmp === "B" && x !== y) {
    return 41;
  } else {
    return 42;
  }
}

let TrickyNested = {
  check: check
};

function checkEnum(e) {
  if (e !== "One" && e !== "Three" && e !== "Two") {
    return "Something else..." + e;
  }
  switch (e) {
    case "One" :
      return "One!";
    case "Two" :
      return "Two";
    case "Three" :
      return "Threeeee";
  }
}

let OverlapString = {
  checkEnum: checkEnum
};

function checkEnum$1(e) {
  if (e !== 1.0 && e !== "Three" && e !== "Two") {
    return "Something else...";
  }
  switch (e) {
    case 1.0 :
      return "One!";
    case "Two" :
      return "Two";
    case "Three" :
      return "Threeeee";
  }
}

let OverlapNumber = {
  checkEnum: checkEnum$1
};

function checkEnum$2(e) {
  if (e !== null && typeof e === "object") {
    return "Object...";
  }
  switch (e) {
    case null :
      return "One!";
    case "Two" :
      return "Two";
    case "Three" :
      return "Threeeee";
  }
}

let OverlapObject = {
  checkEnum: checkEnum$2
};

function classify$7(v) {
  if (Array.isArray(v)) {
    return Primitive_array.get(v, 0);
  } else {
    return v.x;
  }
}

let RecordIsObject = {
  classify: classify$7
};

function classify$8(v) {
  if (typeof v === "object" && !Array.isArray(v)) {
    return v.x;
  } else {
    return Primitive_array.get(v, 0);
  }
}

let ArrayAndObject = {
  classify: classify$8
};

function testHasNull(x) {
  return x;
}

function testHasUndefined(x) {
  return Primitive_option.some(x);
}

function untaggedWithOptionPayload(x) {
  return Primitive_option.some(x);
}

function untaggedWithIntPayload(x) {
  return x;
}

function untaggedInlineNoOptions(x) {
  return x;
}

function untaggedInlineUnaryWihtExplicitOption(x) {
  return Primitive_option.some(x);
}

function untaggedInlineUnaryWihtImplicitOption(x) {
  return Primitive_option.some(x);
}

function untaggedInlineMultinaryOption(x) {
  return x;
}

let OptionUnboxingHeuristic = {
  testHasNull: testHasNull,
  testHasUndefined: testHasUndefined,
  untaggedWithOptionPayload: untaggedWithOptionPayload,
  untaggedWithIntPayload: untaggedWithIntPayload,
  untaggedInlineNoOptions: untaggedInlineNoOptions,
  untaggedInlineUnaryWihtExplicitOption: untaggedInlineUnaryWihtExplicitOption,
  untaggedInlineUnaryWihtImplicitOption: untaggedInlineUnaryWihtImplicitOption,
  untaggedInlineMultinaryOption: untaggedInlineMultinaryOption
};

function classify$9(v) {
  if (Array.isArray(v)) {
    return Primitive_array.get(v, 0);
  }
  switch (typeof v) {
    case "object" :
      return v.x;
    case "function" :
      return v(3);
  }
}

let ff = x => x + 1 | 0;

let TestFunctionCase = {
  classify: classify$9,
  ff: ff
};

let someJson = '[{"name": "Haan"}, {"name": "Mr"}, false]';

function check$1(s) {
  if (Array.isArray(s)) {
    if (s.length !== 3) {
      console.log("Nope...");
      return;
    }
    let match = s[0];
    if (match === true) {
      let match$1 = s[1];
      if (match$1 === undefined || match$1 === null || match$1 === false || match$1 === true) {
        if (match$1 === false) {
          let match$2 = s[2];
          if (Array.isArray(match$2)) {
            if (match$2.length !== 2) {
              console.log("Nope...");
              return;
            }
            let match$3 = match$2[0];
            if (typeof match$3 === "string") {
              if (match$3 === "My name is") {
                let match$4 = match$2[1];
                if (typeof match$4 === "number") {
                  if (match$4 !== 10) {
                    console.log("Nope...");
                  } else {
                    console.log("yup");
                  }
                  return;
                }
                console.log("Nope...");
                return;
              }
              console.log("Nope...");
              return;
            }
            console.log("Nope...");
            return;
          }
          console.log("Nope...");
          return;
        }
        console.log("Nope...");
        return;
      } else {
        console.log("Nope...");
        return;
      }
    } else {
      console.log("Nope...");
      return;
    }
  } else {
    console.log("Nope...");
    return;
  }
}

let ComplexPattern = {
  someJson: someJson,
  check: check$1
};

async function getUserName(u) {
  if (u instanceof Promise) {
    return (await u).name;
  }
  switch (typeof u) {
    case "object" :
      return u.name;
    case "string" :
      return u;
  }
}

async function awaitUser(u) {
  if (u instanceof Promise) {
    return (await u).name;
  }
  switch (typeof u) {
    case "object" :
    case "string" :
      return "dummy";
  }
}

let PromiseSync = {
  getUserName: getUserName,
  awaitUser: awaitUser
};

async function classify$10(a) {
  if (a === "test" || a === 12) {
    if (a === "test") {
      console.log("testing");
      return;
    }
    console.log(12);
    return;
  } else {
    if (Array.isArray(a)) {
      console.log(Belt_Array.joinWith(a, "-", x => x));
      return;
    }
    if (a instanceof Promise) {
      console.log(await a);
      return;
    }
    switch (typeof a) {
      case "string" :
        console.log(a);
        return;
      case "object" :
        console.log(a.userName);
        return;
    }
  }
}

let Arr = {
  classify: classify$10
};

async function classifyAll(t) {
  if (Array.isArray(t)) {
    console.log(Belt_Array.joinWith(t, "-", x => x));
    return;
  }
  if (t instanceof Promise) {
    console.log(await t);
    return;
  }
  if (t instanceof Date) {
    console.log(t.toString());
    return;
  }
  if (t instanceof RegExp) {
    console.log(t.test("test"));
    return;
  }
  if (t instanceof File) {
    console.log(t.name);
    return;
  }
  if (t instanceof Blob) {
    console.log(t.size);
    return;
  }
  switch (typeof t) {
    case "string" :
      console.log(t);
      return;
    case "object" :
      console.log(t.userName);
      return;
  }
}

let AllInstanceofTypes = {
  classifyAll: classifyAll
};

function test(t) {
  switch (typeof t) {
    case "object" :
      return Js_dict.get(t, "Hello");
    case "string" :
      return t;
    case "function" :
      return t();
  }
}

let Aliased = {
  test: test
};

let OnlyOne = {
  onlyOne: "OnlyOne"
};

function should_not_merge(x) {
  if (Array.isArray(x)) {
    return "do not merge";
  }
  if (x instanceof Date) {
    return "do not merge";
  }
  switch (typeof x) {
    case "boolean" :
      return "boolean";
    case "object" :
      return "do not merge";
  }
}

function can_merge(x) {
  if (Array.isArray(x)) {
    return "do not merge";
  }
  if (x instanceof Date) {
    return "do not merge";
  }
  switch (typeof x) {
    case "boolean" :
    case "object" :
      return "merge";
  }
}

let MergeCases = {
  should_not_merge: should_not_merge,
  can_merge: can_merge
};

let $$Array;

let i = 42;

let i2 = 42.5;

let s = "abc";

let s2 = "abc";

let w = {
  x: 10,
  y: ""
};

export {
  $$Array,
  i,
  i2,
  s,
  s2,
  classify,
  classify2,
  w,
  cls,
  ListWithTuples,
  ListWithObjects,
  tuplesToObjects,
  l1,
  l2,
  Truthy,
  TwoObjects,
  Unknown,
  MultipleBlocks,
  OnlyBlocks,
  WithArray,
  Json,
  TrickyNested,
  OverlapString,
  OverlapNumber,
  OverlapObject,
  RecordIsObject,
  ArrayAndObject,
  OptionUnboxingHeuristic,
  TestFunctionCase,
  ComplexPattern,
  PromiseSync,
  Arr,
  AllInstanceofTypes,
  Aliased,
  OnlyOne,
  MergeCases,
}
/* l2 Not a pure module */
