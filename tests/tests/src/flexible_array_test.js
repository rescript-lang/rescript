// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Belt_Array = require("rescript/lib/js/belt_Array.js");
let Pervasives = require("rescript/lib/js/pervasives.js");
let Primitive_array = require("rescript/lib/js/primitive_array.js");
let Primitive_object = require("rescript/lib/js/primitive_object.js");

function sub(_tr, _k) {
  while (true) {
    let k = _k;
    let tr = _tr;
    if (typeof tr !== "object") {
      throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
    }
    if (k === 1) {
      return tr._0;
    }
    if (k % 2 === 0) {
      _k = k / 2 | 0;
      _tr = tr._1;
      continue;
    }
    _k = k / 2 | 0;
    _tr = tr._2;
    continue;
  };
}

function update(tr, k, w) {
  if (typeof tr !== "object") {
    if (k === 1) {
      return {
        TAG: "Br",
        _0: w,
        _1: "Lf",
        _2: "Lf"
      };
    }
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  }
  let r = tr._2;
  let l = tr._1;
  if (k === 1) {
    return {
      TAG: "Br",
      _0: w,
      _1: l,
      _2: r
    };
  }
  let v = tr._0;
  if (k % 2 === 0) {
    return {
      TAG: "Br",
      _0: v,
      _1: update(l, k / 2 | 0, w),
      _2: r
    };
  } else {
    return {
      TAG: "Br",
      _0: v,
      _1: l,
      _2: update(r, k / 2 | 0, w)
    };
  }
}

function $$delete(tr, n) {
  if (typeof tr !== "object") {
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  }
  if (n === 1) {
    return "Lf";
  }
  let r = tr._2;
  let l = tr._1;
  let v = tr._0;
  if (n % 2 === 0) {
    return {
      TAG: "Br",
      _0: v,
      _1: $$delete(l, n / 2 | 0),
      _2: r
    };
  } else {
    return {
      TAG: "Br",
      _0: v,
      _1: l,
      _2: $$delete(r, n / 2 | 0)
    };
  }
}

function loext(tr, w) {
  if (typeof tr !== "object") {
    return {
      TAG: "Br",
      _0: w,
      _1: "Lf",
      _2: "Lf"
    };
  } else {
    return {
      TAG: "Br",
      _0: w,
      _1: loext(tr._2, tr._0),
      _2: tr._1
    };
  }
}

function lorem(tr) {
  if (typeof tr !== "object") {
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  }
  let l = tr._1;
  if (typeof l === "object") {
    return {
      TAG: "Br",
      _0: l._0,
      _1: tr._2,
      _2: lorem(l)
    };
  }
  let tmp = tr._2;
  if (typeof tmp !== "object") {
    return "Lf";
  }
  throw {
    RE_EXN_ID: "Assert_failure",
    _1: [
      "flexible_array_test.res",
      80,
      9
    ],
    Error: new Error()
  };
}

let empty = [
  "Lf",
  0
];

function length(param) {
  return param[1];
}

function get(param, i) {
  if (i >= 0 && i < param[1]) {
    return sub(param[0], i + 1 | 0);
  } else {
    return Pervasives.invalid_arg("Array.get");
  }
}

function set(param, i, v) {
  let k = param[1];
  if (i >= 0 && i < k) {
    return [
      update(param[0], i + 1 | 0, v),
      k
    ];
  } else {
    return Pervasives.invalid_arg("Array.set");
  }
}

function push_front(param, v) {
  return [
    loext(param[0], v),
    param[1] + 1 | 0
  ];
}

function pop_front(param) {
  let k = param[1];
  if (k > 0) {
    return [
      lorem(param[0]),
      k - 1 | 0
    ];
  } else {
    return Pervasives.invalid_arg("Array.pop_front");
  }
}

function push_back(param, v) {
  let k = param[1];
  return [
    update(param[0], k + 1 | 0, v),
    k + 1 | 0
  ];
}

function pop_back(param) {
  let k = param[1];
  if (k > 0) {
    return [
      $$delete(param[0], k),
      k - 1 | 0
    ];
  } else {
    return Pervasives.invalid_arg("Array.pop_back");
  }
}

function filter_from(i, p, s) {
  let u = empty;
  for (let i$1 = i, i_finish = length(s); i$1 < i_finish; ++i$1) {
    let ele = get(s, i$1);
    if (p(ele)) {
      u = push_back(u, ele);
    }
    
  }
  return u;
}

function append(a, b) {
  let empty$1 = empty;
  for (let i = 0, i_finish = length(a); i < i_finish; ++i) {
    empty$1 = push_back(empty$1, get(a, i));
  }
  for (let i$1 = 0, i_finish$1 = length(b); i$1 < i_finish$1; ++i$1) {
    empty$1 = push_back(empty$1, get(b, i$1));
  }
  return empty$1;
}

function sort(s) {
  let size = length(s);
  if (size <= 1) {
    return s;
  }
  let head = get(s, 0);
  let larger = sort(filter_from(1, x => Primitive_object.greaterthan(x, head), s));
  let smaller = sort(filter_from(1, x => Primitive_object.lessequal(x, head), s));
  return append(smaller, push_front(larger, head));
}

function of_array(arr) {
  let v = empty;
  for (let i = 0, i_finish = arr.length; i < i_finish; ++i) {
    v = push_back(v, Primitive_array.get(arr, i));
  }
  return v;
}

let equal = Primitive_object.equal;

let Int_array = {
  empty: empty,
  get: get,
  set: set,
  push_front: push_front,
  pop_front: pop_front,
  push_back: push_back,
  pop_back: pop_back,
  append: append,
  sort: sort,
  of_array: of_array,
  equal: equal
};

function $eq$tilde(x, y) {
  return Primitive_object.equal(x, of_array(y));
}

let u = of_array([
  1,
  2,
  2,
  5,
  3,
  6
]);

if (!$eq$tilde(sort(u), [
    1,
    2,
    2,
    3,
    5,
    6
  ])) {
  throw {
    RE_EXN_ID: "Assert_failure",
    _1: [
      "flexible_array_test.res",
      184,
      2
    ],
    Error: new Error()
  };
}

let v = Belt_Array.init(500, i => 500 - i | 0);

$eq$tilde(sort(of_array(v)), Belt_Array.init(500, i => i + 1 | 0));

exports.sub = sub;
exports.update = update;
exports.$$delete = $$delete;
exports.loext = loext;
exports.lorem = lorem;
exports.Int_array = Int_array;
exports.$eq$tilde = $eq$tilde;
/* u Not a pure module */
