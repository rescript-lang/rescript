// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";

function fromArray(a) {
  return a.slice(0);
}

function toArray(a) {
  return a.slice(0);
}

function length(a) {
  return a.length;
}

function size(a) {
  return a.length;
}

let get = Belt_Array.get;

let getExn = Belt_Array.getExn;

function getUnsafe(a, x) {
  return a[x];
}

function getUndefined(a, x) {
  return a[x];
}

let shuffle = Belt_Array.shuffle;

let reverse = Belt_Array.reverse;

function makeUninitialized(x) {
  return new Array(x);
}

function makeUninitializedUnsafe(x) {
  return new Array(x);
}

let make = Belt_Array.make;

let range = Belt_Array.range;

let rangeBy = Belt_Array.rangeBy;

function makeBy(c, f) {
  return Belt_Array.makeBy(c, x => f(x));
}

function makeByAndShuffle(c, f) {
  return Belt_Array.makeByAndShuffle(c, x => f(x));
}

let zip = Belt_Array.zip;

function zipBy(a1, a2, f) {
  return Belt_Array.zipBy(a1, a2, (x, y) => f(x, y));
}

let unzip = Belt_Array.unzip;

let concat = Belt_Array.concat;

let concatMany = Belt_Array.concatMany;

let slice = Belt_Array.slice;

let sliceToEnd = Belt_Array.sliceToEnd;

function copy(a) {
  return a.slice(0);
}

function forEach(a, f) {
  Belt_Array.forEach(a, x => f(x));
}

function map(a, f) {
  return Belt_Array.map(a, x => f(x));
}

function keepWithIndex(a, f) {
  return Belt_Array.keepWithIndex(a, (x, y) => f(x, y));
}

function keepMap(a, f) {
  return Belt_Array.keepMap(a, x => f(x));
}

function forEachWithIndex(a, f) {
  Belt_Array.forEachWithIndex(a, (x, y) => f(x, y));
}

function mapWithIndex(a, f) {
  return Belt_Array.mapWithIndex(a, (x, y) => f(x, y));
}

function partition(a, f) {
  return Belt_Array.partition(a, x => f(x));
}

function reduce(a, b, f) {
  return Belt_Array.reduce(a, b, (x, y) => f(x, y));
}

function reduceReverse(a, b, f) {
  return Belt_Array.reduceReverse(a, b, (x, y) => f(x, y));
}

function reduceReverse2(a1, a2, c, f) {
  return Belt_Array.reduceReverse2(a1, a2, c, (x, y, z) => f(x, y, z));
}

function some(a, f) {
  return Belt_Array.some(a, x => f(x));
}

function every(a, f) {
  return Belt_Array.every(a, x => f(x));
}

function every2(a1, a2, f) {
  return Belt_Array.every2(a1, a2, (x, y) => f(x, y));
}

function some2(a1, a2, f) {
  return Belt_Array.some2(a1, a2, (x, y) => f(x, y));
}

function cmp(a1, a2, f) {
  return Belt_Array.cmp(a1, a2, (x, y) => f(x, y));
}

function eq(a1, a2, f) {
  return Belt_Array.eq(a1, a2, (x, y) => f(x, y));
}

let $$Array$1 = {
  get: get
};

export {
  $$Array$1 as $$Array,
  fromArray,
  toArray,
  length,
  size,
  get,
  getExn,
  getUnsafe,
  getUndefined,
  shuffle,
  reverse,
  makeUninitialized,
  makeUninitializedUnsafe,
  make,
  range,
  rangeBy,
  makeBy,
  makeByAndShuffle,
  zip,
  zipBy,
  unzip,
  concat,
  concatMany,
  slice,
  sliceToEnd,
  copy,
  forEach,
  map,
  keepWithIndex,
  keepMap,
  forEachWithIndex,
  mapWithIndex,
  partition,
  reduce,
  reduceReverse,
  reduceReverse2,
  some,
  every,
  every2,
  some2,
  cmp,
  eq,
}
/* No side effect */
