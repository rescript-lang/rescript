let x = __x => f(a, __x, c)

let x = __x => f(a, (__x => g(x, __x, z)), __x)

let x = __x => f(__x, x, c)

let x = __x => f(__x, __x, __x)

let x = f((__x => g(__x)))

let x = __x => f(~a=1, ~b=__x, ~c=2)

let x = __x => f(~a=__x, ~b=__x, ~c=__x)

let x = __x => f(~a=__x, ~b=__x, ~c=(__x => g(~x=2, ~y=__x, ~z=__x)))

let nested = (x, __x) => List.length(__x)

let nested2 = (x, y, z, __x) => List.length(__x)

let l = ([1, 2, 3] -> (__x => List.map((i => i + 1), __x))) -> (__x => List.filter((i => i > 0), __x))

let l = (i => i + 1) -> (__x => List.map(__x, [1, 2, 3]))

let x = __x => List.length(__x)

let incr = (~v) => v + 1

let l1 = ([1, 2, 3] -> List.map((__x => incr(~v=__x)))) -> List.length

let l2 = ([1, 2, 3] -> List.map((__x => incr(~v=__x)))) -> List.length

let optParam = (~v=?, ()) => (v == None) ? 0 : 1

let l1 = ([Some(1), None, Some(2)] -> List.map((__x => optParam(~v=?__x, ())))) -> List.length

let l2 = ([Some(1), None, Some(2)] -> List.map((__x => optParam(~v=?__x, ())))) -> List.length

// callback in last position
f(a, b, ((a, b, __x) => List.length(__x)))

// callback in first position
f(((a, b, __x) => List.length(__x)), a, b)

(__x => f(a, b, __x))(x, y)

-(__x => f(a, b, __x))

(__x => f(a, b, __x)) + (__x => g(x, __x, z))

((__x => f(a, b, __x)) + (__x => g(x, __x, z))) + (__x => h(alpha, beta, __x))

assert (__x => f(a, b, __x))

(__x => getDirector(a, b, __x)).name

(__x => f(a, b, __x)) ? (__x => g(x, y, __x)) : (__x => h(alpha, beta, __x))

<div onClick={__x => f(a, b, __x)} />

<div>{__x => f(a, b, __x)}</div>

@res.array.access (__x => f(a, b, __x))[ix]

@res.array.set (__x => f(a, b, __x))[ix] = 2

(__x => getDirector(a, b, __x)).name = "Steve"

filterNone -> (__x => Array.get(__x, 0))

filterNone -> (__x => Array.get(__x, 0))

__x => Array.get(__x, 0)

1 + (__x => Array.get(__x, 0))

(__x => Array.get(__x, 1)) + (__x => Array.get(__x, 0))

let f = __x => Array.get(__x, 0)

let photo = (pricedRoom["room"]["photos"] -> filterNone) -> (__x => Array.get(__x, 0))

__x => underscoreWithComments(
// Comment 1
(x => 
// Comment 2
something(())), __x)

let status = (json -> (__x => optional((__x => field("status", string, __x)), __x))) -> Option.mapOr(Status.Active, Status.fromString)

a -> (__x => map2(__x, fn))

a -> map2(fn)

a -> (__x => f(__x, __x, b))
