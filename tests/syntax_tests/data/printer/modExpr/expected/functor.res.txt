module F = (A: X) => (B: Y) => A

module F = (A: X) => (B: Y) => A

include (X: Map) => (Y: Set) => Z

module F = (A: X) => (B: Y) => A

include (X: Map) => (Y: Set) => Z

include (X: Map) => (Y: Set) => (Z: SuperLongModuleTypeName) => (Foo: Baaaaaaaaar) => Z

include (X: Map) => (Y: Set) => Z

include (X: Map) => (Y: Set) => Zzzzzzzzzzzzzzzzzzz

module Make = (A: X) => (B: Y) => {
  let a = A.a + B.b
}

// constraint on return type
module Make = (A: X) => (B: Y) => ({
  let a = A.a + B.b
}: Set)

include (X: Map) => (Y: Set) => (Z: SuperLongModuleTypeName) => (Foo: Baaaaaaaaar) => ({
  let a = A.a + B.b
}: Set)

// with attributes
module Make = (A: X) => (B: Y) => ({
  let a = A.a + B.b
}: Set)

module Make = (A: X) => (B: Y) => ({
  let a = A.a + B.b
}: Set)

module F = (*) => Map

module F = (*) => Map

include (*) => Map

include (*) => Map

module Make = (Cmp: {
  type t
  let eq: t => t => bool
}) => ({
  open Cmp
  type key = t
  type coll = list<key>
  let empty = list{}
  let add = (y: coll, e: key) => if List.exists((x => eq(x, e)), y) {
    y
  } else {
    list{e, ...y}
  }
}: {
  type key = Cmp.t
  type coll
  let empty: coll
  let add: coll => key => coll
})

module Make = (A: X) => (B: Y) => ({
  let a = A.a + B.b
}: (_: Set) => (_: Set) => Set)

module Make = (SuperLongNaaaaaaaame: X) => (SuperLongNaaaaaaaame: Y) => (SuperLongNaaaaaaaame: Z) => ({
  let a = A.a + B.b
}: (_: Seeeeeeeeeeeeeeeeeeeeeeeeeeeeet) => (_: Seeeeeeeeeeeeeeeeeeeeeeeeeeeeet) => (_: Seeeeeeeeeeeeeeeeeeeeeeeeeeeeet) => Set)

module Make = (H: Hashtbl.HashedType) => ({
  type weak_t<'a> = t<'a>
  let weak_create = create
  let emptybucket = weak_create(0)
  type data = H.t
}: S with type data = H.t)

module Gen1 = (P: Primitive) => (*) => {
  type t = P.t
  type internal = P.t
  let inject = t => t
}

module DistinctString = (*) => ({
  type t = string
  let inject = t => t
}: StringBased)
