// Pmod_ident
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */ /* c4 */  = Y

// Pmod_structure
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */  = {
  let /* inside1 */ a /* inside2 */ /* trailing */  = 2
} // trailing


// Pmod_extension
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */ /* c4 */ /*c5*/ /* c6 */  = %ext("test")

// Pmod_unpack
/* c0 */
module /* c1 */ New_three /* c2 */ /* c3 */  = unpack((
/* c4 */
three /* c5 */ /* c6 */ /* c7 */ /* c8 */ : module(X_int)))

// Pmod_constraint
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */ /* c4 */ /* c5 */ /* c6 */  = (X: Int)

/* c0 */
module /* c1 */ X /* c2 */ /* c4 */ /* c5 */ /* c6 */ /* c7 */  = (X: Int)

// Pmod_apply
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */ /* c4 */  = F(Arg1)(Arg2)(Arg3)

/* c4 */
/* c5 */ 
/* c6 */
/* c7 */ 
/* c8 */
/* c9 */ /* c10 */ 
/* c0 */
module /* c1 */ X /* c2 */ /* c3 */  = F((A: SetLike))((B: TreeLike))

/* c4 */
/* c5 */ /* c6 */ /* c7 */ 
/* c7 */
/* c8 */ /* c9 */ /* c10 */ /* c11 */ 
/* c0 */
module /* c1 */ S0 /* c2 */ /* c3 */ /* c4 */ /* lbrace */  = Make({
  type t /* c5 */  = int
  let eq /* c6 */  = (x, y) => x == y
})

/* rbrace */ // trailing
// Pmod_functor
/* c0 */
module /* c1 */ F /* c2 */ /* before parameters */  = (A: X) => (B: Y) => (C: Z) => ReturnMod

/* c3 */
/* c4 */ /* c5 */ /* c6 */ 
/* c7 */
/* c8 */ /* c9 */ /* c 10 */ 
/* c7 */
/* c8 */ /* c9 */ /* c 10 */ /* c11 */ /* c12 */ module Make /* before parameters */  = (A: X) => (B: Y) => ({
  
  /* before A */
  /* after A */ /* before X */ /* after X */ 
  /* before B */
  /* after B */ /* before Y */ /* after Y */ /* c1 */ /* c2 */ let a /* inside */  = A.a + B.b
}: Set)

module Make /* before parameters */  = (A: X) => (B: Y) => ({
  
  /* before A */
  /* after A */ /* before X */ /* after X */ 
  /* before B */
  /* after B */ /* before Y */ /* after Y */ let a /* inside */ /* c1 */ /* c2 */  = A.a + B.b
}: Set)
