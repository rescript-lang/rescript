type nonrec t = string
type nonrec t = Parser.t
type nonrec t = Lang.Parser.t
type nonrec t = string option
type nonrec t = string option
type nonrec t = string Option.t
type nonrec t = string Option.t
type nonrec t = (a, b, c) Mod.Sub.t
type nonrec t = (a, b, c) Mod.Sub.t
type nonrec t = list
type nonrec t = string list
type nonrec t = <age: int> list
type nonrec t = (<age: int>, <name: string>) list
type nonrec t = <; ..>
type nonrec t = <; ..> list
type nonrec t = <age: int; ..>
type nonrec t = <age: int; ..> list
type nonrec t = <age: int; ..>
type nonrec t = <age: int; ..> list
type nonrec t = <age: int; name: string; ..>
type nonrec t = <age: int; name: string; ..> list
type nonrec t = <age: int; ..>
type nonrec t = <age: int; ..> list
type nonrec t = <age: int; name: string; ..>
type nonrec t = <age: int; name: string; ..> list
let (t : string) = x
let (t : Parser.t) = x
let (t : Lang.Parser.t) = x
let (t : string option) = x
let (t : string option) = x
let (t : string Option.t) = x
let (t : string Option.t) = x
let (t : (a, b, c) Mod.Sub.t) = x
let (t : (a, b, c) Mod.Sub.t) = x
let (t : list) = x
let (t : string list) = x
let (t : <age: int> list) = x
let (t : <age: int> list) = x
let (t : <age: int> list) = x
let (t : <age: int> list) = x
let (t : <age: int; name: string> list) = x
let (t : (<age: int>, <name: string>) list) = x
let (t : (<age: int>, <name: string>) list) = x
let (t : (<age: int; name: string>, <name: string; age: int>) list) = x
let (t : <; ..> list) = x
let (t : <> list) = x
let (t : <age: int; ..> list) = x
let (t : <age: int> list) = x
let (t : <age: int; ..> list) = x
let (t : <age: int; ..> list) = x
let (t : <age: int> list) = x
let (t : <age: int; ..> list) = x
let (t : <age: int; name: string; ..> list) = x
let (t : <age: int; name: string; ..> list) = x
let (t : string list) = x
type nonrec ('T, 'E) id_6 = Ok of 'T | Err of {payload: 'E}
let foo = (fun (x : (int as 'X)) -> x)
module type A = Foo with type t = 'X
;;(= X int)