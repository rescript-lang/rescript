let a = 1
let a = 1
let a = 1 and b = 2
let (f : 't . 't foo) = (fun (type t) -> ((fun sideEffect -> (let module M = struct exception E of t end in ((sideEffect ()); (fun x -> M.E x)))) : t foo))
let (f : 't 'x 'u . ('t * 'x * y) list) = (fun (type t) -> (fun (type x) -> (fun (type u) -> ((fun l -> (f l)) : (t * x * y) list))))