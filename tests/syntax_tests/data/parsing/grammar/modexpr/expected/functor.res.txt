module F = functor (A : X) -> functor (B : Y) -> A
module F = functor (A : X) -> functor (B : Y) -> A
module F = functor (A : X) -> functor (B : Y) -> A
include functor (X : Map) -> functor (Y : Set) -> Z
include functor (X : Map) -> functor (Y : Set) -> Z
module F = functor (A : X) -> functor (B : Y) -> A
include functor (X : Map) -> functor (Y : Set) -> Z
include functor (X : Map) -> functor (Y : Set) -> Z
module Make = functor (A : X) -> functor (B : Y) -> (struct let a = (+ A.a B.b) end : Set)
module Make = functor (A : X) -> functor (B : Y) -> (struct let a = (+ A.a B.b) end : Set)
module F = functor (*) -> Map
module F = functor (*) -> Map
include functor (*) -> Map
include functor (*) -> Map
module Make = functor (Cmp : sig type nonrec t val eq : t -> t -> bool (a:1) (a:1) end) -> (struct open Cmp type nonrec key = t type nonrec coll = key list let empty = [] let add = (fun (y : coll) -> (fun (e : key) -> (if (List.exists (fun x -> (eq x e)) y) then y else :: (e, y)))) end : sig type nonrec key = Cmp.t type nonrec coll val empty : coll val add : coll -> key -> coll (a:1) (a:1) end)
module Gen1 = functor (P : Primitive) -> functor (*) -> struct type nonrec t = P.t type nonrec internal = P.t let inject = (fun t -> t) end
module DistinctString = functor (*) -> (struct type nonrec t = string let inject = (fun t -> t) end : StringBased)
module DistinctString = functor (*) -> (struct type nonrec t = string let inject = (fun t -> t) end : StringBased)