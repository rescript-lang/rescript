
  Syntax error!
  syntax_tests/data/parsing/infiniteLoops/nonRecTypes.res:4:29-36

  2 ┆ include (
  3 ┆           {
  4 ┆             type t('value) = {
  5 ┆               mutable size: int,
  6 ┆               mutable root: option(node('value)),

  Type parameters require angle brackets:
  t<'value>


  Syntax error!
  syntax_tests/data/parsing/infiniteLoops/nonRecTypes.res:6:45

  4 ┆ type t('value) = {
  5 ┆   mutable size: int,
  6 ┆   mutable root: option(node('value)),
  7 ┆   compare:
  8 ┆     Js.Internal.fn([ | `Arity_2('value, 'value)], int),

  Did you forget a `}` here?

include struct include struct type nonrec 'value t = {
  mutable size: int ;
  mutable root: option } ;;(node [%%rescript.exprhole]) ;;value ;;compare ;;(Js.Internal.fn [|([%%rescript.exprhole] [|"Arity_2('value, 'value)], int),\n                      };\n                    }: {\n\n                    }\n                  );\n          type t('value);\n          external t:\n            (\n              ~size: int,\n              ~root: option(node('value)),\n              ~compare: Js.Internal.fn([ | "|] [||])|]) ;;Arity_2 [%%rescript.exprhole] ;;value ;;value ;;int ;;(t [%%rescript.exprhole]) ;;value ;;"" ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0#\\0\\0\\0\\r\\0\\0\\0&\\0\\0\\0#\\x91\\xa0\\xa0A\\xa0$size@\\xa0\\xa0A\\xa0$root@\\xa0\\xa0A\\xa0'compare@@" external sizeSet : t -> 'value (a:1) ;;int ;;(= unit "size") ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x15\\0\\0\\0\\t\\0\\0\\0\\x1a\\0\\0\\0\\x19\\xb0\\xa0\\xa0A\\x91@\\xa0\\xa0A\\x04\\x03@E\\x97\\xa0$size@" ;;[|"use sizeGet instead or use {abstract = light} explicitly"|] external size : t ;;[%%rescript.exprhole] ;;value ;;(= int "") ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x10\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0$size@" external sizeGet : t ;;[%%rescript.exprhole] ;;value ;;(= int "") ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x10\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0$size@" external rootSet : t -> 'value (a:1) ;;(option (node [%%rescript.exprhole])) ;;value ;;(= unit "root") ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x15\\0\\0\\0\\t\\0\\0\\0\\x1a\\0\\0\\0\\x19\\xb0\\xa0\\xa0A\\x91@\\xa0\\xa0A\\x04\\x03@E\\x97\\xa0$root@" ;;[|"use rootGet instead or use {abstract = light} explicitly"|] external root : t ;;[%%rescript.exprhole] ;;value ;;(option (node [%%rescript.exprhole])) ;;value ;;"" ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x10\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0$root@" external rootGet : t ;;[%%rescript.exprhole] ;;value ;;(option (node [%%rescript.exprhole])) ;;value ;;"" ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x10\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0$root@" ;;[|"use compareGet instead or use {abstract = light} explicitly"|] external compare : t ;;[%%rescript.exprhole] ;;value ;;(Js.Internal.fn [|([%%rescript.exprhole] [|"Arity_2('value, 'value)], int) =\n            \"\"\n            \"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x13\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0'compare@\";\n          external compareGet:\n            t('value) => Js.Internal.fn([ | "|] [||])|]) ;;Arity_2 [%%rescript.exprhole] ;;value ;;value ;;int ;;"" ;;"BS:6.0.1\\x84\\x95\\xa6\\xbe\\0\\0\\0\\x13\\0\\0\\0\\x07\\0\\0\\0\\x14\\0\\0\\0\\x13\\xb0\\xa0\\xa0A\\x91@@A\\x98\\xa0'compare@" end let has = (fun rbt -> (fun value -> (!== (_findNode rbt (rootGet rbt) value) None))) let rec minNode = (fun node -> [%%rescript.exprhole]) ;;(= findMin (fun rbt -> [%%rescript.exprhole])) ;;(= removeNode (fun rbt -> (fun node -> (let nodeToRemove = (match ((leftGet node), (rightGet node)) with | (Some _, Some _) -> (let successor = (castNotOption (minNode (rightGet node))) in ((valueSet node (valueGet successor)); ((heightSet node (heightGet successor)); successor))) | _ -> node) in (let successor = (match (leftGet nodeToRemove) with | None -> (rightGet nodeToRemove) | left -> left) in (let (successor, isLeaf) = (match successor with | None -> (let leaf = (createNode ~value:(Js.Internal.raw_expr "0") ~color:Black ~height:0.) in (let isLeaf = (Js.Internal.fn_mk1 (fun x -> (=== x leaf))) in (leaf, isLeaf))) | Some successor -> (successor, (Js.Internal.fn_mk1 (fun _ -> false)))) in (let nodeParent = (parentGet nodeToRemove) in ((parentSet successor nodeParent); ((match nodeParent with | None -> () | Some parent -> (leftOrRightSet parent ~node:nodeToRemove Some successor)); ((updateSumRecursive rbt successor); ((if (=== (colorGet nodeToRemove) Black) then (if (=== (colorGet successor) Red) then ((colorSet successor Black); (if (=== (parentGet successor) None) then (rootSet rbt Some successor))) else (let break = (ref false) in (let successorRef = (ref successor) in (while (not break.contents) do (let successor = successorRef.contents in (match (parentGet successor) with | None -> ((rootSet rbt Some successor); break.contents <- true) | Some successorParent -> (let sibling = (siblingOf successor) in ((if (&& (!== sibling None) (=== (colorGet (castNotOption sibling)) Red)) then ((colorSet successorParent Red); ((colorSet (castNotOption sibling) Black); (if (isLeft successor) then (rotateLeft rbt successorParent) else (rotateRight rbt successorParent))))); (let sibling = (siblingOf successor) in (let siblingNN = (castNotOption sibling) in (if (&& (=== (colorGet successorParent) Black) (|| (=== sibling None) (&& (&& (=== (colorGet siblingNN) Black) (|| (=== (leftGet siblingNN) None) (=== (colorGet (castNotOption (leftGet siblingNN))) Black))) (|| (=== (rightGet siblingNN) None) (=== (colorGet (castNotOption (rightGet siblingNN))) Black))))) then ((if (!== sibling None) then (colorSet siblingNN Red)); successorRef.contents <- successorParent) else (if (&& (=== (colorGet successorParent) Red) (|| (=== sibling None) (&& (&& (=== (colorGet siblingNN) Black) (|| (=== (leftGet siblingNN) None) (=== (colorGet (castNotOption (leftGet siblingNN))) Black))) (|| (=== (rightGet siblingNN) None) (=== (colorGet (castNotOption (rightGet siblingNN))) Black))))) then ((if (!== sibling None) then (colorSet siblingNN Red)); ((colorSet successorParent Black); break.contents <- true)) else (if (&& (!== sibling None) (=== (colorGet (castNotOption sibling)) Black)) then (let sibling = (castNotOption sibling) in ((if (&& (&& (&& (isLeft successor) (|| (=== (rightGet sibling) None) (=== (colorGet (castNotOption (rightGet sibling))) Black))) (!== (leftGet sibling) None)) (=== (colorGet (castNotOption (leftGet sibling))) Red)) then ((colorSet sibling Red); ((colorSet (castNotOption (leftGet sibling)) Black); (rotateRight rbt sibling))) else (if (&& (&& (&& (not (isLeft successor)) (|| (=== (leftGet sibling) None) (=== (colorGet (castNotOption (leftGet sibling))) Black))) (!== (rightGet sibling) None)) (=== (colorGet (castNotOption (rightGet sibling))) Red)) then ((colorSet sibling Red); ((colorSet (castNotOption (rightGet sibling)) Black); (rotateLeft rbt sibling))))); break.contents <- true)) else (let sibling = (siblingOf successor) in (let sibling = (castNotOption sibling) in ((colorSet sibling (colorGet successorParent)); (if (isLeft successor) then ((colorSet (castNotOption (rightGet sibling)) Black); (rotateRight rbt successorParent)) else ((colorSet (castNotOption (leftGet sibling)) Black); (rotateLeft rbt successorParent))))))))))))))) done))))); (if (Js.Internal.fn_run1 isLeaf successor) then ((if (=== (rootGet rbt) Some successor) then (rootSet rbt None)); (match (parentGet successor) with | None -> () | Some parent -> (leftOrRightSet parent ~node:successor None))))))))))))))) let remove = (fun rbt -> (fun value -> (match (_findNode rbt (rootGet rbt) value) with | Some node -> ((removeNode rbt node); ((sizeSet rbt (- (sizeGet rbt) 1)); Some (heightGet node))) | None -> None))) let findThroughCallback = (fun rbt -> (fun cb -> (let rec findThroughCallback = (fun rbt -> (fun node -> (fun cb -> (match node with | None -> None | Some node -> (let cmp = (Js.Internal.fn_run1 cb (valueGet node)) in (if (=== cmp 0) then Some node else (if (< cmp 0) then (findThroughCallback rbt (leftGet node) cb) else (findThroughCallback rbt (rightGet node) cb)))))))) in (match (findThroughCallback rbt (rootGet rbt) cb) with | None -> None | Some node -> Some (valueGet node))))) let make = (fun ~compare:compare -> (t ~size:0 ~root:None ~compare:compare)) let rec heightOfInterval = (fun rbt -> (fun node -> (fun lhs -> (fun rhs -> (match node with | None -> 0. | Some n -> (if (&& (=== lhs None) (=== rhs None)) then (sumGet n) else (if (&& (!== lhs None) (< (Js.Internal.fn_run2 (compareGet rbt) (valueGet n) (castNotOption lhs)) 0)) then (heightOfInterval rbt (rightGet n) lhs rhs) else (if (&& (!== rhs None) (> (Js.Internal.fn_run2 (compareGet rbt) (valueGet n) (castNotOption rhs)) 0)) then (heightOfInterval rbt (leftGet n) lhs rhs) else (+. (+. (heightGet n) (heightOfInterval rbt (leftGet n) lhs None)) (heightOfInterval rbt (rightGet n) None rhs)))))))))) let heightOfInterval = (fun rbt -> (fun lhs -> (fun rhs -> (heightOfInterval rbt (rootGet rbt) lhs rhs)))) let rec firstVisibleNode = (fun node -> (fun offset -> (match node with | None -> None | Some node -> (if (<= (sumGet node) offset) then None else (let nodeHeight = (heightGet node) in (let sumLeft = (match (leftGet node) with | None -> 0.0 | Some left -> (sumGet left)) in (if (> sumLeft offset) then (firstVisibleNode (leftGet node) offset) else (if (> (+. sumLeft nodeHeight) offset) then Some node else (firstVisibleNode (rightGet node) (-. offset (+. sumLeft nodeHeight))))))))))) let lastVisibleNode = (fun node -> (fun offset -> (match (firstVisibleNode node offset) with | None -> (maxNode node) | first -> first))) let firstVisible = (fun rbt -> (fun ~offset:offset -> (match (firstVisibleNode (rootGet rbt) offset) with | None -> None | Some node -> Some (valueGet node)))) let rec leftmost = (fun node -> (match (leftGet node) with | None -> node | Some node -> (leftmost node))) let rec firstRightParent = (fun node -> (match (parentGet node) with | None -> None | Some parent -> (if (isLeft node) then Some parent else (firstRightParent parent)))) let nextNode = (fun node -> (match (rightGet node) with | None -> (firstRightParent node) | Some right -> Some (leftmost right))) let rec sumLeftSpine = (fun node -> (fun ~fromRightChild:fromRightChild -> (let leftSpine = (match (leftGet node) with | None -> (heightGet node) | Some left -> (if fromRightChild then (+. (heightGet node) (sumGet left)) else 0.0)) in (match (parentGet node) with | None -> leftSpine | Some parent -> (+. leftSpine (sumLeftSpine parent ~fromRightChild:(=== (rightGet parent) Some node))))))) let getY = (fun node -> (-. (sumLeftSpine node ~fromRightChild:true) (heightGet node))) let linearSearch = (fun rbt -> (fun callback -> (let rec find = (fun node -> (fun callback -> (if (Js.Internal.fn_run1 callback (valueGet node)) then Some (valueGet node) else (match (nextNode node) with | None -> None | Some node -> (find node callback))))) in (match (minNode (rootGet rbt)) with | None -> None | Some node -> (find node callback))))) let rec iterate = (fun ~inclusive:inclusive -> (fun firstNode -> (fun lastNode -> (fun ~callback:callback -> (match firstNode with | None -> () | Some node -> ((if inclusive then (Js.Internal.fn_run1 callback node)); (if (!== firstNode lastNode) then ((if (not inclusive) then (Js.Internal.fn_run1 callback node)); (iterate ~inclusive:inclusive (nextNode node) lastNode ~callback:callback))))))))) let rec iterateWithY = (fun ?y:y -> (fun ~inclusive:inclusive -> (fun firstNode -> (fun lastNode -> (fun ~callback:callback -> (match firstNode with | None -> () | Some node -> (let y = (match y with | None -> (getY node) | Some y -> y) in ((if inclusive then (Js.Internal.fn_run2 callback node y)); (if (!== firstNode lastNode) then ((if (not inclusive) then (Js.Internal.fn_run2 callback node y)); (iterateWithY ~y:(+. y (heightGet node)) ~inclusive:inclusive (nextNode node) lastNode ~callback:callback))))))))))) let rec updateSum = (fun node -> (fun ~delta:delta -> (match node with | None -> () | Some node -> ((sumSet node (+. (sumGet node) delta)); (updateSum (parentGet node) ~delta:delta))))) let setHeight = (fun rbt -> (fun value -> (fun ~height:height -> (match (_findNode rbt (rootGet rbt) value) with | None -> () | Some node -> (let delta = (-. height (heightGet node)) in ((heightSet node height); (updateSum Some node ~delta:delta))))))) type nonrec nonrec ;;(oldNewVisibleNodes [%%rescript.exprhole]) ;;value ;;([%%rescript.exprhole]; (old; ([%%rescript.exprhole]; ((array [%%rescript.exprhole]); (value; ([%%rescript.exprhole]; ([%%rescript.exprhole]; ([%%rescript.exprhole]; (new_; ([%%rescript.exprhole]; ((array [%%rescript.exprhole]); (value; ([%%rescript.exprhole]; [%%rescript.exprhole]))))))))))))) end