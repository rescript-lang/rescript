// comment 1
let /* a */ x /* b */ /* c */ /* comment 2 */  = 1

// comment 3
// comment 4
let x /* 5 */  = 1

/* 6 */
let f = (
// 1
a //2
, 
// 3
b) => {
// 5
x // 6
: 1, 
// 7
y // 8
: 2}

/* **** comment */
/* ** comment */
/* comment */
/* ** comment */
/* *** comment */
/* **** comment */
/* ** */
/* *** */
/* ** */
/* (** comment *) */
/* (*** comment *) */
/* *(*** comment *) */
/* comment * */
/* comment ** */
/* comment *** */
/* comment **** */
let testingNotQuiteEndOfLineComments = list{"Item 1" /* Comment For First Item */ , "Item 2" /* Comment For Second Item */ , "Item 3" /* Comment For Third Item */ , "Item 4" /* Comment For Fourth Item - but no semi */ }

/* Comment after last item in list. */
/* Comment after list bracket */ let testingEndOfLineComments = list{"Item 1" /* Comment For First Item */ , "Item 2" /* Comment For Second Item */ , "Item 3" /* Comment For Third Item */ , "Item 4" /* Comment For Fourth Item - but before semi */ }

/* Comment after last item in list. */
/* Comment after list bracket */ 
/* This time no space between bracket and comment */
let testingEndOfLineComments /* Comment after list bracket */  = list{}

type t /* End of line on t */  = (int, int)

type t22 /* End of t22 line on type t22 = */  = (int, int)

type variant =
| 
/* Comment above X */
X /* End of line on X */ (int)
| 
/* Comment above Y */
Y /* End of line on Y */ (int)

/* Comment on entire type def for variant */
type rec x = {
  
/* not attached *above* x */
fieldOne: int
}
and /* Attached end of line after x */ y = {
  
/* not attached *above* y */
fieldTwo: int
} /* Attached end of line after y */ 

let result = switch X(3) {
  | X(x) => 
  /* Where does this comment go? */
  ({
    let tmp = x
    x + tmp
  })
  | Y(x) => 
  /* How about this one */
  ({
    let tmp = x
    x + tmp
  })
}

let result = switch None {
  | Some({fieldOne: 20}) => 
  /* Where does this comment go? */
  ({
    let tmp = 0
    2 + tmp
  })
  | Some({fieldOne: n}) => 
  /* How about this one */
  ({
    let tmp = n
    n + tmp
  })
  | None => 20
}

type pointWithManyKindsOfComments = {
  
/* Line before x */
x /* x field */ : string,
  
/* Line before y */
y /* y field */ : string
}

/* Final row of record */
type typeParamPointWithComments<'a> = {
  
/* Line before x */
x /* x field */ : 'a,
  
/* Line before y */
y /* y field */ : 'a
}

/* Final row of record */
let name_equal = (x, y) => x == y

let equal /* most unlikely first */  = (i1, i2) => (i1.contents === i2.contents) && true

let equal /* END OF LINE HERE */  = (i1, i2) => compare(compare(0, 0), compare(1, 1))

module Temp = {
  let v = true
  let logIt = (str, ()) => print_string(str)
}

let store_attributes = arg => {
  let attributes_file = "test"
  let proc_name = attributes_file ++ ".proc"
  let should_write = 
  /* only overwrite defined procedures */
  Temp.v || (!Temp.v)
  if should_write {
    Temp.logIt(proc_name, ())
  }
}

3 // -


3 //-


3 //-


3 /* - */ 

// **** comment
/* ** comment */
@ocaml.doc(" docstring ") @ocaml.doc(" docstring ") @ocaml.doc(" ") @ocaml.doc("") @ocaml.doc(" (** comment *) ") @ocaml.doc(" (*** comment *) ") @ocaml.doc("
 * Multiline
 ") @ocaml.doc(" Multiline
 *
 ") @ocaml.doc("
 **
 ") module // comment
/* ** comment */
/* *** comment */
/* **** comment */
/* ** */
/* *** */
/* ** */
// (** comment *)
// (*** comment *)
// *(*** comment *)
// comment *
// comment **
// comment ***
// comment ****
JustString = {
  include Map.Make(Int32) // Comment eol include
  
}

let testingEndOfLineComments = list{"Item 1" /* Comment For First Item */ , "Item 2" /* Comment For Second Item */ , "Item 3" /* Comment For Third Item */ , "Item 4" /* Comment For Fourth Item - but before trailing comma */ }

// Comment after last item in list.
/* Comment after rbracket */ 
// But if you place them after the comma at eol, they're preserved as such
let testingEndOfLineComments = list{"Item 1" // Comment For First Item
, "Item 2" // Comment For Second Item
, "Item 3" // Comment For Third Item
, "Item 4" /* Comment For Fourth Item - but before trailing comma */ }

// Comment after last item in list.
/* Comment after rbracket */ 
// The space between ; and comment shoudn't matter
let testPlacementOfTrailingComment = list{"Item 0"}

// Comment after last item in list.
// Comment after semi
// The space between ; and comment shoudn't matter
let testPlacementOfTrailingComment = list{"Item 0"}

// Comment after last item in list.
// Comment after semi
// Try again but without other things in the list
let testPlacementOfTrailingComment // Comment after semi
 = list{"Item 0"}

// The space between ; and comment shoudn't matter
let testPlacementOfTrailingComment = list{"Item 0"}

// Comment after last item in list.
// Comment after semi
let testingEndOfLineComments // Comment after entire let binding
 = list{}

// The following is not yet idempotent
// let myFunction
//     withFirstArg  // First arg
//     andSecondArg  => { // Second Arg
//   withFirstArg + andSecondArg /* before semi */ ;
// };
let myFunction // First arg
 = (withFirstArg, 
// Second Arg
andSecondArg) => withFirstArg // After Semi
 + andSecondArg

type point = {
  x // x field
: string,
  y // y field
: string
}

type pointWithManyKindsOfComments = {
  
// Line before x
x // x field
: string,
  
// Line before y
y // y field
: string
}

// Final row of record
type typeParamPointWithComments<'a> = {
  
// Line before x
x // x field
: 'a,
  
// Line before y
y // y field
: 'a
}

// Final row of record
// Now, interleaving comments in type params
// Type name
type typeParamPointWithComments2<'a, 
// The b type apram
'b> = {
  
// Line before x
x // x field
: 'a,
  
// Line before y
y // y field
: 'a
}

// Final row of record
/* The way the last row comment is formatted is suboptimal becuase
 * record type definitions do not include enough location information */
type anotherpoint = {
  x // x field
: string,
  y // y field
: string
}

// comment as last row of record
type t // End of line on t
 = (int, int)

type t2 // End of line on (int, int)
 = (int, int)

type t3 // End of line on (int, int)
 = (int, int)

type variant =
| X // End of line on X
(int, int)
| Y // End of line on Y
(int, int)

// Comment on entire type def for variant
// Before let
let res // Before switch
 = switch X((2, 3)) {
  | 
  // Above X line
  X // End of arrow and X line
  (_) => "result of X"
  | 
  // Above Y line
  Y // End of arrow and Y line
  (_) => "result of Y"
} // After final semi in switch


let res = switch X((2, 3)) {
  | X // After X arrow
  ((0, 0)) => "result of X" // End of X body line
  
  | X /* Before X's arrow */ // End of X body line
  ((1, 0)) => "result of X"
  | X // After X _ arrow
  (_) => "result of X" // End of X body line
  
  | 
  // Above Y line
  Y // Comment above Y body
  (_) => "result of Y"
}

type variant2 =
| 
// Comment above X
X // End of line on X
(int, int)
| 
// Comment above Y
Y(int, int)

type variant3 =
| 
// Comment above X
X // End of line on X
(int, int)
| 
// Comment above Y
Y // End of line on Y
(int, int)

type rec x = {
  
// not attached *above* x
fieldOne: int,
  fieldA: int
}
and // Attached end of line after x
y = {
  
// not attached *above* y
fieldTwo: int
} // Attached end of line after y


type rec x2 = {
  
// not attached *above* x2
fieldOne: int,
  fieldA: int
}
and // Attached end of line after x2
y2 = {
  
// not attached *above* y2
fieldTwo: int
}

let result = switch None {
  | Some({fieldOne: 20, fieldA: a}) => 
  // Where does this comment go?
  ({
    let tmp = 0
    2 + tmp
  })
  | Some({fieldOne: n, fieldA: a}) => 
  // How about this one
  ({
    let tmp = n
    n + tmp
  })
  | None => 20
}

let res // Before switch
 = switch X((2, 3)) {
  | 
  // Above X line
  X // End of arrow and X line
  (_) => "result of X"
  | 
  // Above Y line
  Y // End of arrow and Y line
  (_) => "result of Y"
}

/*
 * Now these end of line comments *should* be retained.
 */
let result = switch None {
  | Some({fieldOne: 20, fieldA: a}) => ({
    let tmp = 0
    2 + tmp
  })
  | Some({fieldOne: n, fieldA: a}) => ({
    let tmp = n
    n + tmp
  })
  | None => 20
}

/*
 * These end of line comments *should* be retained.
 * To get the simple expression eol comment to be retained, we just need to
 * implement label breaking eol behavior much like we did with sequences.
 * Otherwise, right now they are not idempotent.
 */
let res = switch X((2, 3)) {
  | 
  // Above X line
  X // retain this // retain this
  ((_, _)) => "result of X"
  | 
  // Above Y line
  Y // End of arrow and Y line
  (_) => "result of Y"
}

/* type optionalTuple = */
/* | OptTup( */
/* option( */
/* ( */
/* int, */
/* int */
/* ), */
/* ), */
/* ); */
type optionTuple // First int // Second int
 = option<(int, int)>

type intPair // First int // Second int
 = (int, int)

type intPair2 = (
// First int
int, 
// Second int
int)

let result = @ocaml.doc("") (2 + 3)

// This is not yet idempotent
// {
//   /**/
//   (+) 2 3
// };
let a = ()

for i in 0 to 10 {
  
  // bla
  a
}

if true {
  ()
}

type color =
| Red // After red end of line
(int)
| Black // After black end of line
(int)
| Green // After green end of line
(int)

// On next line after color type def
let blahCurriedX = (x, x) => switch x {
  | Red(10) | Black(20) | Green // After or pattern green
  (10) => 1
  | Red // After red
  (x) => 0
  | Black // After black
  (x) => 0
  | Green(x) => 0
} // After second green


// On next line after blahCurriedX def
let name_equal = (x, y) => x == y

let equal // most unlikely first
 = (i1, i2) => (i1.contents === i2.contents) && true

let equal // END OF LINE HERE
 = (i1, i2) => compare(compare(0, 0), compare(1, 1))

let tuple_equal = ((i1, i2)) => i1 == i2

let tuple_equal = ((csu, mgd)) => 
// Some really long comments, see https://github.com/facebook/reason/issues/811
tuple_equal((csu, mgd))

let trueThing = true

for i in 0 to 1 {
  
  // comment
  print_newline(())
}

while trueThing {
  
  // comment
  print_newline(())
}

if trueThing {
  
  // comment
  print_newline(())
}

// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
  
  // Comment before print
  print_newline(())
}

// Comment after final print
// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
}

// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
  
  // Comment before print
  print_newline(())
} else {
  
  // Comment after final print
  
  // Comment before print
  print_newline(())
  
  // Comment before print
  print_newline(())
}

// Comment after final print
// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
} else {
  
  // Comment before print
  print_newline(())
}

// Comment before while test
while trueThing {
  
  // Comment before print
  print_newline(())
  
  // Comment before print
  print_newline(())
}

// Comment after final print
// Comment before while test
while trueThing {
  
  // Comment before print
  print_newline(())
}

// Comment before for test
for i in 0 to 100 {
  
  // Comment before print
  print_newline(())
  
  // Comment before print
  print_newline(())
}

// Comment after final print
// Comment before for test
for i in 0 to 100 {
  
  // Comment before print
  print_newline(())
}

if trueThing {
  
  // Comment before print
  print_newline // eol print
  (())
  
  // Comment before print
  print_newline // eol print
  (())
}

// Comment after print
// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
}

// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline // eol print
  (())
  
  // Comment before print
  print_newline // eol print
  (())
} else {
  
  // Comment after print
  
  // Comment before print
  print_newline // eol print
  (())
  
  // Comment before print
  print_newline // eol print
  (())
}

// Comment after print
// Comment before if test
if trueThing {
  
  // Comment before print
  print_newline(())
} else {
  
  // Comment before print
  print_newline // eol print
  (())
  
  // Comment before print
  print_newline // eol print
  (())
}

// Comment after print
// Comment before while test
while trueThing {
  
  // Comment before print
  print_newline // eol
  (())
  
  // Comment before print
  print_newline // eol
  (())
}

// Comment after final print
// Comment before while test
while trueThing {
  
  // Comment before print
  print_newline(())
}

// Comment before for test
for i in 0 to 100 {
  
  // Comment before print
  print_newline // eol
  (())
  
  // Comment before print
  print_newline // eol
  (())
}

// Comment after final print
// Comment before for test
for i in 0 to 100 {
  
  // Comment before print
  print_newline(())
}

let f = (a, b, c, d) => ((a + b) + c) + d

while trueThing {
  f(
  // a
  1, 
  // b
  2, 
  // c
  3, 
  // d
  4)
}

// does work
while trueThing {
  f(
  // a
  1, 
  // b
  2, 
  // c
  3, 
  // d
  4 // does work
  )
}

ignore(((_really, _long, _printWidth, _exceeded, _here) => 
// First comment
{
  let x = 0
  x + x
}))

// Closing comment
ignore(((_xxx, _yyy) => 
// First comment
{
  let x = 0
  x + x
}))

// Closing comment
type tester<'a, 'b> =
| TwoArgsConstructor('a, 'b)
| OneTupleArgConstructor(('a, 'b))

let callFunctionTwoArgs = (a, b) => ()

let callFunctionOneTuple = tuple => ()

let y //eol1 // eol2
 = TwoArgsConstructor((1, 2))

let y //eol1 // eol2
 = callFunctionTwoArgs(1, 2)

let y //eol1 // eol2
 = OneTupleArgConstructor((1, 2))

let y //eol1 // eol2
 = callFunctionOneTuple((1, 2))

type polyRecord<'a, 'b> = {
  fieldOne: 'a,
  fieldTwo: 'b
}

let r = {fieldOne //eol1
: 1, fieldTwo // eol2
: 2}

let r = {fieldOne //eol1
: 1, fieldTwo // eol2 with trailing comma
: 2}

let y //eol1 // eol2
 = TwoArgsConstructor(("1", "2"))

let y //eol1 // eol2
 = callFunctionTwoArgs("1", "2")

let y //eol1 // eol2
 = OneTupleArgConstructor(("1", "2"))

let y //eol1 // eol2
 = callFunctionOneTuple(("1", "2"))

let r = {fieldOne //eol1
: "1", fieldTwo // eol2
: "2"}

let r = {fieldOne //eol1
: "1", fieldTwo // eol2 with trailing comma
: "2"}

let identifier = "hello"

let y //eol1 // eol2
 = TwoArgsConstructor((identifier, identifier))

let y //eol1 // eol2
 = callFunctionTwoArgs(identifier, identifier)

let y //eol1 // eol2
 = OneTupleArgConstructor((identifier, identifier))

let y //eol1 // eol2
 = callFunctionOneTuple((identifier, identifier))

let r = {fieldOne //eol1
: identifier, fieldTwo // eol2
: identifier}

let r = {fieldOne //eol1
: identifier, fieldTwo // eol2 with trailing comma
: identifier}

let y //eol1 // eol2
 = TwoArgsConstructor((((identifier: string)), ((identifier: string))))

let y //eol1 // eol2
 = callFunctionTwoArgs(((identifier: string)), ((identifier: string)))

let y //eol1 // eol2
 = OneTupleArgConstructor((((identifier: string)), ((identifier: string))))

let y //eol1 // eol2
 = callFunctionOneTuple((((identifier: string)), ((identifier: string))))

let r = {fieldOne //eol1
: ((identifier: string)), fieldTwo // eol2
: ((identifier: string))}

let r = {fieldOne //eol1
: ((identifier: string)), fieldTwo // eol2 with trailing comma
: ((identifier: string))}

// whitespace interleaving
// comment1
// comment2
// whitespace above & below
let r = {fieldOne //eol1
: ((identifier: string)), 
// c1
// c2
// c3
// c4
// c5
fieldTwo // eol2 with trailing comma
: ((identifier: string))}
// trailing
// trailing whitespace above
// attach
// last comment

