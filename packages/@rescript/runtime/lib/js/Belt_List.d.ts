// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";

export type t<A> = rescript.list<A>;

export function head<A>(x: rescript.list<A>): rescript.option<A>;

export function headOrThrow<A>(x: rescript.list<A>): A;

export function headExn<A>(arg0: rescript.list<A>): A;

export function tail<A>(x: rescript.list<A>): rescript.option<rescript.list<A>>;

export function tailOrThrow<A>(x: rescript.list<A>): rescript.list<A>;

export function tailExn<A>(arg0: rescript.list<A>): rescript.list<A>;

export function add<A>(xs: rescript.list<A>, x: A): rescript.list<A>;

export function nthAux<A>(x: rescript.list<A>, n: number): rescript.option<A>;

export function nthAuxAssert<A>(x: rescript.list<A>, n: number): A;

export function get_<A>(x: rescript.list<A>, n: number): rescript.option<A>;

export function getOrThrow<A>(x: rescript.list<A>, n: number): A;

export function getExn<A>(arg0: rescript.list<A>, arg1: number): A;

export function partitionAux<A>(
  p: (arg0: A) => boolean,
  cell: rescript.list<A>,
  precX: t<A>,
  precY: t<A>,
): void;

export function splitAux<A, B>(
  cell: rescript.list<[A, B]>,
  precX: t<A>,
  precY: t<B>,
): void;

export function copyAuxCont<A>(cellX: rescript.list<A>, prec: t<A>): t<A>;

export function copyAuxWitFilter<A>(
  f: (arg0: A) => boolean,
  cellX: rescript.list<A>,
  prec: t<A>,
): void;

export function copyAuxWithFilterIndex<A>(
  f: (arg0: A, arg1: number) => boolean,
  cellX: rescript.list<A>,
  prec: t<A>,
  i: number,
): void;

export function copyAuxWitFilterMap<A, B>(
  f: (arg0: A) => rescript.option<B>,
  cellX: rescript.list<A>,
  prec: t<B>,
): void;

export function removeAssocAuxWithMap<A, B, C>(
  cellX: rescript.list<[A, B]>,
  x: C,
  prec: t<[A, B]>,
  f: (arg0: A, arg1: C) => boolean,
): boolean;

export function setAssocAuxWithMap<A, B>(
  cellX: rescript.list<[A, B]>,
  x: A,
  k: B,
  prec: t<[A, B]>,
  eq: (arg0: A, arg1: A) => boolean,
): boolean;

export function copyAuxWithMap<A, B>(
  cellX: rescript.list<A>,
  prec: t<B>,
  f: (arg0: A) => B,
): void;

export function zipAux<A, B>(
  cellX: rescript.list<A>,
  cellY: rescript.list<B>,
  prec: t<[A, B]>,
): void;

export function copyAuxWithMap2<A, B, C>(
  f: (arg0: A, arg1: B) => C,
  cellX: rescript.list<A>,
  cellY: rescript.list<B>,
  prec: t<C>,
): void;

export function copyAuxWithMapI<A, B>(
  f: (arg0: number, arg1: A) => B,
  i: number,
  cellX: rescript.list<A>,
  prec: t<B>,
): void;

export function takeAux<A>(
  n: number,
  cell: rescript.list<A>,
  prec: t<A>,
): boolean;

export function splitAtAux<A>(
  n: number,
  cell: rescript.list<A>,
  prec: t<A>,
): rescript.option<rescript.list<A>>;

export function take<A>(lst: rescript.list<A>, n: number): rescript.option<t<A>>;

export function dropAux<A>(
  l: rescript.list<A>,
  n: number,
): rescript.option<rescript.list<A>>;

export function drop<A>(
  lst: rescript.list<A>,
  n: number,
): rescript.option<rescript.list<A>>;

export function splitAt<A>(
  lst: rescript.list<A>,
  n: number,
): rescript.option<[t<A>, rescript.list<A>]>;

export function concat<A>(xs: rescript.list<A>, ys: t<A>): t<A>;

export function map<A, B>(xs: rescript.list<A>, f: (arg0: A) => B): t<B>;

export function zipBy<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): t<C>;

export function mapWithIndex<A, B>(
  xs: rescript.list<A>,
  f: (arg0: number, arg1: A) => B,
): t<B>;

export function makeBy<A>(n: number, f: (arg0: number) => A): t<A>;

export function make<A>(n: number, v: A): rescript.list<A>;

export function lengthAux<A>(x: rescript.list<A>, acc: number): number;

export function length<A>(xs: rescript.list<A>): number;

export function size<A>(arg0: rescript.list<A>): number;

export function fillAux<A>(arr: A.t<A>, i: number, x: rescript.list<A>): void;

export function fromArrayAux<A>(
  a: A.t<A>,
  i: number,
  res: rescript.list<A>,
): rescript.list<A>;

export function fromArray<A>(a: A.t<A>): rescript.list<A>;

export function toArray<A>(x: t<A>): A.t<A>;

export function shuffle<A>(xs: t<A>): rescript.list<A>;

export function reverseConcat<A>(
  l1: rescript.list<A>,
  l2: rescript.list<A>,
): rescript.list<A>;

export function reverse<A>(l: rescript.list<A>): rescript.list<A>;

export function flattenAux<A>(prec: t<A>, xs: rescript.list<rescript.list<A>>): void;

export function flatten<A>(xs: rescript.list<rescript.list<A>>): t<A>;

export function concatMany<A>(xs: A.t<t<A>>): t<A>;

export function mapRevAux<A, B>(
  f: (arg0: A) => B,
  accu: rescript.list<B>,
  xs: rescript.list<A>,
): rescript.list<B>;

export function mapReverse<A, B>(
  l: rescript.list<A>,
  f: (arg0: A) => B,
): rescript.list<B>;

export function forEach<A, B>(xs: rescript.list<A>, f: (arg0: A) => B): void;

export function iteri<A, B>(
  xs: rescript.list<A>,
  i: number,
  f: (arg0: number, arg1: A) => B,
): void;

export function forEachWithIndex<A, B>(
  l: rescript.list<A>,
  f: (arg0: number, arg1: A) => B,
): void;

export function reduce<A, B>(
  l: rescript.list<A>,
  accu: B,
  f: (arg0: B, arg1: A) => B,
): B;

export function reduceReverseUnsafe<A, B>(
  l: rescript.list<A>,
  accu: B,
  f: (arg0: B, arg1: A) => B,
): B;

export function reduceReverse<A, B>(
  l: rescript.list<A>,
  acc: B,
  f: (arg0: B, arg1: A) => B,
): B;

export function reduceWithIndexAux<A, B>(
  l: rescript.list<A>,
  acc: B,
  f: (arg0: B, arg1: A, arg2: number) => B,
  i: number,
): B;

export function reduceWithIndex<A, B>(
  l: rescript.list<A>,
  acc: B,
  f: (arg0: B, arg1: A, arg2: number) => B,
): B;

export function mapRevAux2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  accu: rescript.list<C>,
  f: (arg0: A, arg1: B) => C,
): rescript.list<C>;

export function mapReverse2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): rescript.list<C>;

export function forEach2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): void;

export function reduce2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  accu: C,
  f: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function reduceReverse2Unsafe<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  accu: C,
  f: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function reduceReverse2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  acc: C,
  f: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function every<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): boolean;

export function some<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): boolean;

export function every2<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => boolean,
): boolean;

export function cmpByLength<A, B>(l1: rescript.list<A>, l2: rescript.list<B>): number;

export function cmp<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => number,
): number;

export function eq<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => boolean,
): boolean;

export function some2<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => boolean,
): boolean;

export function has<A, B>(
  xs: rescript.list<A>,
  x: B,
  eq: (arg0: A, arg1: B) => boolean,
): boolean;

export function getAssoc<A, B, C>(
  xs: rescript.list<[A, B]>,
  x: C,
  eq: (arg0: A, arg1: C) => boolean,
): rescript.option<B>;

export function hasAssoc<A, B, C>(
  xs: rescript.list<[A, B]>,
  x: C,
  eq: (arg0: A, arg1: C) => boolean,
): boolean;

export function removeAssoc<A, B, C>(
  xs: t<[A, B]>,
  x: C,
  eq: (arg0: A, arg1: C) => boolean,
): t<[A, B]>;

export function setAssoc<A, B>(
  xs: rescript.list<[A, B]>,
  x: A,
  k: B,
  eq: (arg0: A, arg1: A) => boolean,
): t<[A, B]>;

export function sort<A>(
  xs: t<A>,
  cmp: (arg0: A, arg1: A) => number,
): rescript.list<A>;

export function getBy<A>(
  xs: rescript.list<A>,
  p: (arg0: A) => boolean,
): rescript.option<A>;

export function keep<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): t<A>;

export function filter<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): t<A>;

export function keepWithIndex<A>(
  xs: rescript.list<A>,
  p: (arg0: A, arg1: number) => boolean,
): t<A>;

export function filterWithIndex<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A, arg1: number) => boolean,
): t<A>;

export function keepMap<A, B>(
  xs: rescript.list<A>,
  p: (arg0: A) => rescript.option<B>,
): t<B>;

export function partition<A>(
  l: rescript.list<A>,
  p: (arg0: A) => boolean,
): [t<A>, t<A>];

export function unzip<A, B>(xs: rescript.list<[A, B]>): [t<A>, t<B>];

export function zip<A, B>(l1: rescript.list<A>, l2: rescript.list<B>): t<[A, B]>;

export function cmpU<A, B>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => number,
): number;

export function eqU<A, B>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function every2U<A, B>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function everyU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): boolean;

export function forEach2U<A, B, C>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => C,
): void;

export function forEachU<A, B>(arg0: rescript.list<A>, arg1: (arg0: A) => B): void;

export function forEachWithIndexU<A, B>(
  arg0: rescript.list<A>,
  arg1: (arg0: number, arg1: A) => B,
): void;

export function getAssocU<A, B, C>(
  arg0: rescript.list<[A, B]>,
  arg1: C,
  arg2: (arg0: A, arg1: C) => boolean,
): rescript.option<B>;

export function getByU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): rescript.option<A>;

export function hasAssocU<A, B, C>(
  arg0: rescript.list<[A, B]>,
  arg1: C,
  arg2: (arg0: A, arg1: C) => boolean,
): boolean;

export function hasU<A, B>(
  arg0: rescript.list<A>,
  arg1: B,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function keepMapU<A, B>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => rescript.option<B>,
): t<B>;

export function keepU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): t<A>;

export function keepWithIndexU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A, arg1: number) => boolean,
): t<A>;

export function makeByU<A>(arg0: number, arg1: (arg0: number) => A): t<A>;

export function mapReverse2U<A, B, C>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => C,
): rescript.list<C>;

export function mapReverseU<A, B>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => B,
): rescript.list<B>;

export function mapU<A, B>(arg0: rescript.list<A>, arg1: (arg0: A) => B): t<B>;

export function mapWithIndexU<A, B>(
  arg0: rescript.list<A>,
  arg1: (arg0: number, arg1: A) => B,
): t<B>;

export function partitionU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): [t<A>, t<A>];

export function reduce2U<A, B, C>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: C,
  arg3: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function reduceReverse2U<A, B, C>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: C,
  arg3: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function reduceReverseU<A, B>(
  arg0: rescript.list<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function reduceU<A, B>(
  arg0: rescript.list<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function reduceWithIndexU<A, B>(
  arg0: rescript.list<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A, arg2: number) => B,
): B;

export function removeAssocU<A, B, C>(
  arg0: t<[A, B]>,
  arg1: C,
  arg2: (arg0: A, arg1: C) => boolean,
): t<[A, B]>;

export function setAssocU<A, B>(
  arg0: rescript.list<[A, B]>,
  arg1: A,
  arg2: B,
  arg3: (arg0: A, arg1: A) => boolean,
): t<[A, B]>;

export function some2U<A, B>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function someU<A>(
  arg0: rescript.list<A>,
  arg1: (arg0: A) => boolean,
): boolean;

export function sortU<A>(
  arg0: t<A>,
  arg1: (arg0: A, arg1: A) => number,
): rescript.list<A>;

export function zipByU<A, B, C>(
  arg0: rescript.list<A>,
  arg1: rescript.list<B>,
  arg2: (arg0: A, arg1: B) => C,
): t<C>;