// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as Stdlib_Ordering from "./Stdlib_Ordering.js";

export type t<A> = rescript.list<A>;

export function head<A>(x: rescript.list<A>): rescript.option<A>;

export function headOrThrow<A>(x: rescript.list<A>): A;

export function headExn<A>(arg0: rescript.list<A>): A;

export function tail<A>(x: rescript.list<A>): rescript.option<rescript.list<A>>;

export function tailOrThrow<A>(x: rescript.list<A>): rescript.list<A>;

export function tailExn<A>(arg0: rescript.list<A>): rescript.list<A>;

export function add<A>(xs: rescript.list<A>, x: A): rescript.list<A>;

export function get<A>(x: rescript.list<A>, n: number): rescript.option<A>;

export function getOrThrow<A>(x: rescript.list<A>, n: number): A;

export function getExn<A>(arg0: rescript.list<A>, arg1: number): A;

export function take<A>(lst: rescript.list<A>, n: number): rescript.option<rescript.list<A>>;

export function drop<A>(lst: rescript.list<A>, n: number): rescript.option<rescript.list<A>>;

export function splitAt<A>(
  lst: rescript.list<A>,
  n: number,
): rescript.option<[rescript.list<A>, rescript.list<A>]>;

export function concat<A>(xs: rescript.list<A>, ys: rescript.list<A>): rescript.list<A>;

export function map<A, B>(xs: rescript.list<A>, f: (arg0: A) => B): rescript.list<B>;

export function zipBy<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): rescript.list<C>;

export function mapWithIndex<A, B>(
  xs: rescript.list<A>,
  f: (arg0: A, arg1: number) => B,
): rescript.list<B>;

export function fromInitializer<A>(
  length: number,
  f: (arg0: number) => A,
): rescript.list<A>;

export function make<A>(length: number, v: A): rescript.list<A>;

export function length<A>(xs: rescript.list<A>): number;

export function size<A>(arg0: rescript.list<A>): number;

export function fromArray<A>(a: A[]): rescript.list<A>;

export function toArray<A>(x: rescript.list<A>): A[];

export function shuffle<A>(xs: rescript.list<A>): rescript.list<A>;

export function toShuffled<A>(arg0: rescript.list<A>): rescript.list<A>;

export function reverseConcat<A>(
  l1: rescript.list<A>,
  l2: rescript.list<A>,
): rescript.list<A>;

export function reverse<A>(l: rescript.list<A>): rescript.list<A>;

export function flat<A>(xs: rescript.list<rescript.list<A>>): rescript.list<A>;

export function concatMany<A>(xs: rescript.list<A>[]): rescript.list<A>;

export function mapReverse<A, B>(l: rescript.list<A>, f: (arg0: A) => B): rescript.list<B>;

export function forEach<A>(xs: rescript.list<A>, f: (arg0: A) => void): void;

export function forEachWithIndex<A>(
  l: rescript.list<A>,
  f: (arg0: A, arg1: number) => void,
): void;

export function reduce<A, B>(l: rescript.list<A>, accu: B, f: (arg0: B, arg1: A) => B): B;

export function reduceReverse<A, B>(
  l: rescript.list<A>,
  acc: B,
  f: (arg0: B, arg1: A) => B,
): B;

export function reduceWithIndex<A, B>(
  l: rescript.list<A>,
  acc: B,
  f: (arg0: B, arg1: A, arg2: number) => B,
): B;

export function mapReverse2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): rescript.list<C>;

export function forEach2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  f: (arg0: A, arg1: B) => C,
): void;

export function reduce2<B, C, A>(
  l1: rescript.list<B>,
  l2: rescript.list<C>,
  accu: A,
  f: (arg0: A, arg1: B, arg2: C) => A,
): A;

export function reduceReverse2<A, B, C>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  acc: C,
  f: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function every<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): boolean;

export function some<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): boolean;

export function every2<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => boolean,
): boolean;

export function compareLength<A>(
  l1: rescript.list<A>,
  l2: rescript.list<A>,
): Stdlib_Ordering.t;

export function compare<A>(
  l1: rescript.list<A>,
  l2: rescript.list<A>,
  p: (arg0: A, arg1: A) => Stdlib_Ordering.t,
): Stdlib_Ordering.t;

export function equal<A>(
  l1: rescript.list<A>,
  l2: rescript.list<A>,
  p: (arg0: A, arg1: A) => boolean,
): boolean;

export function some2<A, B>(
  l1: rescript.list<A>,
  l2: rescript.list<B>,
  p: (arg0: A, arg1: B) => boolean,
): boolean;

export function has<A, B>(
  xs: rescript.list<A>,
  x: B,
  eq: (arg0: A, arg1: B) => boolean,
): boolean;

export function getAssoc<A, C, B>(
  xs: rescript.list<[A, C]>,
  x: B,
  eq: (arg0: A, arg1: B) => boolean,
): rescript.option<C>;

export function hasAssoc<A, C, B>(
  xs: rescript.list<[A, C]>,
  x: B,
  eq: (arg0: A, arg1: B) => boolean,
): boolean;

export function removeAssoc<A, C, B>(
  xs: rescript.list<[A, C]>,
  x: B,
  eq: (arg0: A, arg1: B) => boolean,
): rescript.list<[A, C]>;

export function setAssoc<A, C>(
  xs: rescript.list<[A, C]>,
  x: A,
  k: C,
  eq: (arg0: A, arg1: A) => boolean,
): rescript.list<[A, C]>;

export function sort<A>(
  xs: rescript.list<A>,
  cmp: (arg0: A, arg1: A) => Stdlib_Ordering.t,
): rescript.list<A>;

export function find<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): rescript.option<A>;

export function filter<A>(xs: rescript.list<A>, p: (arg0: A) => boolean): rescript.list<A>;

export function filterWithIndex<A>(
  xs: rescript.list<A>,
  p: (arg0: A, arg1: number) => boolean,
): rescript.list<A>;

export function filterMap<A, B>(
  xs: rescript.list<A>,
  p: (arg0: A) => rescript.option<B>,
): rescript.list<B>;

export function partition<A>(
  l: rescript.list<A>,
  p: (arg0: A) => boolean,
): [rescript.list<A>, rescript.list<A>];

export function unzip<A, B>(xs: rescript.list<[A, B]>): [rescript.list<A>, rescript.list<B>];

export function zip<A, B>(l1: rescript.list<A>, l2: rescript.list<B>): rescript.list<[A, B]>;