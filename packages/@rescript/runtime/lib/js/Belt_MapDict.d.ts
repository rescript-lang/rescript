// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";
import type * as N from "./N.js";

export type t<Key, A, Id> = rescript.opaque<"Belt_MapDict.t", [Key, A, Id], N.t<Key, A>>;

export type cmp<Key, Id> = Belt_Id.cmp<Key, Id>;

export const empty: rescript.option<any>;

export function fromArray<A, B, C>(
  arg0: [A, B][],
  cmp: N.cmp<A, C>,
): N.t<A, B>;

export function isEmpty<A, B>(arg0: N.t<A, B>): boolean;

export function cmp<A, B, C, D>(
  arg0: N.t<A, B>,
  arg1: N.t<A, C>,
  kcmp: N.cmp<A, D>,
  vcmp: (arg0: B, arg1: C) => number,
): number;

export function eq<A, B, C, D>(
  arg0: N.t<A, B>,
  arg1: N.t<A, C>,
  kcmp: N.cmp<A, D>,
  veq: (arg0: B, arg1: C) => boolean,
): boolean;

export function has<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  cmp: N.cmp<A, C>,
): boolean;

export function findFirstBy<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): rescript.option<[A, B]>;

export function forEach<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => void,
): void;

export function reduce<A, B, C>(
  arg0: N.t<A, B>,
  arg1: C,
  arg2: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function every<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function some<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function size<A, B>(arg0: N.t<A, B>): number;

export function toList<A, B>(arg0: N.t<A, B>): rescript.list<[A, B]>;

export function toArray<A, B>(arg0: N.t<A, B>): [A, B][];

export function keysToArray<A, B>(arg0: N.t<A, B>): A[];

export function valuesToArray<A, B>(arg0: N.t<A, B>): B[];

export function minimum<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function maximum<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function minKey<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function maxKey<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function minKeyUndefined<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function maxKeyUndefined<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function minUndefined<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function maxUndefined<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function get_<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  cmp: N.cmp<A, C>,
): rescript.option<B>;

export function getUndefined<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  cmp: N.cmp<A, C>,
): rescript.option<B>;

export function getWithDefault<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  arg2: B,
  cmp: N.cmp<A, C>,
): B;

export function getOrThrow<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  cmp: N.cmp<A, C>,
): B;

export function getExn<A, B, C>(
  arg0: N.t<A, B>,
  arg1: A,
  cmp: N.cmp<A, C>,
): B;

export function mapWithKey<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => C,
): N.t<A, C>;

export function map<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: B) => C,
): N.t<A, C>;

export function keep<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): N.t<A, B>;

export function partition<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): [N.t<A, B>, N.t<A, B>];

export function checkInvariantInternal<A, B>(arg0: N.t<A, B>): void;

export function set_<A, B, C, D>(
  t: t<A, B, C>,
  newK: A,
  newD: B,
  cmp: Belt_Id.cmp<A, D>,
): N.t<A, B>;

export function update<A, B, C, D>(
  t: t<A, B, C>,
  newK: A,
  f: (arg0: rescript.option<B>) => rescript.option<B>,
  cmp: Belt_Id.cmp<A, D>,
): N.t<A, B>;

export function removeAux0<A, B, C>(
  n: N.node<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A, B>;

export function remove<A, B, C>(
  n: rescript.option<N.node<A, B>>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A, B>;

export function mergeMany<A, B, C, D>(
  h: t<A, B, C>,
  arr: A.t<[A, B]>,
  cmp: Belt_Id.cmp<A, D>,
): t<A, B, C>;

export function splitAuxPivot<A, B, C>(
  n: N.node<A, B>,
  x: A,
  pres: rescript.ref<rescript.option<B>>,
  cmp: Belt_Id.cmp<A, C>,
): [N.t<A, B>, N.t<A, B>];

export function split<A, B, C>(
  n: rescript.option<N.node<A, B>>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): [[N.t<A, B>, N.t<A, B>], rescript.option<B>];

export function merge<A, B, C, D, E>(
  s1: N.t<A, B>,
  s2: N.t<A, C>,
  f: (arg0: A, arg1: rescript.option<B>, arg2: rescript.option<C>) => rescript.option<D>,
  cmp: Belt_Id.cmp<A, E>,
): N.t<A, D>;

export function removeMany0<A, B, C>(
  t: N.node<A, B>,
  xs: A.t<A>,
  i: number,
  len: number,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A, B>;

export function removeMany<A, B, C>(
  t: rescript.option<N.node<A, B>>,
  keys: A.t<A>,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A, B>;

export function cmpU<A, B, C, D>(
  arg0: N.t<A, B>,
  arg1: N.t<A, C>,
  kcmp: N.cmp<A, D>,
  vcmp: (arg0: B, arg1: C) => number,
): number;

export function eqU<A, B, C, D>(
  arg0: N.t<A, B>,
  arg1: N.t<A, C>,
  kcmp: N.cmp<A, D>,
  veq: (arg0: B, arg1: C) => boolean,
): boolean;

export function everyU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function findFirstByU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): rescript.option<[A, B]>;

export function forEachU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => void,
): void;

export function keepU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): N.t<A, B>;

export function mapU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: B) => C,
): N.t<A, C>;

export function mapWithKeyU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => C,
): N.t<A, C>;

export function mergeU<A, B, C, D, E>(
  arg0: N.t<A, B>,
  arg1: N.t<A, C>,
  arg2: (arg0: A, arg1: rescript.option<B>, arg2: rescript.option<C>) => rescript.option<D>,
  cmp: Belt_Id.cmp<A, E>,
): N.t<A, D>;

export function partitionU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): [N.t<A, B>, N.t<A, B>];

export function reduceU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: C,
  arg2: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function someU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function updateU<A, B, C, D>(
  arg0: t<A, B, C>,
  arg1: A,
  arg2: (arg0: rescript.option<B>) => rescript.option<B>,
  cmp: Belt_Id.cmp<A, D>,
): N.t<A, B>;