// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";
import type * as N from "./N.js";

export type id<K, Id> = Belt_Id.comparable<K, Id>;

export type cmp<Key, Id> = Belt_Id.cmp<Key, Id>;

export interface t<Value, Id> {
  readonly cmp: cmp<Value, Id>;
  data: N.t<Value>;
}

export function remove0<A, B>(
  nt: N.node<A>,
  x: B,
  cmp: (arg0: B, arg1: A) => number,
): N.t<A>;

export function remove<A, B>(d: t<A, B>, v: A): void;

export function removeMany0<A, B>(
  t: N.node<A>,
  xs: A.t<B>,
  i: number,
  len: number,
  cmp: (arg0: B, arg1: A) => number,
): rescript.option<N.node<A>>;

export function removeMany<A, B>(d: t<A, B>, xs: A.t<A>): void;

export function removeCheck0<A, B>(
  nt: N.node<A>,
  x: A,
  removed: rescript.ref<boolean>,
  cmp: Belt_Id.cmp<A, B>,
): N.t<A>;

export function removeCheck<A, B>(d: t<A, B>, v: A): boolean;

export function addCheck0<A>(
  t: N.t<A>,
  x: A,
  added: rescript.ref<boolean>,
  cmp: (arg0: A, arg1: A) => number,
): N.t<A>;

export function addCheck<A, B>(m: t<A, B>, e: A): boolean;

export function add<A, B>(m: t<A, B>, e: A): void;

export function addArrayMutate<A, B>(
  t: N.t<A>,
  xs: A.t<A>,
  cmp: N.cmp<A, B>,
): N.t<A>;

export function mergeMany<A, B>(d: t<A, B>, xs: A.t<A>): void;

export function make<A, B>(id: id<A, B>): t<A, B>;

export function isEmpty<A, B>(d: t<A, B>): boolean;

export function minimum<A, B>(d: t<A, B>): rescript.option<A>;

export function minUndefined<A, B>(d: t<A, B>): rescript.option<A>;

export function maximum<A, B>(d: t<A, B>): rescript.option<A>;

export function maxUndefined<A, B>(d: t<A, B>): rescript.option<A>;

export function forEach<A, B>(d: t<A, B>, f: (arg0: A) => void): void;

export function reduce<A, B, C>(
  d: t<A, B>,
  acc: C,
  cb: (arg0: C, arg1: A) => C,
): C;

export function every<A, B>(d: t<A, B>, p: (arg0: A) => boolean): boolean;

export function some<A, B>(d: t<A, B>, p: (arg0: A) => boolean): boolean;

export function size<A, B>(d: t<A, B>): number;

export function toList<A, B>(d: t<A, B>): rescript.list<A>;

export function toArray<A, B>(d: t<A, B>): A[];

export function fromSortedArrayUnsafe<A, B>(
  xs: A[],
  id: id<A, B>,
): t<A, B>;

export function checkInvariantInternal<A, B>(d: t<A, B>): void;

export function fromArray<A, B>(data: A[], id: id<A, B>): t<A, B>;

export function cmp<A, B, C>(d0: t<A, B>, d1: t<A, C>): number;

export function eq<A, B, C>(d0: t<A, B>, d1: t<A, C>): boolean;

export function get_<A, B>(d: t<A, B>, x: A): rescript.option<A>;

export function getUndefined<A, B>(d: t<A, B>, x: A): rescript.option<A>;

export function getOrThrow<A, B>(d: t<A, B>, x: A): A;

export function getExn<A, B>(arg0: t<A, B>, arg1: A): A;

export function split<A, B>(
  d: t<A, B>,
  key: A,
): [[t<A, B>, t<A, B>], boolean];

export function keep<A, B>(d: t<A, B>, p: (arg0: A) => boolean): t<A, B>;

export function partition<A, B>(
  d: t<A, B>,
  p: (arg0: A) => boolean,
): [t<A, B>, t<A, B>];

export function subset<A, B, C>(a: t<A, B>, b: t<A, C>): boolean;

export function intersect<A, B, C>(a: t<A, B>, b: t<A, C>): t<A, B>;

export function diff<A, B, C>(a: t<A, B>, b: t<A, C>): t<A, B>;

export function union<A, B, C>(a: t<A, B>, b: t<A, C>): t<A, B>;

export function has<A, B>(d: t<A, B>, x: A): boolean;

export function copy<A, B>(d: t<A, B>): t<A, B>;

export function everyU<A, B>(arg0: t<A, B>, arg1: (arg0: A) => boolean): boolean;

export function forEachU<A, B>(arg0: t<A, B>, arg1: (arg0: A) => void): void;

export function keepU<A, B>(
  arg0: t<A, B>,
  arg1: (arg0: A) => boolean,
): t<A, B>;

export function partitionU<A, B>(
  arg0: t<A, B>,
  arg1: (arg0: A) => boolean,
): [t<A, B>, t<A, B>];

export function reduceU<A, B, C>(
  arg0: t<A, B>,
  arg1: C,
  arg2: (arg0: C, arg1: A) => C,
): C;

export function someU<A, B>(arg0: t<A, B>, arg1: (arg0: A) => boolean): boolean;