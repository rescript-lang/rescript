// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";

export type t<Res, Err> = rescript.result<Res, Err>;

export function getOrThrow<A, B>(x: t<A, B>, message?: string): A;

export function getExn<A, B>(arg0: t<A, B>, message?: string): A;

export function mapOr<A, B, C>(
  opt: t<A, B>,
  default_: C,
  f: (arg0: A) => C,
): C;

export function mapWithDefault<A, B, C>(
  arg0: t<A, B>,
  arg1: C,
  arg2: (arg0: A) => C,
): C;

export function map<A, B, C>(opt: t<A, B>, f: (arg0: A) => C): t<C, B>;

export function flatMap<A, B, C>(
  opt: t<A, B>,
  f: (arg0: A) => t<C, B>,
): t<C, B>;

export function getOr<A, B>(opt: t<A, B>, default_: A): A;

export function getWithDefault<A, B>(arg0: t<A, B>, arg1: A): A;

export function isOk<A, B>(x: t<A, B>): boolean;

export function isError<A, B>(x: t<A, B>): boolean;

export function equal<A, B, C, D>(
  a: t<A, B>,
  b: t<C, D>,
  eqOk: (arg0: A, arg1: C) => boolean,
  eqError: (arg0: B, arg1: D) => boolean,
): boolean;

export function compare<A, B, C, D>(
  a: t<A, B>,
  b: t<C, D>,
  cmpOk: (arg0: A, arg1: C) => number,
  cmpError: (arg0: B, arg1: D) => number,
): number;

export function forEach<A, B>(r: t<A, B>, f: (arg0: A) => void): void;

export function mapError<A, B, C>(r: t<A, B>, f: (arg0: B) => C): t<A, C>;

export function all<A, B>(results: t<A, B>[]): t<A[], B>;

export function all2<A, B, C>(
  param: [t<A, B>, t<C, B>],
): t<[A, C], B>;

export function all3<A, B, C, D>(
  param: [t<A, B>, t<C, B>, t<D, B>],
): t<[A, C, D], B>;

export function all4<A, B, C, D, E>(
  param: [t<A, B>, t<C, B>, t<D, B>, t<E, B>],
): t<[A, C, D, E], B>;

export function all5<A, B, C, D, E, F>(
  param: [t<A, B>, t<C, B>, t<D, B>, t<E, B>, t<F, B>],
): t<[A, C, D, E, F], B>;

export function all6<A, B, C, D, E, F, G>(
  param: [t<A, B>, t<C, B>, t<D, B>, t<E, B>, t<F, B>, t<G, B>],
): t<[A, C, D, E, F, G], B>;

export function mapOkAsync<A, B, C>(
  res: Promise<t<A, B>>,
  f: (arg0: A) => C,
): Promise<t<C, B>>;

export function mapErrorAsync<A, B, C>(
  res: Promise<t<A, B>>,
  f: (arg0: B) => C,
): Promise<t<A, C>>;

export function flatMapOkAsync<A, B, C>(
  res: Promise<t<A, B>>,
  f: (arg0: A) => Promise<t<C, B>>,
): Promise<t<C, B>>;

export function flatMapErrorAsync<A, B, C>(
  res: Promise<t<A, B>>,
  f: (arg0: B) => Promise<t<A, C>>,
): Promise<t<A, C>>;