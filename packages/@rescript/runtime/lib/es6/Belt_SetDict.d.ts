// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";
import type * as N from "./N.js";

export type t<K, Id> = rescript.opaque<"Belt_SetDict.t", [K, Id], N.t<K>>;

export type cmp<Key, Id> = Belt_Id.cmp<Key, Id>;

export function add<A, B, C>(
  t: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A>;

export function remove<A, B, C>(
  t: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): N.t<A>;

export function mergeMany<A, B, C>(
  h: t<A, B>,
  arr: A.t<A>,
  cmp: Belt_Id.cmp<A, C>,
): t<A, B>;

export function removeMany<A, B, C>(
  h: t<A, B>,
  arr: A.t<A>,
  cmp: Belt_Id.cmp<A, C>,
): t<A, B>;

export function splitAuxNoPivot<A, B>(
  cmp: Belt_Id.cmp<A, B>,
  n: N.node<A>,
  x: A,
): [N.t<A>, N.t<A>];

export function splitAuxPivot<A, B>(
  cmp: Belt_Id.cmp<A, B>,
  n: N.node<A>,
  x: A,
  pres: rescript.ref<boolean>,
): [N.t<A>, N.t<A>];

export function split<A, B, C>(
  t: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): [[N.t<A>, N.t<A>], boolean];

export function union<A, B, C, D>(
  s1: t<A, B>,
  s2: t<A, C>,
  cmp: Belt_Id.cmp<A, D>,
): N.t<A>;

export function intersect<A, B, C, D>(
  s1: t<A, B>,
  s2: t<A, C>,
  cmp: Belt_Id.cmp<A, D>,
): N.t<A>;

export function diff<A, B>(
  s1: N.t<A>,
  s2: N.t<A>,
  cmp: Belt_Id.cmp<A, B>,
): N.t<A>;

export const empty: rescript.option<any>;

export function fromArray<A, B>(arg0: A[], cmp: N.cmp<A, B>): N.t<A>;

export function isEmpty<A>(arg0: N.t<A>): boolean;

export function cmp<A, B>(
  arg0: N.t<A>,
  arg1: N.t<A>,
  cmp: N.cmp<A, B>,
): number;

export function eq<A, B>(
  arg0: N.t<A>,
  arg1: N.t<A>,
  cmp: N.cmp<A, B>,
): boolean;

export function has<A, B>(arg0: N.t<A>, arg1: A, cmp: N.cmp<A, B>): boolean;

export function forEachU<A>(arg0: N.t<A>, arg1: (arg0: A) => void): void;

export function forEach<A>(arg0: N.t<A>, arg1: (arg0: A) => void): void;

export function reduceU<A, B>(
  arg0: N.t<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function reduce<A, B>(
  arg0: N.t<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function everyU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function every<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function someU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function some<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function size<A>(arg0: N.t<A>): number;

export function toList<A>(arg0: N.t<A>): rescript.list<A>;

export function toArray<A>(arg0: N.t<A>): A[];

export function minimum<A>(arg0: N.t<A>): rescript.option<A>;

export function maximum<A>(arg0: N.t<A>): rescript.option<A>;

export function maxUndefined<A>(arg0: N.t<A>): rescript.option<A>;

export function minUndefined<A>(arg0: N.t<A>): rescript.option<A>;

export function get_<A, B>(
  arg0: N.t<A>,
  arg1: A,
  cmp: N.cmp<A, B>,
): rescript.option<A>;

export function getOrThrow<A, B>(
  arg0: N.t<A>,
  arg1: A,
  cmp: N.cmp<A, B>,
): A;

export function getExn<A, B>(arg0: N.t<A>, arg1: A, cmp: N.cmp<A, B>): A;

export function getUndefined<A, B>(
  arg0: N.t<A>,
  arg1: A,
  cmp: N.cmp<A, B>,
): rescript.option<A>;

export function fromSortedArrayUnsafe<A>(arg0: A[]): N.t<A>;

export function subset<A, B>(
  arg0: N.t<A>,
  arg1: N.t<A>,
  cmp: N.cmp<A, B>,
): boolean;

export function keep<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): N.t<A>;

export function keepU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): N.t<A>;

export function partitionU<A>(
  arg0: N.t<A>,
  arg1: (arg0: A) => boolean,
): [N.t<A>, N.t<A>];

export function partition<A>(
  arg0: N.t<A>,
  arg1: (arg0: A) => boolean,
): [N.t<A>, N.t<A>];

export function checkInvariantInternal<A>(arg0: N.t<A>): void;