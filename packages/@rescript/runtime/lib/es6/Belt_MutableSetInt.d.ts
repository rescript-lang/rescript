// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as I from "./I.js";
import type * as N from "./N.js";
import type * as S from "./S.js";

export type value = I.value;

export interface t {
  data: I.t;
}

export function remove0(nt: N.node<value>, x: value): N.t<value>;

export function remove(d: t, v: value): void;

export function removeMany0(
  t: N.node<value>,
  xs: A.t<value>,
  i: number,
  len: number,
): rescript.option<N.node<value>>;

export function removeMany(d: t, xs: A.t<value>): void;

export function removeCheck0(
  nt: N.node<value>,
  x: value,
  removed: rescript.ref<boolean>,
): N.t<value>;

export function removeCheck(d: t, v: value): boolean;

export function addCheck0(
  t: N.t<value>,
  x: value,
  added: rescript.ref<boolean>,
): N.t<value>;

export function addCheck(m: t, e: value): boolean;

export function add(d: t, k: I.value): void;

export function addArrayMutate(
  t: I.N.t<I.value>,
  xs: A.t<I.value>,
): I.N.t<I.value>;

export function mergeMany(d: t, arr: A.t<I.value>): void;

export function make(): t;

export function isEmpty(d: t): boolean;

export function minimum(d: t): rescript.option<I.value>;

export function minUndefined(d: t): rescript.option<I.value>;

export function maximum(d: t): rescript.option<I.value>;

export function maxUndefined(d: t): rescript.option<I.value>;

export function forEach(d: t, f: (arg0: I.value) => void): void;

export function reduce<A>(d: t, acc: A, cb: (arg0: A, arg1: I.value) => A): A;

export function every(d: t, p: (arg0: I.value) => boolean): boolean;

export function some(d: t, p: (arg0: I.value) => boolean): boolean;

export function size(d: t): number;

export function toList(d: t): rescript.list<I.value>;

export function toArray(d: t): I.value[];

export function fromSortedArrayUnsafe(xs: I.value[]): t;

export function checkInvariantInternal(d: t): void;

export function fromArray(xs: I.value[]): t;

export function cmp(d0: t, d1: t): number;

export function eq(d0: t, d1: t): boolean;

export function get_(d: t, x: I.value): rescript.option<I.value>;

export function getUndefined(d: t, x: I.value): rescript.option<I.value>;

export function getOrThrow(d: t, x: I.value): I.value;

export function getExn(arg0: t, arg1: I.value): I.value;

export function split(d: t, key: S.element): [[t, t], boolean];

export function keep(d: t, p: (arg0: I.value) => boolean): t;

export function partition(d: t, p: (arg0: I.value) => boolean): [t, t];

export function subset(a: t, b: t): boolean;

export function intersect(dataa: t, datab: t): t;

export function diff(dataa: t, datab: t): t;

export function union(dataa: t, datab: t): t;

export function has(d: t, x: I.value): boolean;

export function copy(d: t): t;

export function everyU(arg0: t, arg1: (arg0: I.value) => boolean): boolean;

export function forEachU(arg0: t, arg1: (arg0: I.value) => void): void;

export function keepU(arg0: t, arg1: (arg0: I.value) => boolean): t;

export function partitionU(arg0: t, arg1: (arg0: I.value) => boolean): [t, t];

export function reduceU<A>(
  arg0: t,
  arg1: A,
  arg2: (arg0: A, arg1: I.value) => A,
): A;

export function someU(arg0: t, arg1: (arg0: I.value) => boolean): boolean;