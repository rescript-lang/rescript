// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as I from "./I.js";
import type * as N from "./N.js";

export type key = string;

export interface t<A> {
  data: I.t<A>;
}

export function make<A>(): t<A>;

export function isEmpty<A>(m: t<A>): boolean;

export function clear<A>(m: t<A>): void;

export function minKeyUndefined<A>(m: t<A>): rescript.option<I.key>;

export function minKey<A>(m: t<A>): rescript.option<I.key>;

export function maxKeyUndefined<A>(m: t<A>): rescript.option<I.key>;

export function maxKey<A>(m: t<A>): rescript.option<I.key>;

export function minimum<A>(m: t<A>): rescript.option<[I.key, A]>;

export function minUndefined<A>(m: t<A>): rescript.option<[I.key, A]>;

export function maximum<A>(m: t<A>): rescript.option<[I.key, A]>;

export function maxUndefined<A>(m: t<A>): rescript.option<[I.key, A]>;

export function set_<A>(m: t<A>, k: I.key, v: A): void;

export function forEach<A>(d: t<A>, f: (arg0: I.key, arg1: A) => void): void;

export function map<A, B>(d: t<A>, f: (arg0: A) => B): t<B>;

export function mapWithKey<A, B>(d: t<A>, f: (arg0: I.key, arg1: A) => B): t<B>;

export function reduce<A, B>(
  d: t<A>,
  acc: B,
  f: (arg0: B, arg1: I.key, arg2: A) => B,
): B;

export function every<A>(d: t<A>, f: (arg0: I.key, arg1: A) => boolean): boolean;

export function some<A>(d: t<A>, f: (arg0: I.key, arg1: A) => boolean): boolean;

export function size<A>(d: t<A>): number;

export function toList<A>(d: t<A>): rescript.list<[I.key, A]>;

export function toArray<A>(d: t<A>): [I.key, A][];

export function keysToArray<A>(d: t<A>): I.key[];

export function valuesToArray<A>(d: t<A>): A[];

export function checkInvariantInternal<A>(d: t<A>): void;

export function has<A>(d: t<A>, v: I.key): boolean;

export function removeMutateAux<A>(nt: N.node<key, A>, x: key): N.t<key, A>;

export function remove<A>(d: t<A>, v: key): void;

export function updateDone<A>(
  t: N.t<key, A>,
  x: key,
  f: (arg0: rescript.option<A>) => rescript.option<A>,
): N.t<key, A>;

export function update<A>(
  t: t<A>,
  x: key,
  f: (arg0: rescript.option<A>) => rescript.option<A>,
): void;

export function removeArrayMutateAux<A>(
  t: N.node<key, A>,
  xs: A.t<key>,
  i: number,
  len: number,
): rescript.option<N.node<key, A>>;

export function removeMany<A>(d: t<A>, xs: A.t<key>): void;

export function fromArray<A>(xs: [I.key, A][]): t<A>;

export function cmp<A, B>(
  d0: t<A>,
  d1: t<B>,
  f: (arg0: A, arg1: B) => number,
): number;

export function eq<A, B>(
  d0: t<A>,
  d1: t<B>,
  f: (arg0: A, arg1: B) => boolean,
): boolean;

export function get_<A>(d: t<A>, x: I.key): rescript.option<A>;

export function getUndefined<A>(d: t<A>, x: I.key): rescript.option<A>;

export function getWithDefault<A>(d: t<A>, x: I.key, def: A): A;

export function getOrThrow<A>(d: t<A>, x: I.key): A;

export function getExn<A>(arg0: t<A>, arg1: I.key): A;

export function cmpU<A, B>(
  arg0: t<A>,
  arg1: t<B>,
  arg2: (arg0: A, arg1: B) => number,
): number;

export function eqU<A, B>(
  arg0: t<A>,
  arg1: t<B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function everyU<A>(
  arg0: t<A>,
  arg1: (arg0: I.key, arg1: A) => boolean,
): boolean;

export function forEachU<A>(arg0: t<A>, arg1: (arg0: I.key, arg1: A) => void): void;

export function mapU<A, B>(arg0: t<A>, arg1: (arg0: A) => B): t<B>;

export function mapWithKeyU<A, B>(
  arg0: t<A>,
  arg1: (arg0: I.key, arg1: A) => B,
): t<B>;

export function reduceU<A, B>(
  arg0: t<A>,
  arg1: B,
  arg2: (arg0: B, arg1: I.key, arg2: A) => B,
): B;

export function someU<A>(
  arg0: t<A>,
  arg1: (arg0: I.key, arg1: A) => boolean,
): boolean;

export function updateU<A>(
  arg0: t<A>,
  arg1: key,
  arg2: (arg0: rescript.option<A>) => rescript.option<A>,
): void;