// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";

export interface node<K, V> {
  k: K;
  v: V;
  h: number;
  l: t<K, V>;
  r: t<K, V>;
}

export type t<Key, A> = rescript.option<node<Key, A>>;

export type cmp<K, Id> = Belt_Id.cmp<K, Id>;

export function treeHeight<A, B>(n: t<A, B>): number;

export function copy<A, B>(n: t<A, B>): t<A, B>;

export function create<A, B>(
  l: t<A, B>,
  x: A,
  d: B,
  r: t<A, B>,
): rescript.option<node<A, B>>;

export function singleton<A, B>(x: A, d: B): rescript.option<node<A, B>>;

export function heightGe<A, B, C, D>(
  l: rescript.option<node<A, B>>,
  r: rescript.option<node<C, D>>,
): boolean;

export function updateValue<A, B>(n: node<A, B>, newValue: B): node<A, B>;

export function bal<A, B>(
  l: t<A, B>,
  x: A,
  d: B,
  r: t<A, B>,
): rescript.option<node<A, B>>;

export function minKey0Aux<A, B>(n: node<A, B>): A;

export function minKey<A, B>(n: rescript.option<node<A, B>>): rescript.option<A>;

export function minKeyUndefined<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<A>;

export function maxKey0Aux<A, B>(n: node<A, B>): A;

export function maxKey<A, B>(n: rescript.option<node<A, B>>): rescript.option<A>;

export function maxKeyUndefined<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<A>;

export function minKV0Aux<A, B>(n: node<A, B>): [A, B];

export function minimum<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<[A, B]>;

export function minUndefined<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<[A, B]>;

export function maxKV0Aux<A, B>(n: node<A, B>): [A, B];

export function maximum<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<[A, B]>;

export function maxUndefined<A, B>(
  n: rescript.option<node<A, B>>,
): rescript.option<[A, B]>;

export function removeMinAuxWithRef<A, B>(
  n: node<A, B>,
  kr: rescript.ref<A>,
  vr: rescript.ref<B>,
): t<A, B>;

export function isEmpty<A>(x: rescript.option<A>): boolean;

export function stackAllLeft<A, B>(
  v: t<A, B>,
  s: rescript.list<node<A, B>>,
): rescript.list<node<A, B>>;

export function findFirstBy<A, B>(
  n: t<A, B>,
  p: (arg0: A, arg1: B) => boolean,
): rescript.option<[A, B]>;

export function forEach<A, B>(n: t<A, B>, f: (arg0: A, arg1: B) => void): void;

export function map<A, B, C>(n: t<A, B>, f: (arg0: B) => C): t<A, C>;

export function mapWithKey<A, B, C>(
  n: t<A, B>,
  f: (arg0: A, arg1: B) => C,
): t<A, C>;

export function reduce<A, B, C>(
  m: t<A, B>,
  accu: C,
  f: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function every<A, B>(n: t<A, B>, p: (arg0: A, arg1: B) => boolean): boolean;

export function some<A, B>(n: t<A, B>, p: (arg0: A, arg1: B) => boolean): boolean;

export function addMinElement<A, B>(n: t<A, B>, k: A, v: B): t<A, B>;

export function addMaxElement<A, B>(n: t<A, B>, k: A, v: B): t<A, B>;

export function join<A, B>(
  ln: t<A, B>,
  v: A,
  d: B,
  rn: t<A, B>,
): t<A, B>;

export function concat<A, B>(t1: t<A, B>, t2: t<A, B>): t<A, B>;

export function concatOrJoin<A, B>(
  t1: t<A, B>,
  v: A,
  d: rescript.option<B>,
  t2: t<A, B>,
): t<A, B>;

export function keepShared<A, B>(
  n: t<A, B>,
  p: (arg0: A, arg1: B) => boolean,
): t<A, B>;

export function keepMap<A, B, C>(
  n: t<A, B>,
  p: (arg0: A, arg1: B) => rescript.option<C>,
): t<A, C>;

export function partitionShared<A, B>(
  n: t<A, B>,
  p: (arg0: A, arg1: B) => boolean,
): [t<A, B>, t<A, B>];

export function lengthNode<A, B>(n: node<A, B>): number;

export function size<A, B>(n: rescript.option<node<A, B>>): number;

export function toListAux<A, B>(
  n: t<A, B>,
  accu: rescript.list<[A, B]>,
): rescript.list<[A, B]>;

export function toList<A, B>(s: t<A, B>): rescript.list<[A, B]>;

export function checkInvariantInternal<A, B>(v: t<A, B>): void;

export function fillArrayKey<A, B>(
  n: node<A, B>,
  i: number,
  arr: A.t<A>,
): number;

export function fillArrayValue<A, B>(
  n: node<A, B>,
  i: number,
  arr: A.t<B>,
): number;

export function fillArray<A, B>(
  n: node<A, B>,
  i: number,
  arr: A.t<[A, B]>,
): number;

export function toArray<A, B>(n: rescript.option<node<A, B>>): A.t<[A, B]>;

export function keysToArray<A, B>(n: rescript.option<node<A, B>>): A.t<A>;

export function valuesToArray<A, B>(n: rescript.option<node<A, B>>): A.t<B>;

export function fromSortedArrayRevAux<A, B>(
  arr: A.t<[A, B]>,
  off: number,
  len: number,
): t<A, B>;

export function fromSortedArrayAux<A, B>(
  arr: A.t<[A, B]>,
  off: number,
  len: number,
): t<A, B>;

export function fromSortedArrayUnsafe<A, B>(arr: A.t<[A, B]>): t<A, B>;

export function compareAux<A, B, C, D>(
  e1: rescript.list<node<A, B>>,
  e2: rescript.list<node<A, C>>,
  kcmp: Belt_Id.cmp<A, D>,
  vcmp: (arg0: B, arg1: C) => number,
): number;

export function eqAux<A, B, C, D>(
  e1: rescript.list<node<A, B>>,
  e2: rescript.list<node<A, C>>,
  kcmp: Belt_Id.cmp<A, D>,
  veq: (arg0: B, arg1: C) => boolean,
): boolean;

export function cmp<A, B, C, D>(
  s1: t<A, B>,
  s2: t<A, C>,
  kcmp: Belt_Id.cmp<A, D>,
  vcmp: (arg0: B, arg1: C) => number,
): number;

export function eq<A, B, C, D>(
  s1: t<A, B>,
  s2: t<A, C>,
  kcmp: Belt_Id.cmp<A, D>,
  veq: (arg0: B, arg1: C) => boolean,
): boolean;

export function get_<A, B, C>(
  n: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): rescript.option<B>;

export function getUndefined<A, B, C>(
  n: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): rescript.option<B>;

export function getOrThrow<A, B, C>(
  n: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): B;

export function getWithDefault<A, B, C>(
  n: t<A, B>,
  x: A,
  def: B,
  cmp: Belt_Id.cmp<A, C>,
): B;

export function has<A, B, C>(
  n: t<A, B>,
  x: A,
  cmp: Belt_Id.cmp<A, C>,
): boolean;

export function rotateWithLeftChild<A, B>(k2: node<A, B>): node<A, B>;

export function rotateWithRightChild<A, B>(k1: node<A, B>): node<A, B>;

export function doubleWithLeftChild<A, B>(k3: node<A, B>): node<A, B>;

export function doubleWithRightChild<A, B>(k2: node<A, B>): node<A, B>;

export function heightUpdateMutate<A, B>(t: node<A, B>): node<A, B>;

export function balMutate<A, B>(nt: node<A, B>): node<A, B>;

export function updateMutate<A, B, C>(
  t: t<A, B>,
  x: A,
  data: B,
  cmp: Belt_Id.cmp<A, C>,
): t<A, B>;

export function fromArray<A, B, C>(
  xs: [A, B][],
  cmp: Belt_Id.cmp<A, C>,
): t<A, B>;

export function removeMinAuxWithRootMutate<A, B>(
  nt: node<A, B>,
  n: node<A, B>,
): t<A, B>;