// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";
import type * as C from "./C.js";
import type * as N from "./N.js";

export type eq<A, Id> = Belt_Id.eq<A, Id>;

export type hash<A, Id> = Belt_Id.hash<A, Id>;

export type id<A, Id> = Belt_Id.hashable<A, Id>;

export type t<A, Id> = N.t<hash<A, Id>, eq<A, Id>, A>;

export function copyBucket<A, B>(
  hash: Belt_Id.hash<A, B>,
  h_buckets: A.t<C.opt<N.bucket<A>>>,
  ndata_tail: A.t<C.opt<N.bucket<A>>>,
  old_bucket: C.opt<N.bucket<A>>,
): void;

export function tryDoubleResize<A, B, C, D>(
  hash: Belt_Id.hash<A, B>,
  h: C.container<C, D, N.bucket<A>>,
): void;

export function removeBucket<A, B, C, D, E, F, G>(
  eq: Belt_Id.eq<A, B>,
  h: C.container<C, D, E>,
  h_buckets: F,
  i: G,
  key: A,
  prec: N.bucket<A>,
  cell: N.bucket<A>,
): void;

export function remove<A, B, C>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A>>,
  key: A,
): void;

export function addBucket<A, B, C, D, E>(
  h: C.container<A, B, C>,
  key: D,
  cell: N.bucket<D>,
  eq: Belt_Id.eq<D, E>,
): void;

export function add0<A, B, C, D, E>(
  h: C.container<A, B, N.bucket<C>>,
  key: C,
  hash: Belt_Id.hash<C, D>,
  eq: Belt_Id.eq<C, E>,
): void;

export function add<A, B, C>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A>>,
  key: A,
): void;

export function memInBucket<A, B>(
  eq: Belt_Id.eq<A, B>,
  key: A,
  cell: N.bucket<A>,
): boolean;

export function has<A, B, C>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A>>,
  key: A,
): boolean;

export function make<A, B, C>(
  hintSize: number,
  id: id<A, B>,
): C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, B>, C>;

export function clear<A, B, C>(arg0: C.container<A, B, C>): void;

export function size<A, B, C>(h: C.container<A, B, C>): number;

export function forEach<A, B, C>(
  arg0: N.t<A, B, C>,
  arg1: (arg0: C) => void,
): void;

export function reduce<A, B, C, D>(
  arg0: N.t<A, B, C>,
  arg1: D,
  arg2: (arg0: D, arg1: C) => D,
): D;

export function logStats<A, B, C>(arg0: N.t<A, B, C>): void;

export function toArray<A, B, C>(arg0: N.t<A, B, C>): C[];

export function copy<A, B, C>(arg0: N.t<A, B, C>): N.t<A, B, C>;

export function getBucketHistogram<A, B, C>(arg0: N.t<A, B, C>): number[];

export function isEmpty<A, B, C>(arg0: C.container<A, B, C>): boolean;

export function fromArray<A, B>(
  arr: A.t<A>,
  id: id<A, B>,
): C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, B>, N.bucket<A>>;

export function mergeMany<A, B, C>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A>>,
  arr: A.t<A>,
): void;

export function forEachU<A, B, C>(
  arg0: N.t<A, B, C>,
  arg1: (arg0: C) => void,
): void;

export function reduceU<A, B, C, D>(
  arg0: N.t<A, B, C>,
  arg1: D,
  arg2: (arg0: D, arg1: C) => D,
): D;