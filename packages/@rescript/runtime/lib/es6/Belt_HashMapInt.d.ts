// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as C from "./C.js";
import type * as N from "./N.js";

export type key = number;

export type seed = number;

export type t<B> = N.t<void, void, key, B>;

export function hash(s: key): seed;

export function copyBucketReHash<A>(
  h_buckets: A.t<C.opt<N.bucket<key, A>>>,
  ndata_tail: A.t<C.opt<N.bucket<key, A>>>,
  old_bucket: C.opt<N.bucket<key, A>>,
): void;

export function resize<A, B, C>(h: C.container<A, B, N.bucket<key, C>>): void;

export function replaceInBucket<A>(
  key: key,
  info: A,
  cell: N.bucket<key, A>,
): boolean;

export function set_<A, B, C>(
  h: C.container<A, B, N.bucket<key, C>>,
  key: key,
  value: C,
): void;

export function removeInBucket<A, B, C, D, E, F>(
  h: C.container<A, B, C>,
  h_buckets: D,
  i: E,
  key: key,
  prec: N.bucket<key, F>,
  buckets: C.opt<N.bucket<key, F>>,
): void;

export function remove<A, B, C>(
  h: C.container<A, B, N.bucket<key, C>>,
  key: key,
): void;

export function getAux<A>(
  key: key,
  buckets: C.opt<N.bucket<key, A>>,
): rescript.option<A>;

export function get_<A, B, C>(
  h: C.container<A, B, N.bucket<key, C>>,
  key: key,
): rescript.option<C>;

export function memInBucket<A>(key: key, cell: N.bucket<key, A>): boolean;

export function has<A, B, C>(
  h: C.container<A, B, N.bucket<key, C>>,
  key: key,
): boolean;

export function make<A>(hintSize: number): C.container<void, void, A>;

export function clear<A, B, C>(arg0: C.container<A, B, C>): void;

export function size<A, B, C>(h: C.container<A, B, C>): number;

export function forEach<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => E,
): void;

export function reduce<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: E,
  arg2: (arg0: E, arg1: C, arg2: D) => E,
): E;

export function logStats<A, B, C, D>(arg0: N.t<A, B, C, D>): void;

export function keepMapInPlace<A, B, C, D>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => rescript.option<D>,
): void;

export function toArray<A, B, C, D>(arg0: N.t<A, B, C, D>): [C, D][];

export function copy<A, B, C, D>(arg0: N.t<A, B, C, D>): N.t<A, B, C, D>;

export function keysToArray<A, B, C, D>(arg0: N.t<A, B, C, D>): C[];

export function valuesToArray<A, B, C, D>(arg0: N.t<A, B, C, D>): D[];

export function getBucketHistogram<A, B, C, D>(arg0: N.t<A, B, C, D>): number[];

export function isEmpty<A, B, C>(arg0: C.container<A, B, C>): boolean;

export function fromArray<A>(
  arr: A.t<[key, A]>,
): C.container<void, void, N.bucket<key, A>>;

export function mergeMany<A, B, C>(
  h: C.container<A, B, N.bucket<key, C>>,
  arr: A.t<[key, C]>,
): void;

export function forEachU<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => E,
): void;

export function reduceU<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: E,
  arg2: (arg0: E, arg1: C, arg2: D) => E,
): E;

export function keepMapInPlaceU<A, B, C, D>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => rescript.option<D>,
): void;