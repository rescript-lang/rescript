// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";
import type * as C from "./C.js";
import type * as N from "./N.js";

export type eq<A, Id> = Belt_Id.eq<A, Id>;

export type hash<A, Id> = Belt_Id.hash<A, Id>;

export type id<A, Id> = Belt_Id.hashable<A, Id>;

export type t<A, B, Id> = N.t<hash<A, Id>, eq<A, Id>, A, B>;

export function clear<A, B, C>(arg0: C.container<A, B, C>): void;

export function size<A, B, C>(h: C.container<A, B, C>): number;

export function forEach<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => E,
): void;

export function reduce<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: E,
  arg2: (arg0: E, arg1: C, arg2: D) => E,
): E;

export function logStats<A, B, C, D>(arg0: N.t<A, B, C, D>): void;

export function keepMapInPlace<A, B, C, D>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => rescript.option<D>,
): void;

export function toArray<A, B, C, D>(arg0: N.t<A, B, C, D>): [C, D][];

export function copy<A, B, C, D>(arg0: N.t<A, B, C, D>): N.t<A, B, C, D>;

export function keysToArray<A, B, C, D>(arg0: N.t<A, B, C, D>): C[];

export function valuesToArray<A, B, C, D>(arg0: N.t<A, B, C, D>): D[];

export function getBucketHistogram<A, B, C, D>(arg0: N.t<A, B, C, D>): number[];

export function isEmpty<A, B, C>(arg0: C.container<A, B, C>): boolean;

export function copyBucketReHash<A, B>(
  hash: (arg0: A) => number,
  h_buckets: A.t<C.opt<N.bucket<A, B>>>,
  ndata_tail: A.t<C.opt<N.bucket<A, B>>>,
  old_bucket: C.opt<N.bucket<A, B>>,
): void;

export function resize<A, B, C, D>(
  hash: (arg0: A) => number,
  h: C.container<B, C, N.bucket<A, D>>,
): void;

export function replaceInBucket<A, B, C>(
  eq: (arg0: A, arg1: B) => boolean,
  key: B,
  info: C,
  cell: N.bucket<A, C>,
): boolean;

export function set0<A, B, C, D>(
  h: C.container<A, B, N.bucket<C, D>>,
  key: C,
  value: D,
  eq: (arg0: C, arg1: C) => boolean,
  hash: (arg0: C) => number,
): void;

export function set_<A, B, C, D>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A, D>>,
  key: A,
  value: D,
): void;

export function removeInBucket<A, B, C, D, E, F, G, H>(
  h: C.container<A, B, C>,
  h_buckets: D,
  i: E,
  key: F,
  prec: N.bucket<G, H>,
  bucket: C.opt<N.bucket<G, H>>,
  eq: (arg0: G, arg1: F) => boolean,
): void;

export function remove<A, B, C, D>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A, D>>,
  key: A,
): void;

export function getAux<A, B, C>(
  eq: (arg0: A, arg1: B) => boolean,
  key: A,
  buckets: C.opt<N.bucket<B, C>>,
): rescript.option<C>;

export function get_<A, B, C, D>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A, D>>,
  key: A,
): rescript.option<D>;

export function memInBucket<A, B, C>(
  key: A,
  cell: N.bucket<B, C>,
  eq: (arg0: B, arg1: A) => boolean,
): boolean;

export function has<A, B, C, D>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A, D>>,
  key: A,
): boolean;

export function make<A, B, C>(
  hintSize: number,
  id: id<A, B>,
): C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, B>, C>;

export function fromArray<A, B, C>(
  arr: A.t<[A, B]>,
  id: id<A, C>,
): C.container<Belt_Id.hash<A, C>, Belt_Id.eq<A, C>, N.bucket<A, B>>;

export function mergeMany<A, B, C, D>(
  h: C.container<Belt_Id.hash<A, B>, Belt_Id.eq<A, C>, N.bucket<A, D>>,
  arr: A.t<[A, D]>,
): void;

export function forEachU<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => E,
): void;

export function reduceU<A, B, C, D, E>(
  arg0: N.t<A, B, C, D>,
  arg1: E,
  arg2: (arg0: E, arg1: C, arg2: D) => E,
): E;

export function keepMapInPlaceU<A, B, C, D>(
  arg0: N.t<A, B, C, D>,
  arg1: (arg0: C, arg1: D) => rescript.option<D>,
): void;