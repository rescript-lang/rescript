// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";

export type t<A> = A[];

export type arrayLike<A> = rescript.opaque<"Stdlib_Array.arrayLike", [A]>;

export type M = {
  floor: (arg0: number) => number;
  random: () => number;
  fromFloat: (arg0: number) => number;
  toFloat: (arg0: number) => number;
  random_int: (arg0: number, arg1: number) => number;
};
export const M: M;

export function make<A>(length: number, x: A): A[];

export function fromInitializer<A>(length: number, f: (arg0: number) => A): A[];

export function isEmpty<A>(arr: A[]): boolean;

export function equalFromIndex<A, B>(
  a: A[],
  b: B[],
  i: number,
  eq: (arg0: A, arg1: B) => boolean,
  len: number,
): boolean;

export function equal<A, B>(
  a: A[],
  b: B[],
  eq: (arg0: A, arg1: B) => boolean,
): boolean;

export function compareFromIndex<A, B>(
  a: A[],
  b: B[],
  i: number,
  cmp: (arg0: A, arg1: B) => number,
  len: number,
): number;

export function compare<A, B>(
  a: A[],
  b: B[],
  cmp: (arg0: A, arg1: B) => number,
): number;

export function indexOfOpt<A>(arr: A[], item: A): rescript.option<number>;

export function lastIndexOfOpt<A>(arr: A[], item: A): rescript.option<number>;

export function reduce<A, B>(arr: A[], init: B, f: (arg0: B, arg1: A) => B): B;

export function reduceWithIndex<A, B>(
  arr: A[],
  init: B,
  f: (arg0: B, arg1: A, arg2: number) => B,
): B;

export function reduceRight<A, B>(
  arr: A[],
  init: B,
  f: (arg0: B, arg1: A) => B,
): B;

export function reduceRightWithIndex<A, B>(
  arr: A[],
  init: B,
  f: (arg0: B, arg1: A, arg2: number) => B,
): B;

export function findIndexOpt<A>(
  array: A[],
  finder: (arg0: A) => boolean,
): rescript.option<number>;

export function findLastIndexOpt<A>(
  array: A[],
  finder: (arg0: A) => boolean,
): rescript.option<number>;

export function swapUnsafe<A>(xs: A[], i: number, j: number): void;

export function shuffle<A>(xs: A[]): void;

export function toShuffled<A>(xs: A[]): A[];

export function filterMap<A, B>(a: A[], f: (arg0: A) => rescript.option<B>): B[];

export function keepSome<A>(__x: rescript.option<A>[]): A[];

export function filterMapWithIndex<A, B>(
  a: A[],
  f: (arg0: A, arg1: number) => rescript.option<B>,
): B[];

export function findMap<A, B>(
  arr: A[],
  f: (arg0: A) => rescript.option<B>,
): rescript.option<B>;

export function last<A>(a: A[]): rescript.option<A>;