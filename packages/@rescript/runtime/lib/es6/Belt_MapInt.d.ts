// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as I from "./I.js";
import type * as N from "./N.js";

export type key = number;

export type t<A> = N.t<key, A>;

export const empty: rescript.option<any>;

export function isEmpty<A, B>(arg0: N.t<A, B>): boolean;

export function minKey<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function minKeyUndefined<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function maxKey<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function maxKeyUndefined<A, B>(arg0: N.t<A, B>): rescript.option<A>;

export function minimum<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function minUndefined<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function maximum<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function maxUndefined<A, B>(arg0: N.t<A, B>): rescript.option<[A, B]>;

export function findFirstBy<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): rescript.option<[A, B]>;

export function forEach<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => void,
): void;

export function map<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: B) => C,
): N.t<A, C>;

export function mapWithKey<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => C,
): N.t<A, C>;

export function reduce<A, B, C>(
  arg0: N.t<A, B>,
  arg1: C,
  arg2: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function every<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function some<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function keep<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): N.t<A, B>;

export function partition<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): [N.t<A, B>, N.t<A, B>];

export function size<A, B>(arg0: N.t<A, B>): number;

export function toList<A, B>(arg0: N.t<A, B>): rescript.list<[A, B]>;

export function toArray<A, B>(arg0: N.t<A, B>): [A, B][];

export function keysToArray<A, B>(arg0: N.t<A, B>): A[];

export function valuesToArray<A, B>(arg0: N.t<A, B>): B[];

export function checkInvariantInternal<A, B>(arg0: N.t<A, B>): void;

export function set_<A>(t: N.t<key, A>, newK: key, newD: A): N.t<key, A>;

export function update<A>(
  t: N.t<key, A>,
  x: key,
  f: (arg0: rescript.option<A>) => rescript.option<A>,
): N.t<key, A>;

export function removeAux<A>(n: N.node<key, A>, x: key): N.t<key, A>;

export function remove<A>(
  n: rescript.option<N.node<key, A>>,
  x: key,
): N.t<key, A>;

export function removeMany0<A>(
  t: N.node<key, A>,
  xs: A.t<key>,
  i: number,
  len: number,
): N.t<key, A>;

export function removeMany<A>(
  t: rescript.option<N.node<key, A>>,
  keys: A.t<key>,
): N.t<key, A>;

export function mergeMany<A>(
  h: N.t<key, A>,
  arr: A.t<[key, A]>,
): N.t<key, A>;

export function has<A>(arg0: I.N.t<I.key, A>, arg1: I.key): boolean;

export function cmp<A, B>(
  arg0: I.N.t<I.key, A>,
  arg1: I.N.t<I.key, B>,
  arg2: (arg0: A, arg1: B) => number,
): number;

export function eq<A, B>(
  arg0: I.N.t<I.key, A>,
  arg1: I.N.t<I.key, B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function get_<A>(arg0: I.N.t<I.key, A>, arg1: I.key): rescript.option<A>;

export function getUndefined<A>(
  arg0: I.N.t<I.key, A>,
  arg1: I.key,
): rescript.option<A>;

export function getWithDefault<A>(
  arg0: I.N.t<I.key, A>,
  arg1: I.key,
  arg2: A,
): A;

export function getOrThrow<A>(arg0: I.N.t<I.key, A>, arg1: I.key): A;

export function getExn<A>(arg0: I.N.t<I.key, A>, arg1: I.key): A;

export function split<A>(
  arg0: I.key,
  arg1: rescript.option<I.N.node<I.key, A>>,
): [I.t<A>, rescript.option<A>, I.t<A>];

export function merge<A, B, C>(
  arg0: I.N.t<I.key, A>,
  arg1: I.t<B>,
  arg2: (arg0: I.key, arg1: rescript.option<A>, arg2: rescript.option<B>) => rescript.option<C>,
): I.N.t<I.key, C>;

export function fromArray<A>(arg0: [I.key, A][]): I.N.t<I.key, A>;

export function cmpU<A, B>(
  arg0: I.N.t<I.key, A>,
  arg1: I.N.t<I.key, B>,
  arg2: (arg0: A, arg1: B) => number,
): number;

export function eqU<A, B>(
  arg0: I.N.t<I.key, A>,
  arg1: I.N.t<I.key, B>,
  arg2: (arg0: A, arg1: B) => boolean,
): boolean;

export function everyU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function findFirstByU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): rescript.option<[A, B]>;

export function forEachU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => void,
): void;

export function keepU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): N.t<A, B>;

export function mapU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: B) => C,
): N.t<A, C>;

export function mapWithKeyU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => C,
): N.t<A, C>;

export function mergeU<A, B, C>(
  arg0: I.N.t<I.key, A>,
  arg1: I.t<B>,
  arg2: (arg0: I.key, arg1: rescript.option<A>, arg2: rescript.option<B>) => rescript.option<C>,
): I.N.t<I.key, C>;

export function partitionU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): [N.t<A, B>, N.t<A, B>];

export function reduceU<A, B, C>(
  arg0: N.t<A, B>,
  arg1: C,
  arg2: (arg0: C, arg1: A, arg2: B) => C,
): C;

export function someU<A, B>(
  arg0: N.t<A, B>,
  arg1: (arg0: A, arg1: B) => boolean,
): boolean;

export function updateU<A>(
  arg0: N.t<key, A>,
  arg1: key,
  arg2: (arg0: rescript.option<A>) => rescript.option<A>,
): N.t<key, A>;