// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as C from "./C.js";

export interface bucket<A, B> {
  key: A;
  value: B;
  next: C.opt<bucket<A, B>>;
}

export type t<Hash, Eq, A, B> = C.container<Hash, Eq, bucket<A, B>>;

export function copy<A, B, C, D>(x: t<A, B, C, D>): t<A, B, C, D>;

export function copyBuckets<A, B>(
  buckets: C.opt<bucket<A, B>>[],
): A.t<C.opt<bucket<A, B>>>;

export function copyBucket<A, B>(c: C.opt<bucket<A, B>>): C.opt<bucket<A, B>>;

export function copyAuxCont<A, B>(c: C.opt<bucket<A, B>>, prec: bucket<A, B>): void;

export function bucketLength<A, B>(
  accu: number,
  buckets: C.opt<bucket<A, B>>,
): number;

export function do_bucket_iter<A, B, C>(
  f: (arg0: A, arg1: B) => C,
  buckets: C.opt<bucket<A, B>>,
): void;

export function forEach<A, B, C, D, E>(
  h: C.container<A, B, bucket<C, D>>,
  f: (arg0: C, arg1: D) => E,
): void;

export function do_bucket_fold<A, B, C>(
  f: (arg0: A, arg1: B, arg2: C) => A,
  b: C.opt<bucket<B, C>>,
  accu: A,
): A;

export function reduce<A, B, C, D, E>(
  h: C.container<A, B, bucket<C, D>>,
  init: E,
  f: (arg0: E, arg1: C, arg2: D) => E,
): E;

export function getMaxBucketLength<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
): number;

export function getBucketHistogram<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
): A.t<number>;

export function logStats<A, B, C, D>(h: C.container<A, B, bucket<C, D>>): void;

export function filterMapInplaceBucket<A, B, C, D>(
  f: (arg0: A, arg1: B) => rescript.option<B>,
  h: C.container<C, D, bucket<A, B>>,
  i: number,
  prec: C.opt<bucket<A, B>>,
  cell: bucket<A, B>,
): void;

export function keepMapInPlace<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
  f: (arg0: C, arg1: D) => rescript.option<D>,
): void;

export function fillArray<A, B>(
  i: number,
  arr: A.t<[A, B]>,
  cell: bucket<A, B>,
): number;

export function fillArrayMap<A, B, C>(
  i: number,
  arr: A.t<A>,
  cell: bucket<B, C>,
  f: (arg0: bucket<B, C>) => A,
): number;

export function linear<A, B, C, D, E>(
  h: C.container<A, B, bucket<C, D>>,
  f: (arg0: bucket<C, D>) => E,
): A.t<E>;

export function keysToArray<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
): A.t<C>;

export function valuesToArray<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
): A.t<D>;

export function toArray<A, B, C, D>(
  h: C.container<A, B, bucket<C, D>>,
): A.t<[C, D]>;