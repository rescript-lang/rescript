// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as Belt_Id from "./Belt_Id.js";

export interface node<Value> {
  v: Value;
  h: number;
  l: t<Value>;
  r: t<Value>;
}

export type t<Value> = rescript.option<node<Value>>;

export type cmp<A, B> = Belt_Id.cmp<A, B>;

export interface cursor {
  forward: number;
  backward: number;
}

export function height<A>(n: t<A>): number;

export function copy<A>(n: t<A>): t<A>;

export function calcHeight(hl: number, hr: number): number;

export function create<A>(l: t<A>, v: A, r: t<A>): rescript.option<node<A>>;

export function singleton<A>(x: A): rescript.option<node<A>>;

export function heightGe<A, B>(
  l: rescript.option<node<A>>,
  r: rescript.option<node<B>>,
): boolean;

export function bal<A>(l: t<A>, v: A, r: t<A>): rescript.option<node<A>>;

export function min0Aux<A>(n: node<A>): A;

export function minimum<A>(n: rescript.option<node<A>>): rescript.option<A>;

export function minUndefined<A>(n: rescript.option<node<A>>): rescript.option<A>;

export function max0Aux<A>(n: node<A>): A;

export function maximum<A>(n: rescript.option<node<A>>): rescript.option<A>;

export function maxUndefined<A>(n: rescript.option<node<A>>): rescript.option<A>;

export function removeMinAuxWithRef<A>(n: node<A>, v: rescript.ref<A>): t<A>;

export function isEmpty<A>(n: rescript.option<A>): boolean;

export function stackAllLeft<A>(
  v: t<A>,
  s: rescript.list<node<A>>,
): rescript.list<node<A>>;

export function forEach<A>(n: t<A>, f: (arg0: A) => void): void;

export function reduce<A, B>(s: t<A>, accu: B, f: (arg0: B, arg1: A) => B): B;

export function every<A>(n: t<A>, p: (arg0: A) => boolean): boolean;

export function some<A>(n: t<A>, p: (arg0: A) => boolean): boolean;

export function addMinElement<A>(n: t<A>, v: A): t<A>;

export function addMaxElement<A>(n: t<A>, v: A): t<A>;

export function joinShared<A>(ln: t<A>, v: A, rn: t<A>): t<A>;

export function concatShared<A>(t1: t<A>, t2: t<A>): t<A>;

export function partitionShared<A>(
  n: t<A>,
  p: (arg0: A) => boolean,
): [t<A>, t<A>];

export function lengthNode<A>(n: node<A>): number;

export function size<A>(n: rescript.option<node<A>>): number;

export function toListAux<A>(n: t<A>, accu: rescript.list<A>): rescript.list<A>;

export function toList<A>(s: t<A>): rescript.list<A>;

export function checkInvariantInternal<A>(v: t<A>): void;

export function fillArray<A>(n: node<A>, i: number, arr: A.t<A>): number;

export function fillArrayWithPartition<A>(
  n: node<A>,
  cursor: cursor,
  arr: A.t<A>,
  p: (arg0: A) => boolean,
): void;

export function fillArrayWithFilter<A>(
  n: node<A>,
  i: number,
  arr: A.t<A>,
  p: (arg0: A) => boolean,
): number;

export function toArray<A>(n: rescript.option<node<A>>): A.t<A>;

export function fromSortedArrayRevAux<A>(
  arr: A.t<A>,
  off: number,
  len: number,
): t<A>;

export function fromSortedArrayAux<A>(
  arr: A.t<A>,
  off: number,
  len: number,
): t<A>;

export function fromSortedArrayUnsafe<A>(arr: A.t<A>): t<A>;

export function keepShared<A>(n: t<A>, p: (arg0: A) => boolean): t<A>;

export function keepCopy<A>(
  n: rescript.option<node<A>>,
  p: (arg0: A) => boolean,
): t<A>;

export function partitionCopy<A>(
  n: rescript.option<node<A>>,
  p: (arg0: A) => boolean,
): [t<A>, t<A>];

export function has<A, B>(t: t<A>, x: A, cmp: Belt_Id.cmp<A, B>): boolean;

export function compareAux<A, B>(
  e1: rescript.list<node<A>>,
  e2: rescript.list<node<A>>,
  cmp: Belt_Id.cmp<A, B>,
): number;

export function cmp<A, B>(
  s1: t<A>,
  s2: t<A>,
  cmp: Belt_Id.cmp<A, B>,
): number;

export function eq<A, B>(
  s1: t<A>,
  s2: t<A>,
  cmp: Belt_Id.cmp<A, B>,
): boolean;

export function subset<A, B>(
  s1: t<A>,
  s2: t<A>,
  cmp: Belt_Id.cmp<A, B>,
): boolean;

export function get_<A, B>(
  n: t<A>,
  x: A,
  cmp: Belt_Id.cmp<A, B>,
): rescript.option<A>;

export function getUndefined<A, B>(
  n: t<A>,
  x: A,
  cmp: Belt_Id.cmp<A, B>,
): rescript.option<A>;

export function getOrThrow<A, B>(n: t<A>, x: A, cmp: Belt_Id.cmp<A, B>): A;

export function rotateWithLeftChild<A>(k2: node<A>): node<A>;

export function rotateWithRightChild<A>(k1: node<A>): node<A>;

export function doubleWithLeftChild<A>(k3: node<A>): node<A>;

export function doubleWithRightChild<A>(k2: node<A>): node<A>;

export function heightUpdateMutate<A>(t: node<A>): node<A>;

export function balMutate<A>(nt: node<A>): node<A>;

export function addMutate<A, B>(
  cmp: Belt_Id.cmp<A, B>,
  t: t<A>,
  x: A,
): t<A>;

export function fromArray<A, B>(xs: A[], cmp: Belt_Id.cmp<A, B>): t<A>;

export function removeMinAuxWithRootMutate<A>(
  nt: node<A>,
  n: node<A>,
): t<A>;