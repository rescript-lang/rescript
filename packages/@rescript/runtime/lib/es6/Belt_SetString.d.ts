// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as A from "./A.js";
import type * as I from "./I.js";
import type * as N from "./N.js";

export type value = I.value;

export type t = I.t;

export const empty: rescript.option<any>;

export function isEmpty<A>(arg0: N.t<A>): boolean;

export function minimum<A>(arg0: N.t<A>): rescript.option<A>;

export function minUndefined<A>(arg0: N.t<A>): rescript.option<A>;

export function maximum<A>(arg0: N.t<A>): rescript.option<A>;

export function maxUndefined<A>(arg0: N.t<A>): rescript.option<A>;

export function forEach<A>(arg0: N.t<A>, arg1: (arg0: A) => void): void;

export function reduce<A, B>(
  arg0: N.t<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function every<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function some<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function keep<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): N.t<A>;

export function partition<A>(
  arg0: N.t<A>,
  arg1: (arg0: A) => boolean,
): [N.t<A>, N.t<A>];

export function size<A>(arg0: N.t<A>): number;

export function toList<A>(arg0: N.t<A>): rescript.list<A>;

export function toArray<A>(arg0: N.t<A>): A[];

export function fromSortedArrayUnsafe<A>(arg0: A[]): N.t<A>;

export function checkInvariantInternal<A>(arg0: N.t<A>): void;

export function add(t: t, x: value): t;

export function mergeMany(h: t, arr: A.t<value>): t;

export function remove(t: t, x: value): t;

export function removeMany(h: t, arr: A.t<value>): t;

export function fromArray(arg0: I.value[]): I.N.t<I.value>;

export function cmp(arg0: I.N.t<I.value>, arg1: I.N.t<I.value>): number;

export function eq(arg0: I.t, arg1: I.N.t<I.value>): boolean;

export function get_(arg0: I.t, arg1: I.value): rescript.option<I.value>;

export function getUndefined(arg0: I.t, arg1: I.value): rescript.option<I.value>;

export function getOrThrow(arg0: I.t, arg1: I.value): I.value;

export function getExn(arg0: I.t, arg1: I.value): I.value;

export function subset(arg0: I.t, arg1: I.t): boolean;

export function has(arg0: I.t, arg1: I.value): boolean;

export function splitAuxNoPivot(n: N.node<value>, x: value): [t, t];

export function splitAuxPivot(
  n: N.node<value>,
  x: value,
  pres: rescript.ref<boolean>,
): [t, t];

export function split(t: t, x: value): [[t, t], boolean];

export function union(s1: t, s2: t): t;

export function intersect(s1: t, s2: t): N.t<I.value>;

export function diff(s1: t, s2: t): t;

export function forEachU<A>(arg0: N.t<A>, arg1: (arg0: A) => void): void;

export function reduceU<A, B>(
  arg0: N.t<A>,
  arg1: B,
  arg2: (arg0: B, arg1: A) => B,
): B;

export function everyU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function someU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): boolean;

export function keepU<A>(arg0: N.t<A>, arg1: (arg0: A) => boolean): N.t<A>;

export function partitionU<A>(
  arg0: N.t<A>,
  arg1: (arg0: A) => boolean,
): [N.t<A>, N.t<A>];