// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as Stdlib_ArrayBuffer from "./Stdlib_ArrayBuffer.js";

export type array_buffer = Stdlib_ArrayBuffer.t;

export type array_like<A> = rescript.opaque<"Js_typed_array2.array_like", [A]>;

declare namespace ArrayBuffer {
  type t = array_buffer;
}
export type ArrayBuffer = {
  make: (arg0: number) => ArrayBuffer.t;
  byteLength: (arg0: ArrayBuffer.t) => number;
  slice: (arg0: ArrayBuffer.t, start: number, end_: number) => array_buffer;
  sliceFrom: (arg0: ArrayBuffer.t, arg1: number) => array_buffer;
};
export const ArrayBuffer: ArrayBuffer;

declare namespace Int8Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Int8Array.typed_array", [A]>;
  type t = Int8Array.typed_array<Int8Array.elt>;
}
export type Int8Array = {
  unsafe_get: (arg0: Int8Array.t, arg1: number) => Int8Array.elt;
  unsafe_set: (arg0: Int8Array.t, arg1: number, arg2: Int8Array.elt) => void;
  buffer: (arg0: Int8Array.t) => array_buffer;
  byteLength: (arg0: Int8Array.t) => number;
  byteOffset: (arg0: Int8Array.t) => number;
  setArray: (arg0: Int8Array.t, arg1: Int8Array.elt[]) => void;
  setArrayOffset: (arg0: Int8Array.t, arg1: Int8Array.elt[], arg2: number) => void;
  length: (arg0: Int8Array.t) => number;
  copyWithin: (arg0: Int8Array.t, to_: number) => Int8Array.t;
  copyWithinFrom: (arg0: Int8Array.t, to_: number, from: number) => Int8Array.t;
  copyWithinFromRange: (arg0: Int8Array.t, to_: number, start: number, end_: number) => Int8Array.t;
  fillInPlace: (arg0: Int8Array.t, arg1: Int8Array.elt) => Int8Array.t;
  fillFromInPlace: (arg0: Int8Array.t, arg1: Int8Array.elt, from: number) => Int8Array.t;
  fillRangeInPlace: (arg0: Int8Array.t, arg1: Int8Array.elt, start: number, end_: number) => Int8Array.t;
  reverseInPlace: (arg0: Int8Array.t) => Int8Array.t;
  sortInPlace: (arg0: Int8Array.t) => Int8Array.t;
  sortInPlaceWith: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: Int8Array.elt) => number) => Int8Array.t;
  includes: (arg0: Int8Array.t, arg1: Int8Array.elt) => boolean;
  indexOf: (arg0: Int8Array.t, arg1: Int8Array.elt) => number;
  indexOfFrom: (arg0: Int8Array.t, arg1: Int8Array.elt, from: number) => number;
  join: (arg0: Int8Array.t) => string;
  joinWith: (arg0: Int8Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Int8Array.t, arg1: Int8Array.elt) => number;
  lastIndexOfFrom: (arg0: Int8Array.t, arg1: Int8Array.elt, from: number) => number;
  slice: (arg0: Int8Array.t, start: number, end_: number) => Int8Array.t;
  copy: (arg0: Int8Array.t) => Int8Array.t;
  sliceFrom: (arg0: Int8Array.t, arg1: number) => Int8Array.t;
  subarray: (arg0: Int8Array.t, start: number, end_: number) => Int8Array.t;
  subarrayFrom: (arg0: Int8Array.t, arg1: number) => Int8Array.t;
  toString: (arg0: Int8Array.t) => string;
  toLocaleString: (arg0: Int8Array.t) => string;
  every: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => boolean) => boolean;
  everyi: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => boolean) => Int8Array.t;
  filteri: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => boolean) => Int8Array.t;
  find: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => boolean) => rescript.option<Int8Array.elt>;
  findi: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => boolean) => rescript.option<Int8Array.elt>;
  findIndex: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => boolean) => number;
  findIndexi: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => void) => void;
  forEachi: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => void) => void;
  map: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => B) => Int8Array.typed_array<B>;
  mapi: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => B) => Int8Array.typed_array<B>;
  reduce: (arg0: Int8Array.t, arg1: (arg0: B, arg1: Int8Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Int8Array.t, arg1: (arg0: B, arg1: Int8Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Int8Array.t, arg1: (arg0: B, arg1: Int8Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Int8Array.t, arg1: (arg0: B, arg1: Int8Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt) => boolean) => boolean;
  somei: (arg0: Int8Array.t, arg1: (arg0: Int8Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Int8Array.elt[]) => Int8Array.t;
  fromBuffer: (arg0: array_buffer) => Int8Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Int8Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Int8Array.t;
  fromLength: (arg0: number) => Int8Array.t;
  from: (arg0: array_like<Int8Array.elt>) => Int8Array.t;
};
export const Int8Array: Int8Array;

declare namespace Uint8Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Uint8Array.typed_array", [A]>;
  type t = Uint8Array.typed_array<Uint8Array.elt>;
}
export type Uint8Array = {
  unsafe_get: (arg0: Uint8Array.t, arg1: number) => Uint8Array.elt;
  unsafe_set: (arg0: Uint8Array.t, arg1: number, arg2: Uint8Array.elt) => void;
  buffer: (arg0: Uint8Array.t) => array_buffer;
  byteLength: (arg0: Uint8Array.t) => number;
  byteOffset: (arg0: Uint8Array.t) => number;
  setArray: (arg0: Uint8Array.t, arg1: Uint8Array.elt[]) => void;
  setArrayOffset: (arg0: Uint8Array.t, arg1: Uint8Array.elt[], arg2: number) => void;
  length: (arg0: Uint8Array.t) => number;
  copyWithin: (arg0: Uint8Array.t, to_: number) => Uint8Array.t;
  copyWithinFrom: (arg0: Uint8Array.t, to_: number, from: number) => Uint8Array.t;
  copyWithinFromRange: (arg0: Uint8Array.t, to_: number, start: number, end_: number) => Uint8Array.t;
  fillInPlace: (arg0: Uint8Array.t, arg1: Uint8Array.elt) => Uint8Array.t;
  fillFromInPlace: (arg0: Uint8Array.t, arg1: Uint8Array.elt, from: number) => Uint8Array.t;
  fillRangeInPlace: (arg0: Uint8Array.t, arg1: Uint8Array.elt, start: number, end_: number) => Uint8Array.t;
  reverseInPlace: (arg0: Uint8Array.t) => Uint8Array.t;
  sortInPlace: (arg0: Uint8Array.t) => Uint8Array.t;
  sortInPlaceWith: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: Uint8Array.elt) => number) => Uint8Array.t;
  includes: (arg0: Uint8Array.t, arg1: Uint8Array.elt) => boolean;
  indexOf: (arg0: Uint8Array.t, arg1: Uint8Array.elt) => number;
  indexOfFrom: (arg0: Uint8Array.t, arg1: Uint8Array.elt, from: number) => number;
  join: (arg0: Uint8Array.t) => string;
  joinWith: (arg0: Uint8Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Uint8Array.t, arg1: Uint8Array.elt) => number;
  lastIndexOfFrom: (arg0: Uint8Array.t, arg1: Uint8Array.elt, from: number) => number;
  slice: (arg0: Uint8Array.t, start: number, end_: number) => Uint8Array.t;
  copy: (arg0: Uint8Array.t) => Uint8Array.t;
  sliceFrom: (arg0: Uint8Array.t, arg1: number) => Uint8Array.t;
  subarray: (arg0: Uint8Array.t, start: number, end_: number) => Uint8Array.t;
  subarrayFrom: (arg0: Uint8Array.t, arg1: number) => Uint8Array.t;
  toString: (arg0: Uint8Array.t) => string;
  toLocaleString: (arg0: Uint8Array.t) => string;
  every: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => boolean) => boolean;
  everyi: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => boolean) => Uint8Array.t;
  filteri: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => boolean) => Uint8Array.t;
  find: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => boolean) => rescript.option<Uint8Array.elt>;
  findi: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => boolean) => rescript.option<Uint8Array.elt>;
  findIndex: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => boolean) => number;
  findIndexi: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => void) => void;
  forEachi: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => void) => void;
  map: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => B) => Uint8Array.typed_array<B>;
  mapi: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => B) => Uint8Array.typed_array<B>;
  reduce: (arg0: Uint8Array.t, arg1: (arg0: B, arg1: Uint8Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Uint8Array.t, arg1: (arg0: B, arg1: Uint8Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Uint8Array.t, arg1: (arg0: B, arg1: Uint8Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Uint8Array.t, arg1: (arg0: B, arg1: Uint8Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt) => boolean) => boolean;
  somei: (arg0: Uint8Array.t, arg1: (arg0: Uint8Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Uint8Array.elt[]) => Uint8Array.t;
  fromBuffer: (arg0: array_buffer) => Uint8Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Uint8Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Uint8Array.t;
  fromLength: (arg0: number) => Uint8Array.t;
  from: (arg0: array_like<Uint8Array.elt>) => Uint8Array.t;
};
export const Uint8Array: Uint8Array;

declare namespace Uint8ClampedArray {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Uint8ClampedArray.typed_array", [A]>;
  type t = Uint8ClampedArray.typed_array<Uint8ClampedArray.elt>;
}
export type Uint8ClampedArray = {
  unsafe_get: (arg0: Uint8ClampedArray.t, arg1: number) => Uint8ClampedArray.elt;
  unsafe_set: (arg0: Uint8ClampedArray.t, arg1: number, arg2: Uint8ClampedArray.elt) => void;
  buffer: (arg0: Uint8ClampedArray.t) => array_buffer;
  byteLength: (arg0: Uint8ClampedArray.t) => number;
  byteOffset: (arg0: Uint8ClampedArray.t) => number;
  setArray: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt[]) => void;
  setArrayOffset: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt[], arg2: number) => void;
  length: (arg0: Uint8ClampedArray.t) => number;
  copyWithin: (arg0: Uint8ClampedArray.t, to_: number) => Uint8ClampedArray.t;
  copyWithinFrom: (arg0: Uint8ClampedArray.t, to_: number, from: number) => Uint8ClampedArray.t;
  copyWithinFromRange: (arg0: Uint8ClampedArray.t, to_: number, start: number, end_: number) => Uint8ClampedArray.t;
  fillInPlace: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt) => Uint8ClampedArray.t;
  fillFromInPlace: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt, from: number) => Uint8ClampedArray.t;
  fillRangeInPlace: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt, start: number, end_: number) => Uint8ClampedArray.t;
  reverseInPlace: (arg0: Uint8ClampedArray.t) => Uint8ClampedArray.t;
  sortInPlace: (arg0: Uint8ClampedArray.t) => Uint8ClampedArray.t;
  sortInPlaceWith: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: Uint8ClampedArray.elt) => number) => Uint8ClampedArray.t;
  includes: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt) => boolean;
  indexOf: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt) => number;
  indexOfFrom: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt, from: number) => number;
  join: (arg0: Uint8ClampedArray.t) => string;
  joinWith: (arg0: Uint8ClampedArray.t, arg1: string) => string;
  lastIndexOf: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt) => number;
  lastIndexOfFrom: (arg0: Uint8ClampedArray.t, arg1: Uint8ClampedArray.elt, from: number) => number;
  slice: (arg0: Uint8ClampedArray.t, start: number, end_: number) => Uint8ClampedArray.t;
  copy: (arg0: Uint8ClampedArray.t) => Uint8ClampedArray.t;
  sliceFrom: (arg0: Uint8ClampedArray.t, arg1: number) => Uint8ClampedArray.t;
  subarray: (arg0: Uint8ClampedArray.t, start: number, end_: number) => Uint8ClampedArray.t;
  subarrayFrom: (arg0: Uint8ClampedArray.t, arg1: number) => Uint8ClampedArray.t;
  toString: (arg0: Uint8ClampedArray.t) => string;
  toLocaleString: (arg0: Uint8ClampedArray.t) => string;
  every: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => boolean) => boolean;
  everyi: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => boolean) => Uint8ClampedArray.t;
  filteri: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => boolean) => Uint8ClampedArray.t;
  find: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => boolean) => rescript.option<Uint8ClampedArray.elt>;
  findi: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => boolean) => rescript.option<Uint8ClampedArray.elt>;
  findIndex: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => boolean) => number;
  findIndexi: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => void) => void;
  forEachi: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => void) => void;
  map: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => B) => Uint8ClampedArray.typed_array<B>;
  mapi: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => B) => Uint8ClampedArray.typed_array<B>;
  reduce: (arg0: Uint8ClampedArray.t, arg1: (arg0: B, arg1: Uint8ClampedArray.elt) => B, arg2: B) => B;
  reducei: (arg0: Uint8ClampedArray.t, arg1: (arg0: B, arg1: Uint8ClampedArray.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Uint8ClampedArray.t, arg1: (arg0: B, arg1: Uint8ClampedArray.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Uint8ClampedArray.t, arg1: (arg0: B, arg1: Uint8ClampedArray.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt) => boolean) => boolean;
  somei: (arg0: Uint8ClampedArray.t, arg1: (arg0: Uint8ClampedArray.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Uint8ClampedArray.elt[]) => Uint8ClampedArray.t;
  fromBuffer: (arg0: array_buffer) => Uint8ClampedArray.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Uint8ClampedArray.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Uint8ClampedArray.t;
  fromLength: (arg0: number) => Uint8ClampedArray.t;
  from: (arg0: array_like<Uint8ClampedArray.elt>) => Uint8ClampedArray.t;
};
export const Uint8ClampedArray: Uint8ClampedArray;

declare namespace Int16Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Int16Array.typed_array", [A]>;
  type t = Int16Array.typed_array<Int16Array.elt>;
}
export type Int16Array = {
  unsafe_get: (arg0: Int16Array.t, arg1: number) => Int16Array.elt;
  unsafe_set: (arg0: Int16Array.t, arg1: number, arg2: Int16Array.elt) => void;
  buffer: (arg0: Int16Array.t) => array_buffer;
  byteLength: (arg0: Int16Array.t) => number;
  byteOffset: (arg0: Int16Array.t) => number;
  setArray: (arg0: Int16Array.t, arg1: Int16Array.elt[]) => void;
  setArrayOffset: (arg0: Int16Array.t, arg1: Int16Array.elt[], arg2: number) => void;
  length: (arg0: Int16Array.t) => number;
  copyWithin: (arg0: Int16Array.t, to_: number) => Int16Array.t;
  copyWithinFrom: (arg0: Int16Array.t, to_: number, from: number) => Int16Array.t;
  copyWithinFromRange: (arg0: Int16Array.t, to_: number, start: number, end_: number) => Int16Array.t;
  fillInPlace: (arg0: Int16Array.t, arg1: Int16Array.elt) => Int16Array.t;
  fillFromInPlace: (arg0: Int16Array.t, arg1: Int16Array.elt, from: number) => Int16Array.t;
  fillRangeInPlace: (arg0: Int16Array.t, arg1: Int16Array.elt, start: number, end_: number) => Int16Array.t;
  reverseInPlace: (arg0: Int16Array.t) => Int16Array.t;
  sortInPlace: (arg0: Int16Array.t) => Int16Array.t;
  sortInPlaceWith: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: Int16Array.elt) => number) => Int16Array.t;
  includes: (arg0: Int16Array.t, arg1: Int16Array.elt) => boolean;
  indexOf: (arg0: Int16Array.t, arg1: Int16Array.elt) => number;
  indexOfFrom: (arg0: Int16Array.t, arg1: Int16Array.elt, from: number) => number;
  join: (arg0: Int16Array.t) => string;
  joinWith: (arg0: Int16Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Int16Array.t, arg1: Int16Array.elt) => number;
  lastIndexOfFrom: (arg0: Int16Array.t, arg1: Int16Array.elt, from: number) => number;
  slice: (arg0: Int16Array.t, start: number, end_: number) => Int16Array.t;
  copy: (arg0: Int16Array.t) => Int16Array.t;
  sliceFrom: (arg0: Int16Array.t, arg1: number) => Int16Array.t;
  subarray: (arg0: Int16Array.t, start: number, end_: number) => Int16Array.t;
  subarrayFrom: (arg0: Int16Array.t, arg1: number) => Int16Array.t;
  toString: (arg0: Int16Array.t) => string;
  toLocaleString: (arg0: Int16Array.t) => string;
  every: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => boolean) => boolean;
  everyi: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => boolean) => Int16Array.t;
  filteri: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => boolean) => Int16Array.t;
  find: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => boolean) => rescript.option<Int16Array.elt>;
  findi: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => boolean) => rescript.option<Int16Array.elt>;
  findIndex: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => boolean) => number;
  findIndexi: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => void) => void;
  forEachi: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => void) => void;
  map: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => B) => Int16Array.typed_array<B>;
  mapi: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => B) => Int16Array.typed_array<B>;
  reduce: (arg0: Int16Array.t, arg1: (arg0: B, arg1: Int16Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Int16Array.t, arg1: (arg0: B, arg1: Int16Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Int16Array.t, arg1: (arg0: B, arg1: Int16Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Int16Array.t, arg1: (arg0: B, arg1: Int16Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt) => boolean) => boolean;
  somei: (arg0: Int16Array.t, arg1: (arg0: Int16Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Int16Array.elt[]) => Int16Array.t;
  fromBuffer: (arg0: array_buffer) => Int16Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Int16Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Int16Array.t;
  fromLength: (arg0: number) => Int16Array.t;
  from: (arg0: array_like<Int16Array.elt>) => Int16Array.t;
};
export const Int16Array: Int16Array;

declare namespace Uint16Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Uint16Array.typed_array", [A]>;
  type t = Uint16Array.typed_array<Uint16Array.elt>;
}
export type Uint16Array = {
  unsafe_get: (arg0: Uint16Array.t, arg1: number) => Uint16Array.elt;
  unsafe_set: (arg0: Uint16Array.t, arg1: number, arg2: Uint16Array.elt) => void;
  buffer: (arg0: Uint16Array.t) => array_buffer;
  byteLength: (arg0: Uint16Array.t) => number;
  byteOffset: (arg0: Uint16Array.t) => number;
  setArray: (arg0: Uint16Array.t, arg1: Uint16Array.elt[]) => void;
  setArrayOffset: (arg0: Uint16Array.t, arg1: Uint16Array.elt[], arg2: number) => void;
  length: (arg0: Uint16Array.t) => number;
  copyWithin: (arg0: Uint16Array.t, to_: number) => Uint16Array.t;
  copyWithinFrom: (arg0: Uint16Array.t, to_: number, from: number) => Uint16Array.t;
  copyWithinFromRange: (arg0: Uint16Array.t, to_: number, start: number, end_: number) => Uint16Array.t;
  fillInPlace: (arg0: Uint16Array.t, arg1: Uint16Array.elt) => Uint16Array.t;
  fillFromInPlace: (arg0: Uint16Array.t, arg1: Uint16Array.elt, from: number) => Uint16Array.t;
  fillRangeInPlace: (arg0: Uint16Array.t, arg1: Uint16Array.elt, start: number, end_: number) => Uint16Array.t;
  reverseInPlace: (arg0: Uint16Array.t) => Uint16Array.t;
  sortInPlace: (arg0: Uint16Array.t) => Uint16Array.t;
  sortInPlaceWith: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: Uint16Array.elt) => number) => Uint16Array.t;
  includes: (arg0: Uint16Array.t, arg1: Uint16Array.elt) => boolean;
  indexOf: (arg0: Uint16Array.t, arg1: Uint16Array.elt) => number;
  indexOfFrom: (arg0: Uint16Array.t, arg1: Uint16Array.elt, from: number) => number;
  join: (arg0: Uint16Array.t) => string;
  joinWith: (arg0: Uint16Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Uint16Array.t, arg1: Uint16Array.elt) => number;
  lastIndexOfFrom: (arg0: Uint16Array.t, arg1: Uint16Array.elt, from: number) => number;
  slice: (arg0: Uint16Array.t, start: number, end_: number) => Uint16Array.t;
  copy: (arg0: Uint16Array.t) => Uint16Array.t;
  sliceFrom: (arg0: Uint16Array.t, arg1: number) => Uint16Array.t;
  subarray: (arg0: Uint16Array.t, start: number, end_: number) => Uint16Array.t;
  subarrayFrom: (arg0: Uint16Array.t, arg1: number) => Uint16Array.t;
  toString: (arg0: Uint16Array.t) => string;
  toLocaleString: (arg0: Uint16Array.t) => string;
  every: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => boolean) => boolean;
  everyi: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => boolean) => Uint16Array.t;
  filteri: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => boolean) => Uint16Array.t;
  find: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => boolean) => rescript.option<Uint16Array.elt>;
  findi: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => boolean) => rescript.option<Uint16Array.elt>;
  findIndex: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => boolean) => number;
  findIndexi: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => void) => void;
  forEachi: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => void) => void;
  map: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => B) => Uint16Array.typed_array<B>;
  mapi: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => B) => Uint16Array.typed_array<B>;
  reduce: (arg0: Uint16Array.t, arg1: (arg0: B, arg1: Uint16Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Uint16Array.t, arg1: (arg0: B, arg1: Uint16Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Uint16Array.t, arg1: (arg0: B, arg1: Uint16Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Uint16Array.t, arg1: (arg0: B, arg1: Uint16Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt) => boolean) => boolean;
  somei: (arg0: Uint16Array.t, arg1: (arg0: Uint16Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Uint16Array.elt[]) => Uint16Array.t;
  fromBuffer: (arg0: array_buffer) => Uint16Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Uint16Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Uint16Array.t;
  fromLength: (arg0: number) => Uint16Array.t;
  from: (arg0: array_like<Uint16Array.elt>) => Uint16Array.t;
};
export const Uint16Array: Uint16Array;

declare namespace Int32Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Int32Array.typed_array", [A]>;
  type t = Int32Array.typed_array<Int32Array.elt>;
}
export type Int32Array = {
  unsafe_get: (arg0: Int32Array.t, arg1: number) => Int32Array.elt;
  unsafe_set: (arg0: Int32Array.t, arg1: number, arg2: Int32Array.elt) => void;
  buffer: (arg0: Int32Array.t) => array_buffer;
  byteLength: (arg0: Int32Array.t) => number;
  byteOffset: (arg0: Int32Array.t) => number;
  setArray: (arg0: Int32Array.t, arg1: Int32Array.elt[]) => void;
  setArrayOffset: (arg0: Int32Array.t, arg1: Int32Array.elt[], arg2: number) => void;
  length: (arg0: Int32Array.t) => number;
  copyWithin: (arg0: Int32Array.t, to_: number) => Int32Array.t;
  copyWithinFrom: (arg0: Int32Array.t, to_: number, from: number) => Int32Array.t;
  copyWithinFromRange: (arg0: Int32Array.t, to_: number, start: number, end_: number) => Int32Array.t;
  fillInPlace: (arg0: Int32Array.t, arg1: Int32Array.elt) => Int32Array.t;
  fillFromInPlace: (arg0: Int32Array.t, arg1: Int32Array.elt, from: number) => Int32Array.t;
  fillRangeInPlace: (arg0: Int32Array.t, arg1: Int32Array.elt, start: number, end_: number) => Int32Array.t;
  reverseInPlace: (arg0: Int32Array.t) => Int32Array.t;
  sortInPlace: (arg0: Int32Array.t) => Int32Array.t;
  sortInPlaceWith: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: Int32Array.elt) => number) => Int32Array.t;
  includes: (arg0: Int32Array.t, arg1: Int32Array.elt) => boolean;
  indexOf: (arg0: Int32Array.t, arg1: Int32Array.elt) => number;
  indexOfFrom: (arg0: Int32Array.t, arg1: Int32Array.elt, from: number) => number;
  join: (arg0: Int32Array.t) => string;
  joinWith: (arg0: Int32Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Int32Array.t, arg1: Int32Array.elt) => number;
  lastIndexOfFrom: (arg0: Int32Array.t, arg1: Int32Array.elt, from: number) => number;
  slice: (arg0: Int32Array.t, start: number, end_: number) => Int32Array.t;
  copy: (arg0: Int32Array.t) => Int32Array.t;
  sliceFrom: (arg0: Int32Array.t, arg1: number) => Int32Array.t;
  subarray: (arg0: Int32Array.t, start: number, end_: number) => Int32Array.t;
  subarrayFrom: (arg0: Int32Array.t, arg1: number) => Int32Array.t;
  toString: (arg0: Int32Array.t) => string;
  toLocaleString: (arg0: Int32Array.t) => string;
  every: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => boolean) => boolean;
  everyi: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => boolean) => Int32Array.t;
  filteri: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => boolean) => Int32Array.t;
  find: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => boolean) => rescript.option<Int32Array.elt>;
  findi: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => boolean) => rescript.option<Int32Array.elt>;
  findIndex: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => boolean) => number;
  findIndexi: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => void) => void;
  forEachi: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => void) => void;
  map: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => B) => Int32Array.typed_array<B>;
  mapi: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => B) => Int32Array.typed_array<B>;
  reduce: (arg0: Int32Array.t, arg1: (arg0: B, arg1: Int32Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Int32Array.t, arg1: (arg0: B, arg1: Int32Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Int32Array.t, arg1: (arg0: B, arg1: Int32Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Int32Array.t, arg1: (arg0: B, arg1: Int32Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt) => boolean) => boolean;
  somei: (arg0: Int32Array.t, arg1: (arg0: Int32Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Int32Array.elt[]) => Int32Array.t;
  fromBuffer: (arg0: array_buffer) => Int32Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Int32Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Int32Array.t;
  fromLength: (arg0: number) => Int32Array.t;
  from: (arg0: array_like<Int32Array.elt>) => Int32Array.t;
};
export const Int32Array: Int32Array;

declare namespace Uint32Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Uint32Array.typed_array", [A]>;
  type t = Uint32Array.typed_array<Uint32Array.elt>;
}
export type Uint32Array = {
  unsafe_get: (arg0: Uint32Array.t, arg1: number) => Uint32Array.elt;
  unsafe_set: (arg0: Uint32Array.t, arg1: number, arg2: Uint32Array.elt) => void;
  buffer: (arg0: Uint32Array.t) => array_buffer;
  byteLength: (arg0: Uint32Array.t) => number;
  byteOffset: (arg0: Uint32Array.t) => number;
  setArray: (arg0: Uint32Array.t, arg1: Uint32Array.elt[]) => void;
  setArrayOffset: (arg0: Uint32Array.t, arg1: Uint32Array.elt[], arg2: number) => void;
  length: (arg0: Uint32Array.t) => number;
  copyWithin: (arg0: Uint32Array.t, to_: number) => Uint32Array.t;
  copyWithinFrom: (arg0: Uint32Array.t, to_: number, from: number) => Uint32Array.t;
  copyWithinFromRange: (arg0: Uint32Array.t, to_: number, start: number, end_: number) => Uint32Array.t;
  fillInPlace: (arg0: Uint32Array.t, arg1: Uint32Array.elt) => Uint32Array.t;
  fillFromInPlace: (arg0: Uint32Array.t, arg1: Uint32Array.elt, from: number) => Uint32Array.t;
  fillRangeInPlace: (arg0: Uint32Array.t, arg1: Uint32Array.elt, start: number, end_: number) => Uint32Array.t;
  reverseInPlace: (arg0: Uint32Array.t) => Uint32Array.t;
  sortInPlace: (arg0: Uint32Array.t) => Uint32Array.t;
  sortInPlaceWith: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: Uint32Array.elt) => number) => Uint32Array.t;
  includes: (arg0: Uint32Array.t, arg1: Uint32Array.elt) => boolean;
  indexOf: (arg0: Uint32Array.t, arg1: Uint32Array.elt) => number;
  indexOfFrom: (arg0: Uint32Array.t, arg1: Uint32Array.elt, from: number) => number;
  join: (arg0: Uint32Array.t) => string;
  joinWith: (arg0: Uint32Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Uint32Array.t, arg1: Uint32Array.elt) => number;
  lastIndexOfFrom: (arg0: Uint32Array.t, arg1: Uint32Array.elt, from: number) => number;
  slice: (arg0: Uint32Array.t, start: number, end_: number) => Uint32Array.t;
  copy: (arg0: Uint32Array.t) => Uint32Array.t;
  sliceFrom: (arg0: Uint32Array.t, arg1: number) => Uint32Array.t;
  subarray: (arg0: Uint32Array.t, start: number, end_: number) => Uint32Array.t;
  subarrayFrom: (arg0: Uint32Array.t, arg1: number) => Uint32Array.t;
  toString: (arg0: Uint32Array.t) => string;
  toLocaleString: (arg0: Uint32Array.t) => string;
  every: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => boolean) => boolean;
  everyi: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => boolean) => Uint32Array.t;
  filteri: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => boolean) => Uint32Array.t;
  find: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => boolean) => rescript.option<Uint32Array.elt>;
  findi: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => boolean) => rescript.option<Uint32Array.elt>;
  findIndex: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => boolean) => number;
  findIndexi: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => void) => void;
  forEachi: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => void) => void;
  map: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => B) => Uint32Array.typed_array<B>;
  mapi: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => B) => Uint32Array.typed_array<B>;
  reduce: (arg0: Uint32Array.t, arg1: (arg0: B, arg1: Uint32Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Uint32Array.t, arg1: (arg0: B, arg1: Uint32Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Uint32Array.t, arg1: (arg0: B, arg1: Uint32Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Uint32Array.t, arg1: (arg0: B, arg1: Uint32Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt) => boolean) => boolean;
  somei: (arg0: Uint32Array.t, arg1: (arg0: Uint32Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Uint32Array.elt[]) => Uint32Array.t;
  fromBuffer: (arg0: array_buffer) => Uint32Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Uint32Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Uint32Array.t;
  fromLength: (arg0: number) => Uint32Array.t;
  from: (arg0: array_like<Uint32Array.elt>) => Uint32Array.t;
};
export const Uint32Array: Uint32Array;

declare namespace Float32Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Float32Array.typed_array", [A]>;
  type t = Float32Array.typed_array<Float32Array.elt>;
}
export type Float32Array = {
  unsafe_get: (arg0: Float32Array.t, arg1: number) => Float32Array.elt;
  unsafe_set: (arg0: Float32Array.t, arg1: number, arg2: Float32Array.elt) => void;
  buffer: (arg0: Float32Array.t) => array_buffer;
  byteLength: (arg0: Float32Array.t) => number;
  byteOffset: (arg0: Float32Array.t) => number;
  setArray: (arg0: Float32Array.t, arg1: Float32Array.elt[]) => void;
  setArrayOffset: (arg0: Float32Array.t, arg1: Float32Array.elt[], arg2: number) => void;
  length: (arg0: Float32Array.t) => number;
  copyWithin: (arg0: Float32Array.t, to_: number) => Float32Array.t;
  copyWithinFrom: (arg0: Float32Array.t, to_: number, from: number) => Float32Array.t;
  copyWithinFromRange: (arg0: Float32Array.t, to_: number, start: number, end_: number) => Float32Array.t;
  fillInPlace: (arg0: Float32Array.t, arg1: Float32Array.elt) => Float32Array.t;
  fillFromInPlace: (arg0: Float32Array.t, arg1: Float32Array.elt, from: number) => Float32Array.t;
  fillRangeInPlace: (arg0: Float32Array.t, arg1: Float32Array.elt, start: number, end_: number) => Float32Array.t;
  reverseInPlace: (arg0: Float32Array.t) => Float32Array.t;
  sortInPlace: (arg0: Float32Array.t) => Float32Array.t;
  sortInPlaceWith: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: Float32Array.elt) => number) => Float32Array.t;
  includes: (arg0: Float32Array.t, arg1: Float32Array.elt) => boolean;
  indexOf: (arg0: Float32Array.t, arg1: Float32Array.elt) => number;
  indexOfFrom: (arg0: Float32Array.t, arg1: Float32Array.elt, from: number) => number;
  join: (arg0: Float32Array.t) => string;
  joinWith: (arg0: Float32Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Float32Array.t, arg1: Float32Array.elt) => number;
  lastIndexOfFrom: (arg0: Float32Array.t, arg1: Float32Array.elt, from: number) => number;
  slice: (arg0: Float32Array.t, start: number, end_: number) => Float32Array.t;
  copy: (arg0: Float32Array.t) => Float32Array.t;
  sliceFrom: (arg0: Float32Array.t, arg1: number) => Float32Array.t;
  subarray: (arg0: Float32Array.t, start: number, end_: number) => Float32Array.t;
  subarrayFrom: (arg0: Float32Array.t, arg1: number) => Float32Array.t;
  toString: (arg0: Float32Array.t) => string;
  toLocaleString: (arg0: Float32Array.t) => string;
  every: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => boolean) => boolean;
  everyi: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => boolean) => Float32Array.t;
  filteri: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => boolean) => Float32Array.t;
  find: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => boolean) => rescript.option<Float32Array.elt>;
  findi: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => boolean) => rescript.option<Float32Array.elt>;
  findIndex: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => boolean) => number;
  findIndexi: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => void) => void;
  forEachi: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => void) => void;
  map: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => B) => Float32Array.typed_array<B>;
  mapi: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => B) => Float32Array.typed_array<B>;
  reduce: (arg0: Float32Array.t, arg1: (arg0: B, arg1: Float32Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Float32Array.t, arg1: (arg0: B, arg1: Float32Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Float32Array.t, arg1: (arg0: B, arg1: Float32Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Float32Array.t, arg1: (arg0: B, arg1: Float32Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt) => boolean) => boolean;
  somei: (arg0: Float32Array.t, arg1: (arg0: Float32Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Float32Array.elt[]) => Float32Array.t;
  fromBuffer: (arg0: array_buffer) => Float32Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Float32Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Float32Array.t;
  fromLength: (arg0: number) => Float32Array.t;
  from: (arg0: array_like<Float32Array.elt>) => Float32Array.t;
};
export const Float32Array: Float32Array;

declare namespace Float64Array {
  type elt = number;
  type typed_array<A> = rescript.opaque<"Js_typed_array2.Float64Array.typed_array", [A]>;
  type t = Float64Array.typed_array<Float64Array.elt>;
}
export type Float64Array = {
  unsafe_get: (arg0: Float64Array.t, arg1: number) => Float64Array.elt;
  unsafe_set: (arg0: Float64Array.t, arg1: number, arg2: Float64Array.elt) => void;
  buffer: (arg0: Float64Array.t) => array_buffer;
  byteLength: (arg0: Float64Array.t) => number;
  byteOffset: (arg0: Float64Array.t) => number;
  setArray: (arg0: Float64Array.t, arg1: Float64Array.elt[]) => void;
  setArrayOffset: (arg0: Float64Array.t, arg1: Float64Array.elt[], arg2: number) => void;
  length: (arg0: Float64Array.t) => number;
  copyWithin: (arg0: Float64Array.t, to_: number) => Float64Array.t;
  copyWithinFrom: (arg0: Float64Array.t, to_: number, from: number) => Float64Array.t;
  copyWithinFromRange: (arg0: Float64Array.t, to_: number, start: number, end_: number) => Float64Array.t;
  fillInPlace: (arg0: Float64Array.t, arg1: Float64Array.elt) => Float64Array.t;
  fillFromInPlace: (arg0: Float64Array.t, arg1: Float64Array.elt, from: number) => Float64Array.t;
  fillRangeInPlace: (arg0: Float64Array.t, arg1: Float64Array.elt, start: number, end_: number) => Float64Array.t;
  reverseInPlace: (arg0: Float64Array.t) => Float64Array.t;
  sortInPlace: (arg0: Float64Array.t) => Float64Array.t;
  sortInPlaceWith: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: Float64Array.elt) => number) => Float64Array.t;
  includes: (arg0: Float64Array.t, arg1: Float64Array.elt) => boolean;
  indexOf: (arg0: Float64Array.t, arg1: Float64Array.elt) => number;
  indexOfFrom: (arg0: Float64Array.t, arg1: Float64Array.elt, from: number) => number;
  join: (arg0: Float64Array.t) => string;
  joinWith: (arg0: Float64Array.t, arg1: string) => string;
  lastIndexOf: (arg0: Float64Array.t, arg1: Float64Array.elt) => number;
  lastIndexOfFrom: (arg0: Float64Array.t, arg1: Float64Array.elt, from: number) => number;
  slice: (arg0: Float64Array.t, start: number, end_: number) => Float64Array.t;
  copy: (arg0: Float64Array.t) => Float64Array.t;
  sliceFrom: (arg0: Float64Array.t, arg1: number) => Float64Array.t;
  subarray: (arg0: Float64Array.t, start: number, end_: number) => Float64Array.t;
  subarrayFrom: (arg0: Float64Array.t, arg1: number) => Float64Array.t;
  toString: (arg0: Float64Array.t) => string;
  toLocaleString: (arg0: Float64Array.t) => string;
  every: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => boolean) => boolean;
  everyi: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => boolean) => boolean;
  filter: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => boolean) => Float64Array.t;
  filteri: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => boolean) => Float64Array.t;
  find: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => boolean) => rescript.option<Float64Array.elt>;
  findi: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => boolean) => rescript.option<Float64Array.elt>;
  findIndex: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => boolean) => number;
  findIndexi: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => boolean) => number;
  forEach: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => void) => void;
  forEachi: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => void) => void;
  map: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => B) => Float64Array.typed_array<B>;
  mapi: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => B) => Float64Array.typed_array<B>;
  reduce: (arg0: Float64Array.t, arg1: (arg0: B, arg1: Float64Array.elt) => B, arg2: B) => B;
  reducei: (arg0: Float64Array.t, arg1: (arg0: B, arg1: Float64Array.elt, arg2: number) => B, arg2: B) => B;
  reduceRight: (arg0: Float64Array.t, arg1: (arg0: B, arg1: Float64Array.elt) => B, arg2: B) => B;
  reduceRighti: (arg0: Float64Array.t, arg1: (arg0: B, arg1: Float64Array.elt, arg2: number) => B, arg2: B) => B;
  some: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt) => boolean) => boolean;
  somei: (arg0: Float64Array.t, arg1: (arg0: Float64Array.elt, arg1: number) => boolean) => boolean;
  _BYTES_PER_ELEMENT: number;
  make: (arg0: Float64Array.elt[]) => Float64Array.t;
  fromBuffer: (arg0: array_buffer) => Float64Array.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => Float64Array.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => Float64Array.t;
  fromLength: (arg0: number) => Float64Array.t;
  from: (arg0: array_like<Float64Array.elt>) => Float64Array.t;
};
export const Float64Array: Float64Array;

declare namespace DataView {
  type t = rescript.opaque<"Js_typed_array2.DataView.t", []>;
}
export type DataView = {
  make: (arg0: array_buffer) => DataView.t;
  fromBuffer: (arg0: array_buffer) => DataView.t;
  fromBufferOffset: (arg0: array_buffer, arg1: number) => DataView.t;
  fromBufferRange: (arg0: array_buffer, offset: number, length: number) => DataView.t;
  buffer: (arg0: DataView.t) => array_buffer;
  byteLength: (arg0: DataView.t) => number;
  byteOffset: (arg0: DataView.t) => number;
  getInt8: (arg0: DataView.t, arg1: number) => number;
  getUint8: (arg0: DataView.t, arg1: number) => number;
  getInt16: (arg0: DataView.t, arg1: number) => number;
  getInt16LittleEndian: (arg0: DataView.t, arg1: number) => number;
  getUint16: (arg0: DataView.t, arg1: number) => number;
  getUint16LittleEndian: (arg0: DataView.t, arg1: number) => number;
  getInt32: (arg0: DataView.t, arg1: number) => number;
  getInt32LittleEndian: (arg0: DataView.t, arg1: number) => number;
  getUint32: (arg0: DataView.t, arg1: number) => number;
  getUint32LittleEndian: (arg0: DataView.t, arg1: number) => number;
  getFloat32: (arg0: DataView.t, arg1: number) => number;
  getFloat32LittleEndian: (arg0: DataView.t, arg1: number) => number;
  getFloat64: (arg0: DataView.t, arg1: number) => number;
  getFloat64LittleEndian: (arg0: DataView.t, arg1: number) => number;
  setInt8: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setUint8: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setInt16: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setInt16LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setUint16: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setUint16LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setInt32: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setInt32LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setUint32: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setUint32LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setFloat32: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setFloat32LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setFloat64: (arg0: DataView.t, arg1: number, arg2: number) => void;
  setFloat64LittleEndian: (arg0: DataView.t, arg1: number, arg2: number) => void;
};
export const DataView: DataView;