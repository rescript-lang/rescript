// Generated by ReScript, PLEASE EDIT WITH CARE

import type * as rescript from "@rescript/runtime/types";
import type * as Js_array2 from "./Js_array2.js";

export type t<A> = A[];

export type array_like<A> = Js_array2.array_like<A>;

export function copyWithin<A, B>(to_: number, obj: t<A>): B;

export function copyWithinFrom<A, B>(to_: number, from_: number, obj: t<A>): B;

export function copyWithinFromRange<A, B>(
  to_: number,
  start: number,
  end_: number,
  obj: t<A>,
): B;

export function fillInPlace<A, B>(arg1: A, obj: t<A>): B;

export function fillFromInPlace<A, B>(arg1: A, from_: number, obj: t<A>): B;

export function fillRangeInPlace<A, B>(
  arg1: A,
  start: number,
  end_: number,
  obj: t<A>,
): B;

export function push<A>(arg1: A, obj: t<A>): number;

export function pushMany<A>(arg1: A[], obj: t<A>): number;

export function sortInPlaceWith<A, B>(
  arg1: (arg0: A, arg1: A) => number,
  obj: t<A>,
): B;

export function spliceInPlace<A, B>(
  pos: number,
  remove: number,
  add: A[],
  obj: t<A>,
): B;

export function removeFromInPlace<A, B>(pos: number, obj: t<A>): B;

export function removeCountInPlace<A, B>(
  pos: number,
  count: number,
  obj: t<A>,
): B;

export function unshift<A>(arg1: A, obj: t<A>): number;

export function unshiftMany<A>(arg1: A[], obj: t<A>): number;

export function concat<A, B>(arg1: A, obj: t<B>): A;

export function concatMany<A, B>(arg1: A[], obj: t<B>): A;

export function includes<A>(arg1: A, obj: t<A>): boolean;

export function indexOf<A>(arg1: A, obj: t<A>): number;

export function indexOfFrom<A>(arg1: A, from_: number, obj: t<A>): number;

export function joinWith<A>(arg1: string, obj: t<A>): string;

export function lastIndexOf<A>(arg1: A, obj: t<A>): number;

export function lastIndexOfFrom<A>(arg1: A, from_: number, obj: t<A>): number;

export function slice<A, B>(start: number, end_: number, obj: t<A>): B;

export function sliceFrom<A, B>(arg1: number, obj: t<A>): B;

export function every<A>(arg1: (arg0: A) => boolean, obj: t<A>): boolean;

export function everyi<A>(
  arg1: (arg0: A, arg1: number) => boolean,
  obj: t<A>,
): boolean;

export function filter<A, B>(arg1: (arg0: A) => boolean, obj: t<A>): B;

export function filteri<A, B>(
  arg1: (arg0: A, arg1: number) => boolean,
  obj: t<A>,
): B;

export function find<A>(
  arg1: (arg0: A) => boolean,
  obj: t<A>,
): rescript.option<A>;

export function findi<A>(
  arg1: (arg0: A, arg1: number) => boolean,
  obj: t<A>,
): rescript.option<A>;

export function findIndex<A>(arg1: (arg0: A) => boolean, obj: t<A>): number;

export function findIndexi<A>(
  arg1: (arg0: A, arg1: number) => boolean,
  obj: t<A>,
): number;

export function forEach<A>(arg1: (arg0: A) => void, obj: t<A>): void;

export function forEachi<A>(arg1: (arg0: A, arg1: number) => void, obj: t<A>): void;

export function map<A, B>(arg1: (arg0: A) => B, obj: t<A>): t<B>;

export function mapi<A, B>(arg1: (arg0: A, arg1: number) => B, obj: t<A>): t<B>;

export function reduce<A, B>(
  arg1: (arg0: A, arg1: B) => A,
  arg2: A,
  obj: t<B>,
): A;

export function reducei<A, B>(
  arg1: (arg0: A, arg1: B, arg2: number) => A,
  arg2: A,
  obj: t<B>,
): A;

export function reduceRight<A, B>(
  arg1: (arg0: A, arg1: B) => A,
  arg2: A,
  obj: t<B>,
): A;

export function reduceRighti<A, B>(
  arg1: (arg0: A, arg1: B, arg2: number) => A,
  arg2: A,
  obj: t<B>,
): A;

export function some<A>(arg1: (arg0: A) => boolean, obj: t<A>): boolean;

export function somei<A>(
  arg1: (arg0: A, arg1: number) => boolean,
  obj: t<A>,
): boolean;